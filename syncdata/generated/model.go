// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// Information about the price charged to a shop every plan period.
type AppPricingDetails interface {
	IsAppPricingDetails()
}

// Services and features purchased once by the store.
type AppPurchase interface {
	IsAppPurchase()
}

// A discount application involved in order editing that might be newly added or have new changes applied.
//
type CalculatedDiscountApplication interface {
	IsCalculatedDiscountApplication()
}

// The main embed of a comment event.
type CommentEventEmbed interface {
	IsCommentEventEmbed()
}

// The subject line of a comment event.
type CommentEventSubject interface {
	IsCommentEventSubject()
}

// Represents events preceding a customer order, such as shop sessions.
type CustomerMoment interface {
	IsCustomerMoment()
}

// The criteria (weight or price) that the field must meet based on the operator.
type DeliveryConditionCriteria interface {
	IsDeliveryConditionCriteria()
}

// Rate provided by a rate definition or a participant.
type DeliveryRateProvider interface {
	IsDeliveryRateProvider()
}

// Discount applications capture the intentions of a discount source at
// the time of application on an order's line items or shipping lines.
//
type DiscountApplication interface {
	IsDiscountApplication()
}

// An automatic discount.
type DiscountAutomatic interface {
	IsDiscountAutomatic()
}

// A code discount.
type DiscountCode interface {
	IsDiscountCode()
}

// The prerequisite quantity required for the discount to be applicable.
type DiscountCustomerBuysValue interface {
	IsDiscountCustomerBuysValue()
}

// The value of the discount and how it will be applied.
type DiscountCustomerGetsValue interface {
	IsDiscountCustomerGetsValue()
}

// The selection of customers who can use this discount.
type DiscountCustomerSelection interface {
	IsDiscountCustomerSelection()
}

// The type of discount that will be applied. Currently, only percentage off is supported.
type DiscountEffect interface {
	IsDiscountEffect()
}

// Entitled or prerequisite items on a discount. An item could be either collection or product or product_variant.
//
type DiscountItems interface {
	IsDiscountItems()
}

// The minimum subtotal or quantity requirements for the discount.
type DiscountMinimumRequirement interface {
	IsDiscountMinimumRequirement()
}

// The selection of shipping countries to which this discount applies.
type DiscountShippingDestinationSelection interface {
	IsDiscountShippingDestinationSelection()
}

// Represents an error in the input of a mutation.
type DisplayableError interface {
	IsDisplayableError()
}

// Events chronicle resource activities such as the creation of an article, the fulfillment of an order, or the
// addition of a product.
//
type Event interface {
	IsEvent()
}

// Connector to event records on a compatible host.
type HasEvents interface {
	IsHasEvents()
}

// Localization extensions associated with the specified resource. For example, the tax id for government invoice.
//
type HasLocalizationExtensions interface {
	IsHasLocalizationExtensions()
}

// Represents information about the metafields associated to the specified resource.
type HasMetafields interface {
	IsHasMetafields()
}

// Published translations associated with the resource.
type HasPublishedTranslations interface {
	IsHasPublishedTranslations()
}

// Interoperability metadata for types that directly correspond to a REST Admin API resource.
// For example, on the Product type, LegacyInteroperability returns metadata for the corresponding [Product object](https://help.shopify.com/api/reference/products/product) in the REST Admin API.
//
type LegacyInteroperability interface {
	IsLegacyInteroperability()
}

// Represents a media interface.
type Media interface {
	IsMedia()
}

// A default cursor for use in pagination.
// The default cursor can be used for next and previous navigation.
//
type Navigable interface {
	IsNavigable()
}

// An object with an ID to support global identification.
type Node interface {
	IsNode()
}

// Online Store preview URL of the object.
type OnlineStorePreviewable interface {
	IsOnlineStorePreviewable()
}

// A change that has been applied to an order.
//
type OrderStagedChange interface {
	IsOrderStagedChange()
}

// The value of the price rule.
type PriceRuleValue interface {
	IsPriceRuleValue()
}

// The value of the pricing object.
type PricingValue interface {
	IsPricingValue()
}

// Represents a resource that can be published to a channel.
// A publishable resource can be either a Product or Collection.
//
type Publishable interface {
	IsPublishable()
}

// The charge descriptors for a payments account.
type ShopifyPaymentsChargeStatementDescriptor interface {
	IsShopifyPaymentsChargeStatementDescriptor()
}

// Information about the payment instrument used for this transaction.
type TenderTransactionDetails interface {
	IsTenderTransactionDetails()
}

// Endpoint where webhooks will be delivered.
type WebhookSubscriptionEndpoint interface {
	IsWebhookSubscriptionEndpoint()
}

// Represents the access scope permission that is applicable to a merchant's shop, such as `read_orders`.
//
type AccessScope struct {
	// Description of the access scopes enabled on an api permission.
	Description string `json:"description"`
	// A human-friendly string for an access scope.
	Handle string `json:"handle"`
}

// Whether all items in the cart are entitled to the discount.
type AllDiscountItems struct {
	// Whether all items are selected. The value is hardcoded to `true`.
	AllItems bool `json:"allItems"`
}

func (AllDiscountItems) IsDiscountItems() {}

// A version of the API.
type APIVersion struct {
	// The human-readable name of the version.
	DisplayName string `json:"displayName"`
	// The unique identifier of an ApiVersion. All supported API versions have a date-based (YYYY-MM) or `unstable` handle.
	Handle string `json:"handle"`
	// Whether the version is supported by Shopify.
	Supported bool `json:"supported"`
}

// A Shopify application.
type App struct {
	// A unique application API identifier.
	APIKey string `json:"apiKey"`
	// App store page URL of the app.
	AppStoreAppURL *string `json:"appStoreAppUrl"`
	// App store page URL of the developer who created the app.
	AppStoreDeveloperURL *string `json:"appStoreDeveloperUrl"`
	// Banner image for the app.
	Banner *Image `json:"banner"`
	// Description of the app.
	Description *string `json:"description"`
	// App's developer name.
	DeveloperName *string `json:"developerName"`
	// Website of the developer who created the app.
	DeveloperURL string `json:"developerUrl"`
	// Whether the app uses the Embedded App SDK.
	Embedded bool `json:"embedded"`
	// Requirements that must be met before the app can be installed.
	FailedRequirements []*FailedRequirement `json:"failedRequirements"`
	// List of app features.
	Features []string `json:"features"`
	// Feedback from this app about the store.
	Feedback *AppFeedback `json:"feedback"`
	// Handle of the app.
	Handle *string `json:"handle"`
	// Icon that represents the app.
	Icon *Image `json:"icon"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Webpage where you can install the app.
	InstallURL *string `json:"installUrl"`
	// Corresponding AppInstallation for this shop and App.
	// Returns null if the App is not installed.
	//
	Installation *AppInstallation `json:"installation"`
	// Webpage that the app starts in.
	LaunchURL string `json:"launchUrl"`
	// Menu items for the app, which also appear as submenu items in left navigation sidebar in the Shopify admin.
	//
	NavigationItems []*NavigationItem `json:"navigationItems"`
	// Detailed information about the app pricing.
	PricingDetails *string `json:"pricingDetails"`
	// Summary of the app pricing details.
	PricingDetailsSummary string `json:"pricingDetailsSummary"`
	// Link to app privacy policy.
	PrivacyPolicyURL *string `json:"privacyPolicyUrl"`
	// Whether the app is published.
	Published bool `json:"published"`
	// Screenshots of the app.
	Screenshots []*Image `json:"screenshots"`
	// Whether the app was developed by Shopify.
	ShopifyDeveloped bool `json:"shopifyDeveloped"`
	// Name of the app.
	Title string `json:"title"`
	// Message that appears when the app is uninstalled. For example:
	// By removing this app, you will no longer be able to publish products to MySocialSite or view this app in your Shopify admin. You can re-enable this channel at any time.
	//
	UninstallMessage string `json:"uninstallMessage"`
	// Webpage where you can uninstall the app.
	UninstallURL *string `json:"uninstallUrl"`
}

func (App) IsNode() {}

type AppConnection struct {
	// A list of edges.
	Edges []*AppEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// App credits can be applied by the merchant towards future app purchases, subscriptions, or usage records in Shopify.
type AppCredit struct {
	// The amount that can be used towards future app purchases in Shopify.
	Amount *MoneyV2 `json:"amount"`
	// The date and time when the app credit was created.
	CreatedAt string `json:"createdAt"`
	// The description of the app credit.
	Description string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Whether the app credit is a test transaction.
	Test bool `json:"test"`
}

func (AppCredit) IsNode() {}

type AppCreditConnection struct {
	// A list of edges.
	Edges []*AppCreditEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `appCreditCreate` mutation.
type AppCreditCreatePayload struct {
	// The newly created app credit.
	AppCredit *AppCredit `json:"appCredit"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type AppCreditEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of AppCreditEdge.
	Node *AppCredit `json:"node"`
}

type AppEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of AppEdge.
	Node *App `json:"node"`
}

// Reports the status of shops and their resources and displays this information
// within Shopify admin. AppFeedback is used to notify merchants about steps they need to take
// to set up an app on their store.
//
type AppFeedback struct {
	// The application associated to the feedback.
	App *App `json:"app"`
	// A link to where merchants can resolve errors.
	Link *Link `json:"link"`
	// The feedback message presented to the merchant.
	Messages []*UserError `json:"messages"`
}

// Represents an installed application on a shop.
type AppInstallation struct {
	// Access scopes granted to an app by a merchant during installation.
	AccessScopes []*AccessScope `json:"accessScopes"`
	// Active subscriptions charged to a shop on a recurring basis.
	ActiveSubscriptions []*AppSubscription `json:"activeSubscriptions"`
	// All subscriptions created for a shop.
	AllSubscriptions *AppSubscriptionConnection `json:"allSubscriptions"`
	// Application which is installed.
	App *App `json:"app"`
	// Channel associated with the installed application.
	Channel *Channel `json:"channel"`
	// Credits that can be used towards future app purchases.
	Credits *AppCreditConnection `json:"credits"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Url used to launch the app.
	LaunchURL string `json:"launchUrl"`
	// One-time purchases to a shop.
	OneTimePurchases *AppPurchaseOneTimeConnection `json:"oneTimePurchases"`
	// Publication associated with the installed application.
	Publication *Publication `json:"publication"`
	// Subscriptions charge to a shop on a recurring basis.
	Subscriptions []*AppSubscription `json:"subscriptions"`
	// Webpage where you can uninstall the app.
	UninstallURL *string `json:"uninstallUrl"`
}

func (AppInstallation) IsNode() {}

type AppInstallationConnection struct {
	// A list of edges.
	Edges []*AppInstallationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type AppInstallationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of AppInstallationEdge.
	Node *AppInstallation `json:"node"`
}

// Defines the pricing model for the app subscription.
type AppPlanInput struct {
	// Usage based billing pricing details.
	AppUsagePricingDetails *AppUsagePricingInput `json:"appUsagePricingDetails,omitempty"`
	// Recurring based billing pricing details.
	AppRecurringPricingDetails *AppRecurringPricingInput `json:"appRecurringPricingDetails,omitempty"`
}

// Defines the app plan the merchant is subscribed to.
type AppPlanV2 struct {
	// Defines the pricing model for the app subscription.
	PricingDetails AppPricingDetails `json:"pricingDetails"`
}

// Services and features purchased once by a store.
type AppPurchaseOneTime struct {
	// The date and time when the app purchase was created.
	CreatedAt string `json:"createdAt"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The name of the app purchase.
	Name string `json:"name"`
	// The amount to be charged to the store for the app purchase.
	Price *MoneyV2 `json:"price"`
	// The status of the app purchase. Possible values include pending, active, declined and cancelled.
	Status AppPurchaseStatus `json:"status"`
	// Whether the app purchase is a test transaction.
	Test bool `json:"test"`
}

func (AppPurchaseOneTime) IsAppPurchase() {}
func (AppPurchaseOneTime) IsNode()        {}

type AppPurchaseOneTimeConnection struct {
	// A list of edges.
	Edges []*AppPurchaseOneTimeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `appPurchaseOneTimeCreate` mutation.
type AppPurchaseOneTimeCreatePayload struct {
	// The newly created app one-time purchase.
	AppPurchaseOneTime *AppPurchaseOneTime `json:"appPurchaseOneTime"`
	// The URL where the merchant can approve or decline the app one-time purchase.
	ConfirmationURL *string `json:"confirmationUrl"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type AppPurchaseOneTimeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of AppPurchaseOneTimeEdge.
	Node *AppPurchaseOneTime `json:"node"`
}

// Price charged every interval.
type AppRecurringPricing struct {
	// Specifies the number of days in a billing cycle of the app subscription.
	Interval AppPricingInterval `json:"interval"`
	// The amount to be charged to the store every billing interval.
	Price *MoneyV2 `json:"price"`
}

func (AppRecurringPricing) IsAppPricingDetails() {}

// Allows an app to charge per billing interval.
type AppRecurringPricingInput struct {
	// Specifies the billing frequency of the app subscription.
	Interval *AppPricingInterval `json:"interval,omitempty"`
	// The amount to be charged to the store every billing interval. The only permitted currency code is USD.
	Price *MoneyInput `json:"price,omitempty"`
}

// Provides users access to services and/or features for a duration of time.
type AppSubscription struct {
	// The date and time when the app subscription was created.
	CreatedAt string `json:"createdAt"`
	// The date and time when the current app subscription period ends.
	CurrentPeriodEnd *string `json:"currentPeriodEnd"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Attaches a plan to an app subscription.
	LineItems []*AppSubscriptionLineItem `json:"lineItems"`
	// The name of the app subscription.
	Name string `json:"name"`
	// The URL where the merchant is redirected after approving the app subscription.
	ReturnURL string `json:"returnUrl"`
	// The status of the app subscription. Possible values include pending, active, declined,
	//          expired, frozen, and cancelled.
	Status AppSubscriptionStatus `json:"status"`
	// Specifies whether the app subscription is a test transaction.
	Test bool `json:"test"`
	// The number of days of the free trial.
	TrialDays int64 `json:"trialDays"`
}

func (AppSubscription) IsNode() {}

// Return type for `appSubscriptionCancel` mutation.
type AppSubscriptionCancelPayload struct {
	// The cancelled app subscription.
	AppSubscription *AppSubscription `json:"appSubscription"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type AppSubscriptionConnection struct {
	// A list of edges.
	Edges []*AppSubscriptionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `appSubscriptionCreate` mutation.
type AppSubscriptionCreatePayload struct {
	// The newly created app subscription.
	AppSubscription *AppSubscription `json:"appSubscription"`
	// The URL where the merchant approves or declines an app subscription.
	ConfirmationURL *string `json:"confirmationUrl"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type AppSubscriptionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of AppSubscriptionEdge.
	Node *AppSubscription `json:"node"`
}

// Attaches a plan to an app subscription.
type AppSubscriptionLineItem struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// Defines the pricing model for the app subscription.
	Plan *AppPlanV2 `json:"plan"`
	// Lists the store's usage for a usage pricing plan.
	UsageRecords *AppUsageRecordConnection `json:"usageRecords"`
}

// Allows an app to add more than one plan to an app subscription.
type AppSubscriptionLineItemInput struct {
	// Defines the pricing model for the app subscription.
	Plan *AppPlanInput `json:"plan,omitempty"`
}

// Return type for `appSubscriptionLineItemUpdate` mutation.
type AppSubscriptionLineItemUpdatePayload struct {
	// The updated app subscription.
	AppSubscription *AppSubscription `json:"appSubscription"`
	// The URL where the merchant approves or declines the updated app subscription line item.
	ConfirmationURL *string `json:"confirmationUrl"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Defines the usage pricing model for the app subscription.
type AppUsagePricing struct {
	// The total usage records for interval.
	BalanceUsed *MoneyV2 `json:"balanceUsed"`
	// The limit a store can be charged for usage based pricing.
	CappedAmount *MoneyV2 `json:"cappedAmount"`
	// Specifies the interval which usage records are applied.
	Interval AppPricingInterval `json:"interval"`
	// The terms and conditions for app usage pricing.
	Terms string `json:"terms"`
}

func (AppUsagePricing) IsAppPricingDetails() {}

// Allows an app to charge a store for usage.
type AppUsagePricingInput struct {
	// The limit a customer can be charged for usage based pricing.
	CappedAmount *MoneyInput `json:"cappedAmount,omitempty"`
	// The terms and conditions for app usage.
	Terms string `json:"terms,omitempty"`
}

// Store usage for app subscriptions with usage pricing.
type AppUsageRecord struct {
	// The date and time when the usage record was created.
	CreatedAt string `json:"createdAt"`
	// The description of the app usage record.
	Description string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The price of the usage record. The only permitted currency code is USD.
	Price *MoneyV2 `json:"price"`
	// Defines the usage pricing plan the merchant is subscribed to.
	SubscriptionLineItem *AppSubscriptionLineItem `json:"subscriptionLineItem"`
}

func (AppUsageRecord) IsNode() {}

type AppUsageRecordConnection struct {
	// A list of edges.
	Edges []*AppUsageRecordEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `appUsageRecordCreate` mutation.
type AppUsageRecordCreatePayload struct {
	// The newly created app usage record.
	AppUsageRecord *AppUsageRecord `json:"appUsageRecord"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type AppUsageRecordEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of AppUsageRecordEdge.
	Node *AppUsageRecord `json:"node"`
}

// Represents a generic custom attribute.
type Attribute struct {
	// Key or name of the attribute.
	Key string `json:"key"`
	// Value of the attribute.
	Value *string `json:"value"`
}

// Specifies the input fields required for an attribute.
type AttributeInput struct {
	// Key or name of the attribute.
	Key string `json:"key,omitempty"`
	// Value of the attribute.
	Value string `json:"value,omitempty"`
}

// Automatic discount applications capture the intentions of a discount that was automatically applied.
//
type AutomaticDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// An ordered index that can be used to identify the discount application and indicate the precedence
	// of the discount application for calculations.
	//
	Index int64 `json:"index"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the discount application.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (AutomaticDiscountApplication) IsDiscountApplication() {}

// Basic events chronicle resource activities such as the creation of an article, the fulfillment of an order, or
// the addition of a product.
//
type BasicEvent struct {
	// The name of the app that created the event. Returns null when the event originates from the Shopify admin.
	AppTitle *string `json:"appTitle"`
	// Whether the event was created by an app.
	AttributeToApp bool `json:"attributeToApp"`
	// Whether the event was caused by an admin user.
	AttributeToUser bool `json:"attributeToUser"`
	// The date and time when the event was created.
	CreatedAt string `json:"createdAt"`
	// Whether the event is critical.
	CriticalAlert bool `json:"criticalAlert"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Human readable text that describes the event.
	Message string `json:"message"`
}

func (BasicEvent) IsNode()  {}
func (BasicEvent) IsEvent() {}

// An asynchronous long-running operation to fetch data in bulk.
//
// Bulk operations are created using the `bulkOperationRunQuery` mutation. After they are created,
// clients should poll the `status` field for updates. When `COMPLETED`, the `url` field contains
// a link to the data in [JSONL](http://jsonlines.org/) format.
//
// See the [bulk operations guide](https://help.shopify.com/api/guides/bulk-operations) for more details.
//
type BulkOperation struct {
	// When the bulk operation was successfully completed.
	CompletedAt *string `json:"completedAt"`
	// When the bulk operation was created.
	CreatedAt string `json:"createdAt"`
	// Error code for failed operations.
	ErrorCode *BulkOperationErrorCode `json:"errorCode"`
	// File size in bytes of the file in the `url` field.
	FileSize *string `json:"fileSize"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The running count of all objects processed.
	// For example, when fetching all products and their variants, this field counts both products and variants.
	// This field can be used to track operation progress.
	//
	ObjectCount string `json:"objectCount"`
	// URL to partial/incomplete response data (in [JSONL](http://jsonlines.org/) format) returned by a failed operation.
	// Expires **one week** after the operation fails. Returns `null` when there's no data available.
	//
	PartialDataURL *string `json:"partialDataUrl"`
	// GraphQL query document specified in `bulkOperationRunQuery`.
	Query string `json:"query"`
	// The running count of all objects processed at the root of the query.
	// For example, when fetching all products and their variants, this field counts only products.
	// This field can be used to track operation progress.
	//
	RootObjectCount string `json:"rootObjectCount"`
	// Status of the bulk operation.
	Status BulkOperationStatus `json:"status"`
	// URL to the response data in [JSONL](http://jsonlines.org/) format.
	// Expires **one week** after the operation completes.
	//
	URL *string `json:"url"`
}

func (BulkOperation) IsNode() {}

// Return type for `bulkOperationCancel` mutation.
type BulkOperationCancelPayload struct {
	// The bulk operation to be canceled.
	BulkOperation *BulkOperation `json:"bulkOperation"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `bulkOperationRunQuery` mutation.
type BulkOperationRunQueryPayload struct {
	// The newly created bulk operation.
	BulkOperation *BulkOperation `json:"bulkOperation"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Discount code applications capture the intentions of a discount code at
// the time that it is applied onto an order.
//
type CalculatedAutomaticDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The level at which the discount was applied.
	//
	AppliedTo DiscountApplicationLevel `json:"appliedTo"`
	// The description of discount application. Indicates the reason why the discount was applied.
	Description *string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (CalculatedAutomaticDiscountApplication) IsCalculatedDiscountApplication() {}

// An amount discounting the line that has been allocated by an associated discount application.
//
type CalculatedDiscountAllocation struct {
	// The money amount allocated by the discount application in shop and presentment currencies.
	AllocatedAmountSet *MoneyBag `json:"allocatedAmountSet"`
	// The discount that the allocated amount originated from.
	DiscountApplication CalculatedDiscountApplication `json:"discountApplication"`
}

type CalculatedDiscountApplicationConnection struct {
	// A list of edges.
	Edges []*CalculatedDiscountApplicationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type CalculatedDiscountApplicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CalculatedDiscountApplicationEdge.
	Node CalculatedDiscountApplication `json:"node"`
}

// Discount code applications capture the intentions of a discount code at
// the time that it is applied onto an order.
//
type CalculatedDiscountCodeApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The level at which the discount was applied.
	//
	AppliedTo DiscountApplicationLevel `json:"appliedTo"`
	// The string identifying the discount code that was used at the time of application.
	Code string `json:"code"`
	// The description of discount application. Indicates the reason why the discount was applied.
	Description *string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (CalculatedDiscountCodeApplication) IsCalculatedDiscountApplication() {}

// The computed properties for a draft order.
type CalculatedDraftOrder struct {
	// Order-level discount applied to the draft order.
	AppliedDiscount *DraftOrderAppliedDiscount `json:"appliedDiscount"`
	// The available shipping rates for the draft order. Requires a customer with a valid shipping address and at least one line item.
	AvailableShippingRates []*ShippingRate `json:"availableShippingRates"`
	// Customer who will be sent an invoice for the draft order, if there is one.
	Customer *Customer `json:"customer"`
	// Line items in the draft order with their computed properties.
	LineItems []*CalculatedDraftOrderLineItem `json:"lineItems"`
	// Line item that contains the shipping costs.
	ShippingLine *ShippingLine `json:"shippingLine"`
	// Subtotal of the line items and their discounts (does not contain shipping charges or shipping discounts, or taxes).
	//
	SubtotalPrice string `json:"subtotalPrice"`
	// Total amount of taxes charged for each line item and shipping line.
	TaxLines []*TaxLine `json:"taxLines"`
	// Total amount of the draft order (includes taxes, shipping charges, and discounts).
	TotalPrice string `json:"totalPrice"`
	// Total shipping charge for the draft order.
	TotalShippingPrice string `json:"totalShippingPrice"`
	// Total amount of taxes for the draft order.
	TotalTax string `json:"totalTax"`
}

// The computed line items for a draft order.
type CalculatedDraftOrderLineItem struct {
	// Discount applied to the line item.
	AppliedDiscount *DraftOrderAppliedDiscount `json:"appliedDiscount"`
	// Indicates if this is a product variant line item, or a custom line item.
	Custom bool `json:"custom"`
	// List of additional information (metafields) about the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// Total price with discounts applied.
	DiscountedTotal *MoneyV2 `json:"discountedTotal"`
	// Unit price with discounts applied.
	DiscountedUnitPrice *MoneyV2 `json:"discountedUnitPrice"`
	// Name of the service provider who fulfilled the order.
	//
	// Valid values are either **manual** or the name of the provider.
	// For example, **amazon**, **shipwire**.
	//
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// Image associated with the draft order line item.
	Image *Image `json:"image"`
	// Indicates whether the line item represents the puchase of a gift card.
	IsGiftCard bool `json:"isGiftCard"`
	// Name of the product.
	Name string `json:"name"`
	// Total price (without discounts) of the line item, based on the original unit price of the variant x quantity.
	//
	OriginalTotal *MoneyV2 `json:"originalTotal"`
	// Variant price without any discounts applied.
	OriginalUnitPrice *MoneyV2 `json:"originalUnitPrice"`
	// Product associated with the draft order line item.
	Product *Product `json:"product"`
	// Number of variant items requested in the draft order.
	Quantity int64 `json:"quantity"`
	// Whether physical shipping is required for the variant.
	RequiresShipping bool `json:"requiresShipping"`
	// Variant SKU number.
	Sku *string `json:"sku"`
	// Whether the variant is taxable.
	Taxable bool `json:"taxable"`
	// Title of the product or variant (this field only applies to custom line items).
	Title string `json:"title"`
	// Total value of the discount.
	TotalDiscount *MoneyV2 `json:"totalDiscount"`
	// Variant associated with the draft order line item.
	Variant *ProductVariant `json:"variant"`
	// Name of the variant.
	VariantTitle *string `json:"variantTitle"`
	// Name of the vendor who made the variant.
	Vendor *string `json:"vendor"`
	// Weight unit and value for a draft order line item.
	Weight *Weight `json:"weight"`
}

// A line item involved in order editing that may be newly added or have new changes applied.
//
type CalculatedLineItem struct {
	// The discounts that have been allocated onto the line item by discount applications.
	CalculatedDiscountAllocations []*CalculatedDiscountAllocation `json:"calculatedDiscountAllocations"`
	// List of additional information (metafields) about the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The discounts that have been allocated onto the line item by discount applications.
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// The total line price after discounts are applied in shop and presentment currencies.
	DiscountedUnitPriceSet *MoneyBag `json:"discountedUnitPriceSet"`
	// The total number of items that can be edited.
	EditableQuantity int64 `json:"editableQuantity"`
	// The editable quantity prior to any changes made in the current edit.
	EditableQuantityBeforeChanges int64 `json:"editableQuantityBeforeChanges"`
	// The total price of editable lines in shop and presentment currencies.
	EditableSubtotalSet *MoneyBag `json:"editableSubtotalSet"`
	// Whether the calculated line item has a staged discount.
	HasStagedLineItemDiscount bool `json:"hasStagedLineItemDiscount"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The Image object associated to the line item's variant.
	Image *Image `json:"image"`
	// Variant price without any discounts applied in shop and presentment currencies.
	OriginalUnitPriceSet *MoneyBag `json:"originalUnitPriceSet"`
	// The total number of items.
	Quantity int64 `json:"quantity"`
	// Whether the line item can be restocked or not.
	Restockable bool `json:"restockable"`
	// Whether the changes on the line item will result in a restock.
	Restocking bool `json:"restocking"`
	// Variant SKU number.
	Sku *string `json:"sku"`
	// A list of changes that affect this line item.
	StagedChanges []OrderStagedChange `json:"stagedChanges"`
	// Title of the product or variant.
	Title string `json:"title"`
	// The total price of uneditable lines in shop and presentment currencies.
	UneditableSubtotalSet *MoneyBag `json:"uneditableSubtotalSet"`
	// The product variant associated with this line item. Will be null for custom line items and items whose
	// variant has been deleted.
	//
	Variant *ProductVariant `json:"variant"`
	// Name of the variant.
	VariantTitle *string `json:"variantTitle"`
}

type CalculatedLineItemConnection struct {
	// A list of edges.
	Edges []*CalculatedLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type CalculatedLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CalculatedLineItemEdge.
	Node *CalculatedLineItem `json:"node"`
}

// Manual discount applications capture the intentions of a discount that was manually created for an order.
//
type CalculatedManualDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The level at which the discount was applied.
	//
	AppliedTo DiscountApplicationLevel `json:"appliedTo"`
	// The description of discount application. Indicates the reason why the discount was applied.
	Description *string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (CalculatedManualDiscountApplication) IsCalculatedDiscountApplication() {}

// An order with edits applied but not saved.
//
type CalculatedOrder struct {
	// Returns only the new discount applications being added to the order.
	//
	AddedDiscountApplications *CalculatedDiscountApplicationConnection `json:"addedDiscountApplications"`
	// Returns only the new line items being added to the order.
	//
	AddedLineItems *CalculatedLineItemConnection `json:"addedLineItems"`
	// Amount of the order-level discount (does not contain any line item discounts) in shop and presentment currencies.
	CartDiscountAmountSet *MoneyBag `json:"cartDiscountAmountSet"`
	// Will be true when the changes have been applied to the order.
	Committed bool `json:"committed"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Returns all items on the order that existed before starting the edit.
	// will include any changes that have been made.
	//
	LineItems *CalculatedLineItemConnection `json:"lineItems"`
	// The HTML of the customer notification for the order edit.
	NotificationPreviewHTML *string `json:"notificationPreviewHtml"`
	// The customer notification title.
	NotificationPreviewTitle string `json:"notificationPreviewTitle"`
	// The order with changes applied.
	Order *Order `json:"order"`
	// The order without any changes applied.
	//
	OriginalOrder *Order `json:"originalOrder"`
	// List of changes made on the order.
	//
	StagedChanges *OrderStagedChangeConnection `json:"stagedChanges"`
	// The sum of the quantities for the line items that contribute to the order's subtotal.
	SubtotalLineItemsQuantity int64 `json:"subtotalLineItemsQuantity"`
	// Subtotal of the line items and their discounts (does not contain shipping costs, shipping discounts) in shop and presentment currencies.
	SubtotalPriceSet *MoneyBag `json:"subtotalPriceSet"`
	// Taxes charged for the line item.
	TaxLines []*TaxLine `json:"taxLines"`
	// Total price of the order less the total amount received from the customer in shop and presentment currencies.
	TotalOutstandingSet *MoneyBag `json:"totalOutstandingSet"`
	// Total amount of the order (includes taxes and discounts) in shop and presentment currencies.
	TotalPriceSet *MoneyBag `json:"totalPriceSet"`
}

func (CalculatedOrder) IsNode() {}

// Discount code applications capture the intentions of a discount code at
// the time that it is applied onto an order.
//
type CalculatedScriptDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The level at which the discount was applied.
	//
	AppliedTo DiscountApplicationLevel `json:"appliedTo"`
	// The description of discount application. Indicates the reason why the discount was applied.
	Description *string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (CalculatedScriptDiscountApplication) IsCalculatedDiscountApplication() {}

// A channel represents an app where you sell a group of products and collections.
// A channel can be a platform or marketplace such as Facebook or Pinterest, an online store, or POS.
//
type Channel struct {
	// Underlying app used by the channel.
	App *App `json:"app"`
	// The collection publications for the list of collections published to the channel.
	CollectionPublicationsV3 *ResourcePublicationConnection `json:"collectionPublicationsV3"`
	// The list of collections published to the channel.
	Collections *CollectionConnection `json:"collections"`
	// Unique identifier for the channel.
	Handle string `json:"handle"`
	// Whether the collection is available to the channel.
	HasCollection bool `json:"hasCollection"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Name of the channel.
	Name string `json:"name"`
	// Menu items for the channel, which also appear as submenu items in left navigation sidebar in the Shopify admin.
	//
	NavigationItems []*NavigationItem `json:"navigationItems"`
	// Home page for the channel.
	OverviewPath *string `json:"overviewPath"`
	// The product publications for the products published to the channel.
	ProductPublications *ProductPublicationConnection `json:"productPublications"`
	// The product publications for the list of products published to the channel.
	ProductPublicationsV3 *ResourcePublicationConnection `json:"productPublicationsV3"`
	// The list of products published to the channel.
	Products *ProductConnection `json:"products"`
	// Whether or not this channel supports future publishing.
	SupportsFuturePublishing bool `json:"supportsFuturePublishing"`
}

func (Channel) IsNode() {}

type ChannelConnection struct {
	// A list of edges.
	Edges []*ChannelEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ChannelEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ChannelEdge.
	Node *Channel `json:"node"`
}

// Represents a collection of products.
//
type Collection struct {
	// The number of publications a resource is published to without feedback errors.
	AvailablePublicationCount int64 `json:"availablePublicationCount"`
	// The stripped description of the collection, in a single line with HTML tags removed.
	Description string `json:"description"`
	// The description of the collection, complete with HTML formatting.
	DescriptionHTML string `json:"descriptionHtml"`
	// Information about the collection that's provided through resource feedback.
	Feedback *ResourceFeedback `json:"feedback"`
	// A unique human-friendly string for the collection. Automatically generated from the collection's title.
	//
	Handle string `json:"handle"`
	// Whether the collection includes a product.
	HasProduct bool `json:"hasProduct"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The image associated with the collection.
	Image *Image `json:"image"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// The products that are included in the collection.
	Products *ProductConnection `json:"products"`
	// The number of products included in the collection.
	ProductsCount int64 `json:"productsCount"`
	// The number of publications a resource is published on.
	PublicationCount int64 `json:"publicationCount"`
	// The channels where the collection is published.
	Publications *CollectionPublicationConnection `json:"publications"`
	// Check to see whether the resource is published to a given channel.
	PublishedOnChannel bool `json:"publishedOnChannel"`
	// Check to see whether the resource is published to the calling app's channel.
	PublishedOnCurrentChannel bool `json:"publishedOnCurrentChannel"`
	// Check to see whether the resource is published to the calling app's publication.
	PublishedOnCurrentPublication bool `json:"publishedOnCurrentPublication"`
	// Check to see whether the resource is published to a given publication.
	PublishedOnPublication bool `json:"publishedOnPublication"`
	// The list of resources that are published to a publication.
	ResourcePublications *ResourcePublicationConnection `json:"resourcePublications"`
	// The list of resources that are either published or staged to be published to a publication.
	ResourcePublicationsV2 *ResourcePublicationV2Connection `json:"resourcePublicationsV2"`
	// The rules used to assign products to the collection. This applies only to smart collections.
	//
	RuleSet *CollectionRuleSet `json:"ruleSet"`
	// SEO information for the collection.
	Seo *Seo `json:"seo"`
	// The order in which the collection's products are sorted.
	SortOrder CollectionSortOrder `json:"sortOrder"`
	// The storefront ID of the collection.
	StorefrontID string `json:"storefrontId"`
	// The theme template used when viewing this collection in a store.
	TemplateSuffix *string `json:"templateSuffix"`
	// The title of the collection.
	Title string `json:"title"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
	// The list of channels that the resource is not published to.
	UnpublishedChannels *ChannelConnection `json:"unpublishedChannels"`
	// The list of publications that the resource is not published to.
	UnpublishedPublications *PublicationConnection `json:"unpublishedPublications"`
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) when the collection was last modified.
	//
	UpdatedAt string `json:"updatedAt"`
}

func (Collection) IsHasMetafields()            {}
func (Collection) IsNode()                     {}
func (Collection) IsPublishable()              {}
func (Collection) IsHasPublishedTranslations() {}

// Return type for `collectionAddProducts` mutation.
type CollectionAddProductsPayload struct {
	// The updated collection.
	Collection *Collection `json:"collection"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type CollectionConnection struct {
	// A list of edges.
	Edges []*CollectionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `collectionCreate` mutation.
type CollectionCreatePayload struct {
	// The collection that has been created.
	Collection *Collection `json:"collection"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the collection to delete.
type CollectionDeleteInput struct {
	// The ID of the collection to be deleted.
	ID string `json:"id,omitempty"`
}

// Return type for `collectionDelete` mutation.
type CollectionDeletePayload struct {
	// The ID of the collection that was deleted.
	DeletedCollectionID *string `json:"deletedCollectionId"`
	// The shop associated with the collection.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type CollectionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CollectionEdge.
	Node *Collection `json:"node"`
}

// Specifies the input fields required to create a collection.
type CollectionInput struct {
	// The description of the collection, in HTML format.
	DescriptionHTML *string `json:"descriptionHtml,omitempty"`
	// A unique human-friendly string for the collection. Automatically generated from the collection's title.
	//
	Handle *string `json:"handle,omitempty"`
	// Specifies the collection to update or create a new collection if absent.
	ID *string `json:"id,omitempty"`
	// The image associated with the collection.
	Image *ImageInput `json:"image,omitempty"`
	// Initial list of collection products. Only valid with `productCreate` and without rules.
	Products []string `json:"products,omitempty"`
	// Initial list of collection publications. Only valid with `productCreate`. This argument is deprecated: Use PublishablePublish instead.
	Publications []*CollectionPublicationInput `json:"publications,omitempty"`
	// The private metafields to associated with this product.
	PrivateMetafields []*PrivateMetafieldInput `json:"privateMetafields,omitempty"`
	// The rules used to assign products to the collection.
	//
	RuleSet *CollectionRuleSetInput `json:"ruleSet,omitempty"`
	// The theme template used when viewing the collection in a store.
	TemplateSuffix *string `json:"templateSuffix,omitempty"`
	// The order in which the collection's products are sorted.
	SortOrder *CollectionSortOrder `json:"sortOrder,omitempty"`
	// Required for creating a new collection.
	Title *string `json:"title,omitempty"`
	// The metafields to associate with this collection.
	Metafields []*MetafieldInput `json:"metafields,omitempty"`
	// SEO information for the collection.
	Seo *SEOInput `json:"seo,omitempty"`
	// Indicates whether a redirect is required after a new handle has been provided.
	// If true, then the old handle is redirected to the new one automatically.
	//
	RedirectNewHandle *bool `json:"redirectNewHandle,omitempty"`
}

// Represents the publications where a collection is published.
type CollectionPublication struct {
	// The channel where the collection will be published.
	Channel *Channel `json:"channel"`
	// The collection to be published on the publication.
	Collection *Collection `json:"collection"`
	// Whether the publication is published or not.
	IsPublished bool `json:"isPublished"`
	// The publication where the collection will be published.
	Publication *Publication `json:"publication"`
	// The date that the publication was or is going to be published.
	PublishDate string `json:"publishDate"`
}

type CollectionPublicationConnection struct {
	// A list of edges.
	Edges []*CollectionPublicationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type CollectionPublicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CollectionPublicationEdge.
	Node *CollectionPublication `json:"node"`
}

// Specifies the publications to which a collection will be published.
type CollectionPublicationInput struct {
	// The ID of the publication.
	PublicationID *string `json:"publicationId,omitempty"`
	// The ID of the channel. This argument is deprecated: Use publicationId instead.
	ChannelID *string `json:"channelId,omitempty"`
	// This argument is deprecated: Use publicationId instead.
	ChannelHandle *string `json:"channelHandle,omitempty"`
}

// Specifies a collection to publish and the sales channels to publish it to.
type CollectionPublishInput struct {
	// The collection to create or update publications for.
	ID string `json:"id,omitempty"`
	// The channels where the collection will be published.
	CollectionPublications []*CollectionPublicationInput `json:"collectionPublications,omitempty"`
}

// Return type for `collectionPublish` mutation.
type CollectionPublishPayload struct {
	// The published collection.
	Collection *Collection `json:"collection"`
	// The channels where the collection has been published.
	CollectionPublications []*CollectionPublication `json:"collectionPublications"`
	// The shop associated with the collection.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `collectionRemoveProducts` mutation.
type CollectionRemoveProductsPayload struct {
	// The asynchronous job removing the products.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `collectionReorderProducts` mutation.
type CollectionReorderProductsPayload struct {
	// The asynchronous job reordering the products.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents at rule that's used to assign products to a collection.
type CollectionRule struct {
	// The attribute that the rule focuses on (for example, `title` or `product_type`).
	Column CollectionRuleColumn `json:"column"`
	// The value that the operator is applied to (for example, `Hats`).
	Condition string `json:"condition"`
	// The type of operator that the rule is based on (for example, `equals`, `contains`, or `not_equals`).
	//
	Relation CollectionRuleRelation `json:"relation"`
}

// Collections may use rules to automatically include the matching products. This defines restrictions for a type of rule.
type CollectionRuleConditions struct {
	// Allowed relations of the rule.
	AllowedRelations []CollectionRuleRelation `json:"allowedRelations"`
	// Most commonly used relation for this rule.
	DefaultRelation CollectionRuleRelation `json:"defaultRelation"`
	// Type of the rule.
	RuleType CollectionRuleColumn `json:"ruleType"`
}

// Specifies a rule to associate with a collection.
type CollectionRuleInput struct {
	// The attribute that the rule focuses on (for example, `title` or `product_type`).
	Column CollectionRuleColumn `json:"column,omitempty"`
	// The type of operator that the rule is based on (for example, `equals`, `contains`, or `not_equals`).
	//
	Relation CollectionRuleRelation `json:"relation,omitempty"`
	// The value that the operator is applied to (for example, `Hats`).
	Condition string `json:"condition,omitempty"`
}

// The set of rules that are used to determine which products are included in the collection.
type CollectionRuleSet struct {
	// Whether products must match any or all of the rules to be included in the collection.
	// If true, then products must match one or more of the rules to be included in the collection.
	// If false, then products must match all of the rules to be included in the collection.
	//
	AppliedDisjunctively bool `json:"appliedDisjunctively"`
	// The rules used to assign products to the collection.
	Rules []*CollectionRule `json:"rules"`
}

// Specifies a rule set for the collection.
type CollectionRuleSetInput struct {
	// Whether products must match any or all of the rules to be included in the collection.
	// If true, then products must match one or more of the rules to be included in the collection.
	// If false, then products must match all of the rules to be included in the collection.
	//
	AppliedDisjunctively bool `json:"appliedDisjunctively,omitempty"`
	// The rules used to assign products to the collection.
	Rules []*CollectionRuleInput `json:"rules,omitempty"`
}

// Specifies the collection to unpublish and the sales channels to remove it from.
type CollectionUnpublishInput struct {
	// The collection to create or update publications for.
	ID string `json:"id,omitempty"`
	// The channels where the collection is published.
	CollectionPublications []*CollectionPublicationInput `json:"collectionPublications,omitempty"`
}

// Return type for `collectionUnpublish` mutation.
type CollectionUnpublishPayload struct {
	// The collection that has been unpublished.
	Collection *Collection `json:"collection"`
	// The shop associated with the collection.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `collectionUpdate` mutation.
type CollectionUpdatePayload struct {
	// The updated collection.
	Collection *Collection `json:"collection"`
	// The asynchronous job updating the products based on the new rule set.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Comment events are generated by staff members of a shop.
// They are created when a staff member adds a comment to the timeline of an order, draft order, customer, or transfer.
//
type CommentEvent struct {
	// The name of the app that created the event. Returns null when the event originates from the Shopify admin.
	AppTitle *string `json:"appTitle"`
	// The attachments associated with the comment event.
	Attachments []*CommentEventAttachment `json:"attachments"`
	// Whether the event was created by an app.
	AttributeToApp bool `json:"attributeToApp"`
	// Whether the event was caused by an admin user.
	AttributeToUser bool `json:"attributeToUser"`
	// Whether the comment event can be deleted. If true, then the comment event can be deleted.
	CanDelete bool `json:"canDelete"`
	// Whether the comment event can be edited. If true, then the comment event can be edited.
	CanEdit bool `json:"canEdit"`
	// The date and time when the event was created.
	CreatedAt string `json:"createdAt"`
	// Whether the event is critical.
	CriticalAlert bool `json:"criticalAlert"`
	// Whether the comment event has been edited. If true, then the comment event has been edited.
	Edited bool `json:"edited"`
	// The references associated with the comment event.
	Embed CommentEventEmbed `json:"embed"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Human readable text that describes the event.
	Message string `json:"message"`
	// The raw body of the comment event.
	RawMessage string `json:"rawMessage"`
	// The subject of the comment event.
	Subject CommentEventSubject `json:"subject"`
}

func (CommentEvent) IsNode()  {}
func (CommentEvent) IsEvent() {}

// A file attachment associated to a comment event.
type CommentEventAttachment struct {
	// The file extension of the comment event attachment, indicating the file format.
	FileExtension *string `json:"fileExtension"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The image attached to the comment event.
	Image *Image `json:"image"`
	// The filename of the comment event attachment.
	Name string `json:"name"`
	// The size of the attachment.
	Size int64 `json:"size"`
	// The URL of the attachment.
	URL string `json:"url"`
}

// Countries that have been defined in shipping zones for the shop.
type CountriesInShippingZones struct {
	// Countries that have been defined in shipping zones.
	CountryCodes []CountryCode `json:"countryCodes"`
	// Whether 'Rest of World' has been defined in any shipping zones.
	IncludeRestOfWorld bool `json:"includeRestOfWorld"`
}

// Holds the country specific harmonized system code and the country ISO code.
//
type CountryHarmonizedSystemCode struct {
	// Country ISO code.
	CountryCode CountryCode `json:"countryCode"`
	// Country specific harmonized system code.
	HarmonizedSystemCode string `json:"harmonizedSystemCode"`
}

type CountryHarmonizedSystemCodeConnection struct {
	// A list of edges.
	Edges []*CountryHarmonizedSystemCodeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type CountryHarmonizedSystemCodeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CountryHarmonizedSystemCodeEdge.
	Node *CountryHarmonizedSystemCode `json:"node"`
}

// Holds the country specific harmonized system code and the country ISO code.
//
type CountryHarmonizedSystemCodeInput struct {
	// Country specific harmonized system code.
	HarmonizedSystemCode string `json:"harmonizedSystemCode,omitempty"`
	// Country ISO code.
	CountryCode CountryCode `json:"countryCode,omitempty"`
}

// Specifies the input fields required to create a media object.
type CreateMediaInput struct {
	// The original source of the media object. May be an external URL or signed upload URL.
	OriginalSource string `json:"originalSource,omitempty"`
	// The alt text associated to the media.
	Alt *string `json:"alt,omitempty"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType,omitempty"`
}

// Currency formats.
type CurrencyFormats struct {
	// HTML without currency.
	MoneyFormat string `json:"moneyFormat"`
	// Email without currency.
	MoneyInEmailsFormat string `json:"moneyInEmailsFormat"`
	// HTML with currency.
	MoneyWithCurrencyFormat string `json:"moneyWithCurrencyFormat"`
	// Email with currency.
	MoneyWithCurrencyInEmailsFormat string `json:"moneyWithCurrencyInEmailsFormat"`
}

// Represents a currency setting.
type CurrencySetting struct {
	// The currency's ISO code.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// The full name of the currency.
	CurrencyName string `json:"currencyName"`
	// Flag describing whether the currency is enabled.
	Enabled bool `json:"enabled"`
	// Date and time when the exchange rate for the currency was last modified.
	RateUpdatedAt *string `json:"rateUpdatedAt"`
}

type CurrencySettingConnection struct {
	// A list of edges.
	Edges []*CurrencySettingEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type CurrencySettingEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CurrencySettingEdge.
	Node *CurrencySetting `json:"node"`
}

// Represents information about a customer of the shop, such as the customer's contact details, their order
// history, and whether they've agreed to receive email marketing.
//
type Customer struct {
	// Whether the customer has agreed to receive marketing materials.
	AcceptsMarketing bool `json:"acceptsMarketing"`
	// The date and time when the customer consented or objected to receiving marketing material by email.
	//
	AcceptsMarketingUpdatedAt string `json:"acceptsMarketingUpdatedAt"`
	// A list of addresses associated with the customer.
	Addresses []*MailingAddress `json:"addresses"`
	// The average amount that the customer spent per order.
	AverageOrderAmount *string `json:"averageOrderAmount"`
	// The average amount that the customer spent per order.
	AverageOrderAmountV2 *MoneyV2 `json:"averageOrderAmountV2"`
	// Whether the merchant can delete the customer from their store.
	//
	// A customer can be deleted from a store only if they have not yet made an order. After a customer makes an
	// order, they can't be deleted from a store.
	//
	CanDelete bool `json:"canDelete"`
	// The date and time when the customer was added to the store.
	CreatedAt string `json:"createdAt"`
	// The default address associated with the customer.
	DefaultAddress *MailingAddress `json:"defaultAddress"`
	// The full name of the customer, based on the values for first_name and last_name. If the first_name and
	// last_name are not available, then this falls back to the customer's email address, and if that is not available, the customer's phone number.
	//
	DisplayName string `json:"displayName"`
	// The customer's email address.
	Email *string `json:"email"`
	// A list of events associated with the customer.
	Events *EventConnection `json:"events"`
	// The customer's first name.
	FirstName *string `json:"firstName"`
	// Whether the customer has a note associated with them.
	HasNote bool `json:"hasNote"`
	// Whether the merchant has added timeline comments about the customer on the customer's page.
	//
	HasTimelineComment bool `json:"hasTimelineComment"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The image associated with the customer.
	Image *Image `json:"image"`
	// The customer's last name.
	LastName *string `json:"lastName"`
	// The customer's last order.
	LastOrder *Order `json:"lastOrder"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The amount of time since the customer was first added to the store.
	//
	// Example: 'about 12 years'.
	//
	LifetimeDuration string `json:"lifetimeDuration"`
	// The customer's locale.
	Locale string `json:"locale"`
	// The marketing subscription opt-in level (as described by the M3AAWG best practices guideline) that the
	// customer gave when they consented to receive marketing material by email.
	//
	// If the customer does not accept email marketing, then this property will be null.
	//
	MarketingOptInLevel *CustomerMarketingOptInLevel `json:"marketingOptInLevel"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// A unique identifier for the customer that's used with Multipass login.
	MultipassIdentifier *string `json:"multipassIdentifier"`
	// A note about the customer.
	Note *string `json:"note"`
	// A list of the customer's orders.
	Orders *OrderConnection `json:"orders"`
	// The number of orders that the customer has made at the store in their lifetime.
	//
	OrdersCount string `json:"ordersCount"`
	// The customer's phone number.
	Phone *string `json:"phone"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// The state of the customer's account with the shop.
	State CustomerState `json:"state"`
	// A comma separated list of tags that have been added to the customer.
	Tags []string `json:"tags"`
	// Whether the customer is exempt from being charged taxes on their orders.
	TaxExempt bool `json:"taxExempt"`
	// The list of tax exemptions applied to the customer.
	TaxExemptions []TaxExemption `json:"taxExemptions"`
	// The total amount that the customer has spent on orders in their lifetime.
	TotalSpent string `json:"totalSpent"`
	// The total amount that the customer has spent on orders in their lifetime.
	TotalSpentV2 *MoneyV2 `json:"totalSpentV2"`
	// The date and time when the customer was last updated.
	UpdatedAt string `json:"updatedAt"`
	// Whether the email address is formatted correctly. This does not
	// guarantee that the email address actually exists.
	//
	ValidEmailAddress bool `json:"validEmailAddress"`
	// Whether the customer has verified their email address. Defaults to `true` if the customer is created through the Shopify admin or API.
	VerifiedEmail bool `json:"verifiedEmail"`
}

func (Customer) IsNode()                   {}
func (Customer) IsCommentEventSubject()    {}
func (Customer) IsHasMetafields()          {}
func (Customer) IsLegacyInteroperability() {}
func (Customer) IsHasEvents()              {}
func (Customer) IsCommentEventEmbed()      {}

// Return type for `customerAddTaxExemptions` mutation.
type CustomerAddTaxExemptionsPayload struct {
	// The updated customer.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type CustomerConnection struct {
	// A list of edges.
	Edges []*CustomerEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `customerCreate` mutation.
type CustomerCreatePayload struct {
	// The created customer.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the customer to delete.
type CustomerDeleteInput struct {
	// The ID of the customer to delete.
	ID string `json:"id,omitempty"`
}

// Return type for `customerDelete` mutation.
type CustomerDeletePayload struct {
	// ID of the deleted customer.
	DeletedCustomerID *string `json:"deletedCustomerId"`
	// Shop of the deleted customer.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type CustomerEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CustomerEdge.
	Node *Customer `json:"node"`
}

// Return type for `customerGenerateAccountActivationUrl` mutation.
type CustomerGenerateAccountActivationURLPayload struct {
	// The newly generated account activation URL.
	AccountActivationURL *string `json:"accountActivationUrl"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Provides the fields and values to use when creating or updating a customer.
type CustomerInput struct {
	// Whether the customer has consented to receive marketing material via email.
	AcceptsMarketing *bool `json:"acceptsMarketing,omitempty"`
	// The date and time when the customer consented or objected to receiving marketing material by email. Set
	// whenever the customer consents or objects to marketing material.
	//
	AcceptsMarketingUpdatedAt *string `json:"acceptsMarketingUpdatedAt,omitempty"`
	// An input that specifies addresses for a customer.
	Addresses []*MailingAddressInput `json:"addresses,omitempty"`
	// The unique email address of the customer.
	Email *string `json:"email,omitempty"`
	// The customer's first name.
	FirstName *string `json:"firstName,omitempty"`
	// Specifies the customer to update, or creates a new customer if one doesn't exist.
	ID *string `json:"id,omitempty"`
	// The customer's last name.
	LastName *string `json:"lastName,omitempty"`
	// The customer's locale.
	Locale *string `json:"locale,omitempty"`
	// The marketing subscription opt-in level (as described by the M3AAWG best practices guideline) that was
	// enabled when the customer consented to receiving marketing material by email.
	//
	MarketingOptInLevel *CustomerMarketingOptInLevel `json:"marketingOptInLevel,omitempty"`
	// Attaches additional metadata to the customer.
	Metafields []*MetafieldInput `json:"metafields,omitempty"`
	// A note about the customer.
	Note *string `json:"note,omitempty"`
	// The unique phone number for the customer.
	Phone *string `json:"phone,omitempty"`
	// The private metafields to associated with this product.
	PrivateMetafields []*PrivateMetafieldInput `json:"privateMetafields,omitempty"`
	// A comma separated list of tags that have been added to the customer.
	Tags []string `json:"tags,omitempty"`
	// Whether the customer is exempt from paying taxes on their order.
	TaxExempt *bool `json:"taxExempt,omitempty"`
	// The list of tax exemptions to apply to the customer.
	TaxExemptions []TaxExemption `json:"taxExemptions,omitempty"`
}

// Represents a customer's activity on a shop's online store.
type CustomerJourney struct {
	// The position of the current order within the customer's order history.
	CustomerOrderIndex int64 `json:"customerOrderIndex"`
	// The amount of days between first session and order creation date. First session represents first session since the last order, or first session within the 30 day attribution window, if more than 30 days has passed since the last order.
	DaysToConversion int64 `json:"daysToConversion"`
	// The customer's first session going into the shop.
	FirstVisit *CustomerVisit `json:"firstVisit"`
	// The last session before an order is made.
	LastVisit *CustomerVisit `json:"lastVisit"`
	// Events preceding a customer order, such as shop sessions.
	Moments []CustomerMoment `json:"moments"`
}

// Represents a customer's activity on a shop's online store.
type CustomerJourneySummary struct {
	// The position of the current order within the customer's order history.
	CustomerOrderIndex *int64 `json:"customerOrderIndex"`
	// The number of days between the first session and the order creation date. The first session represents the first session since the last order, or the first session within the 30 day attribution window, if more than 30 days have passed since the last order.
	DaysToConversion *int64 `json:"daysToConversion"`
	// The customer's first session going into the shop.
	FirstVisit *CustomerVisit `json:"firstVisit"`
	// The last session before an order is made.
	LastVisit *CustomerVisit `json:"lastVisit"`
	// The events preceding a customer order, such as shop sessions.
	Moments *CustomerMomentConnection `json:"moments"`
	// The total number of customer moments associated with this order. Returns null if the order is still in the process of being attributed.
	MomentsCount *int64 `json:"momentsCount"`
	// Whether or not the attributed sessions for the order have been created yet.
	Ready bool `json:"ready"`
}

type CustomerMomentConnection struct {
	// A list of edges.
	Edges []*CustomerMomentEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type CustomerMomentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of CustomerMomentEdge.
	Node CustomerMoment `json:"node"`
}

// Return type for `customerRemoveTaxExemptions` mutation.
type CustomerRemoveTaxExemptionsPayload struct {
	// The updated customer.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerReplaceTaxExemptions` mutation.
type CustomerReplaceTaxExemptionsPayload struct {
	// The updated customer.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerUpdateDefaultAddress` mutation.
type CustomerUpdateDefaultAddressPayload struct {
	// The customer whose address was updated.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `customerUpdate` mutation.
type CustomerUpdatePayload struct {
	// The updated customer.
	Customer *Customer `json:"customer"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Information about a customer's session on a shop's online store.
type CustomerVisit struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// URL of the first page the customer landed on for the session.
	LandingPage *string `json:"landingPage"`
	// Landing page information with URL linked in HTML. For example, the first page the customer visited was store.myshopify.com/products/1.
	LandingPageHTML *string `json:"landingPageHtml"`
	// Represent actions taken by an app, on behalf of a merchant,
	// to market Shopify resources such as products, collections, and discounts.
	//
	MarketingEvent *MarketingEvent `json:"marketingEvent"`
	// When the customer moment occurred.
	OccurredAt string `json:"occurredAt"`
	// Marketing referral code from the link that the customer clicked to visit the store.
	// Supports the following URL attributes: _ref_, _source_, or _r_.
	// For example, if the URL is myshopifystore.com/products/slide?ref=j2tj1tn2, then this value is j2tj1tn2.
	//
	ReferralCode *string `json:"referralCode"`
	// Referral information with URLs linked in HTML.
	ReferralInfoHTML string `json:"referralInfoHtml"`
	// Webpage where the customer clicked a link that sent them to the online store.
	// For example, _https://randomblog.com/page1_ or _android-app://com.google.android.gm_.
	//
	ReferrerURL *string `json:"referrerUrl"`
	// Source from which the customer visited the store, such as a platform (Facebook, Google), email, direct,
	// a website domain, QR code, or unknown.
	//
	Source string `json:"source"`
	// Describes the source explicitly for first or last session.
	SourceDescription *string `json:"sourceDescription"`
	// Type of marketing tactic.
	SourceType *MarketingTactic `json:"sourceType"`
	// A set of UTM parameters gathered from the URL parameters of the referrer.
	UtmParameters *UTMParameters `json:"utmParameters"`
}

func (CustomerVisit) IsCustomerMoment() {}
func (CustomerVisit) IsNode()           {}

// Deletion events chronicle the destruction of resources (e.g. products and collections).
// Once deleted, the deletion event is the only trace of the original's existence,
// as the resource itself has been removed and can no longer be accessed.
//
type DeletionEvent struct {
	// The date and time when the deletion event for the related resource was generated.
	OccurredAt string `json:"occurredAt"`
	// The id of the resource that was deleted.
	SubjectID string `json:"subjectId"`
	// The type of resource that was deleted.
	SubjectType DeletionEventSubjectType `json:"subjectType"`
}

type DeletionEventConnection struct {
	// A list of edges.
	Edges []*DeletionEventEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DeletionEventEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DeletionEventEdge.
	Node *DeletionEvent `json:"node"`
}

// The service and the countries they are available for.
type DeliveryAvailableService struct {
	// The countries the service provider ships to.
	Countries *DeliveryCountryCodesOrRestOfWorld `json:"countries"`
	// The name of the service.
	Name string `json:"name"`
}

// Information about a carrier or service provider.
type DeliveryCarrierService struct {
	// Services offered for given destinations.
	AvailableServicesForCountries []*DeliveryAvailableService `json:"availableServicesForCountries"`
	// The properly formatted name of the service provider, ready to display.
	FormattedName *string `json:"formattedName"`
	// The logo of the service provider.
	Icon *Image `json:"icon"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The name of the service provider.
	Name *string `json:"name"`
}

func (DeliveryCarrierService) IsNode() {}

// A carrier services and their set of shop locations that can be used.
type DeliveryCarrierServiceAndLocations struct {
	// The carrier service.
	CarrierService *DeliveryCarrierService `json:"carrierService"`
	// The locations that support this carrier service.
	Locations []*Location `json:"locations"`
}

// A condition that must pass for a method definition to be applied to an order.
type DeliveryCondition struct {
	// The criteria (weight or price) that the field must meet based on the operator.
	ConditionCriteria DeliveryConditionCriteria `json:"conditionCriteria"`
	// The field to compare the criteria unit against, using the operator.
	Field DeliveryConditionField `json:"field"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The operator to compare the field and criteria.
	Operator DeliveryConditionOperator `json:"operator"`
}

func (DeliveryCondition) IsNode() {}

// A country that is used to define a zone.
type DeliveryCountry struct {
	// The ISO 3166-1 alpha-2 country code of this country and a flag indicating Rest Of World.
	Code *DeliveryCountryCodeOrRestOfWorld `json:"code"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The name of the country.
	Name string `json:"name"`
	// The regions associated with this country.
	Provinces []*DeliveryProvince `json:"provinces"`
}

func (DeliveryCountry) IsNode() {}

// A country with the name of the zone.
type DeliveryCountryAndZone struct {
	// The country in the delivery zone.
	Country *DeliveryCountry `json:"country"`
	// The name of the delivery zone.
	Zone string `json:"zone"`
}

// The ISO 3166-1 alpha-2 country code and a flag indicating Rest Of World.
type DeliveryCountryCodeOrRestOfWorld struct {
	// The country code.
	CountryCode *CountryCode `json:"countryCode"`
	// Indicates if 'Rest of World' is applied.
	RestOfWorld bool `json:"restOfWorld"`
}

// A list of ISO 3166-1 alpha-2 country codes or the 'Rest of World'.
type DeliveryCountryCodesOrRestOfWorld struct {
	// List of applicable country codes.
	CountryCodes []CountryCode `json:"countryCodes"`
	// Indicates if 'Rest of World' is applied.
	RestOfWorld bool `json:"restOfWorld"`
}

// Input fields to specify a country.
type DeliveryCountryInput struct {
	// The country code of the country.
	Code *CountryCode `json:"code,omitempty"`
	// Use Rest of World as the country.
	RestOfWorld *bool `json:"restOfWorld,omitempty"`
	// The regions associated with this country.
	Provinces []*DeliveryProvinceInput `json:"provinces,omitempty"`
	// Associate all available provinces with this country.
	IncludeAllProvinces *bool `json:"includeAllProvinces,omitempty"`
}

// Whether the shop is blocked from converting to full multi-location delivery profiles mode. If the shop is blocked, then the blocking reasons are also returned.
type DeliveryLegacyModeBlocked struct {
	// Whether the shop can convert to full multi-location delivery profiles mode.
	Blocked bool `json:"blocked"`
	// The reasons why the shop is blocked from converting to full multi-location delivery profiles mode.
	Reasons []DeliveryLegacyModeBlockedReason `json:"reasons"`
}

// A location group is a collection of active locations that share zone and delivery methods across delivery profiles.
type DeliveryLocationGroup struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// List of active locations that are part of this location group.
	Locations *LocationConnection `json:"locations"`
}

func (DeliveryLocationGroup) IsNode() {}

// Links a location group and zone with the associated method definitions in a delivery profile.
type DeliveryLocationGroupZone struct {
	// The number of method definitions in this zone.
	MethodDefinitionCounts *DeliveryMethodDefinitionCounts `json:"methodDefinitionCounts"`
	// The method definitions associated to a zone and location group in a delivery profile.
	MethodDefinitions *DeliveryMethodDefinitionConnection `json:"methodDefinitions"`
	// The zone associated to a location group in a delivery profile.
	Zone *DeliveryZone `json:"zone"`
}

type DeliveryLocationGroupZoneConnection struct {
	// A list of edges.
	Edges []*DeliveryLocationGroupZoneEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DeliveryLocationGroupZoneEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DeliveryLocationGroupZoneEdge.
	Node *DeliveryLocationGroupZone `json:"node"`
}

// Input fields for a delivery zone associated to a location group and profile.
type DeliveryLocationGroupZoneInput struct {
	// Globally unique identifier of the Zone.
	ID *string `json:"id,omitempty"`
	// The name of the zone.
	Name *string `json:"name,omitempty"`
	// Countries to associate with the zone.
	Countries []*DeliveryCountryInput `json:"countries,omitempty"`
	// Method definitions to create.
	MethodDefinitionsToCreate []*DeliveryMethodDefinitionInput `json:"methodDefinitionsToCreate,omitempty"`
	// Method definitions to update.
	MethodDefinitionsToUpdate []*DeliveryMethodDefinitionInput `json:"methodDefinitionsToUpdate,omitempty"`
}

// Delivery method.
type DeliveryMethod struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The type of the delivery method.
	MethodType DeliveryMethodType `json:"methodType"`
}

func (DeliveryMethod) IsNode() {}

// A method definition describes the delivery rate and the conditions that must be met for the method to be applied.
type DeliveryMethodDefinition struct {
	// Whether this method definition is active.
	Active bool `json:"active"`
	// The description of the method definition.
	Description *string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The method conditions that must pass for this method definition to be applied to an order.
	MethodConditions []*DeliveryCondition `json:"methodConditions"`
	// The name of the method definition.
	Name string `json:"name"`
	// Provided rate for this method definition, from a rate definition or participant.
	RateProvider DeliveryRateProvider `json:"rateProvider"`
}

func (DeliveryMethodDefinition) IsNode() {}

type DeliveryMethodDefinitionConnection struct {
	// A list of edges.
	Edges []*DeliveryMethodDefinitionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Then number of method definitions in a zone, separated into merchant-owned and participant definitions.
type DeliveryMethodDefinitionCounts struct {
	// The number of participant method definitions in the current zone.
	ParticipantDefinitionsCount int64 `json:"participantDefinitionsCount"`
	// The number of merchant-defined method definitions in the current zone.
	RateDefinitionsCount int64 `json:"rateDefinitionsCount"`
}

type DeliveryMethodDefinitionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DeliveryMethodDefinitionEdge.
	Node *DeliveryMethodDefinition `json:"node"`
}

// Input fields for a method definition.
type DeliveryMethodDefinitionInput struct {
	// Globally unique identifier of the method definition. Use only when updating a method definiton.
	ID *string `json:"id,omitempty"`
	// The name of the method definition.
	Name *string `json:"name,omitempty"`
	// The description of the method definition.
	Description *string `json:"description,omitempty"`
	// Whether or not to use this method definition during rate calculation.
	Active *bool `json:"active,omitempty"`
	// A rate definition to apply to the method definition.
	RateDefinition *DeliveryRateDefinitionInput `json:"rateDefinition,omitempty"`
	// A participant to apply to the method definition.
	Participant *DeliveryParticipantInput `json:"participant,omitempty"`
	// Weight conditions on the method definition.
	WeightConditionsToCreate []*DeliveryWeightConditionInput `json:"weightConditionsToCreate,omitempty"`
	// Price conditions on the method definition.
	PriceConditionsToCreate []*DeliveryPriceConditionInput `json:"priceConditionsToCreate,omitempty"`
	// Conditions on the method definition to update.
	ConditionsToUpdate []*DeliveryUpdateConditionInput `json:"conditionsToUpdate,omitempty"`
}

// A carrier-defined rate with possible merchant-defined fixed fee or percentage-of-rate fee.
type DeliveryParticipant struct {
	// Flag to indicate if new available services should be included.
	AdaptToNewServicesFlag bool `json:"adaptToNewServicesFlag"`
	// Use this carrier service for this participant.
	CarrierService *DeliveryCarrierService `json:"carrierService"`
	// The merchant-set fixed fee for this participant.
	FixedFee *MoneyV2 `json:"fixedFee"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Services offered by the participant and their active status.
	ParticipantServices []*DeliveryParticipantService `json:"participantServices"`
	// The merchant-set percentage-of-rate fee for this participant.
	PercentageOfRateFee float64 `json:"percentageOfRateFee"`
}

func (DeliveryParticipant) IsDeliveryRateProvider() {}
func (DeliveryParticipant) IsNode()                 {}

// Input fields for a participant.
type DeliveryParticipantInput struct {
	// Globally unique identifier of the participant.
	ID *string `json:"id,omitempty"`
	// Global identifier of the carrier service.
	CarrierServiceID *string `json:"carrierServiceId,omitempty"`
	// The merchant-set fixed fee for this participant.
	FixedFee *MoneyInput `json:"fixedFee,omitempty"`
	// The merchant-set percentage-of-rate fee for this participant.
	PercentageOfRateFee *float64 `json:"percentageOfRateFee,omitempty"`
	// Services offered by the participant and their active status.
	ParticipantServices []*DeliveryParticipantServiceInput `json:"participantServices,omitempty"`
	// Flag to indicate if new available services should be included.
	AdaptToNewServices *bool `json:"adaptToNewServices,omitempty"`
}

// A service provided by a participant.
type DeliveryParticipantService struct {
	// If the service is active or not.
	Active bool `json:"active"`
	// Name of the service.
	Name string `json:"name"`
}

// Input fields for a service provided by a participant.
type DeliveryParticipantServiceInput struct {
	// Name of the service.
	Name string `json:"name,omitempty"`
	// If the service is active or not.
	Active bool `json:"active,omitempty"`
}

// Input fields for the price-based conditions of a method definition.
type DeliveryPriceConditionInput struct {
	// The criteria for the price.
	Criteria *MoneyInput `json:"criteria,omitempty"`
	// The operator to use for comparison.
	Operator *DeliveryConditionOperator `json:"operator,omitempty"`
}

// How many product variants are in a profile. This count is capped at 500.
type DeliveryProductVariantsCount struct {
	// If the count has reached the cap of 500.
	Capped bool `json:"capped"`
	// The product variant count.
	Count int64 `json:"count"`
}

// A profile for multi-location, per-product delivery.
type DeliveryProfile struct {
	// The number of active shipping rates for the profile.
	ActiveMethodDefinitionsCount int64 `json:"activeMethodDefinitionsCount"`
	// Whether this is the default profile.
	Default bool `json:"default"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Whether this shop has enabled legacy compatibility mode for delivery profiles.
	LegacyMode bool `json:"legacyMode"`
	// The number of locations without rates defined.
	LocationsWithoutRatesCount int64 `json:"locationsWithoutRatesCount"`
	// The name of the delivery profile.
	Name string `json:"name"`
	// The number of active origin locations for the profile.
	OriginLocationCount int64 `json:"originLocationCount"`
	// The number of product variants for this profile. The count for the default profile is not supported and will return -1.
	ProductVariantsCount int64 `json:"productVariantsCount"`
	// How many product variants are in this profile.
	ProductVariantsCountV2 *DeliveryProductVariantsCount `json:"productVariantsCountV2"`
	// The products and variants associated with this profile.
	ProfileItems *DeliveryProfileItemConnection `json:"profileItems"`
	// The location groups and associated zones using this profile.
	ProfileLocationGroups []*DeliveryProfileLocationGroup `json:"profileLocationGroups"`
	// List of locations that have not been assigned to a location group for this profile.
	UnassignedLocations []*Location `json:"unassignedLocations"`
	// The number of countries with active rates to deliver to.
	ZoneCountryCount int64 `json:"zoneCountryCount"`
}

func (DeliveryProfile) IsNode() {}

type DeliveryProfileConnection struct {
	// A list of edges.
	Edges []*DeliveryProfileEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DeliveryProfileEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DeliveryProfileEdge.
	Node *DeliveryProfile `json:"node"`
}

// Input fields for a delivery profile.
type DeliveryProfileInput struct {
	// The name of the profile.
	Name *string `json:"name,omitempty"`
	// The location groups associated with the profile.
	ProfileLocationGroups []*DeliveryProfileLocationGroupInput `json:"profileLocationGroups,omitempty"`
	// The location groups to be created in the profile.
	LocationGroupsToCreate []*DeliveryProfileLocationGroupInput `json:"locationGroupsToCreate,omitempty"`
	// The location groups to be updated in the profile.
	LocationGroupsToUpdate []*DeliveryProfileLocationGroupInput `json:"locationGroupsToUpdate,omitempty"`
	// The location groups to be deleted in the profile.
	LocationGroupsToDelete []string `json:"locationGroupsToDelete,omitempty"`
	// The product variant ids to be associated with this profile.
	VariantsToAssociate []string `json:"variantsToAssociate,omitempty"`
	// The product variant ids to be dissociated from this profile and returned to the default profile.
	VariantsToDissociate []string `json:"variantsToDissociate,omitempty"`
	// Zones to delete.
	ZonesToDelete []string `json:"zonesToDelete,omitempty"`
	// Method definitions to delete.
	MethodDefinitionsToDelete []string `json:"methodDefinitionsToDelete,omitempty"`
	// Conditions to delete.
	ConditionsToDelete []string `json:"conditionsToDelete,omitempty"`
}

// A product and the subset of associated variants that are part of this delivery profile.
type DeliveryProfileItem struct {
	// A product associated with this profile.
	Product *Product `json:"product"`
	// The product variants associated with this delivery profile.
	Variants *ProductVariantConnection `json:"variants"`
}

type DeliveryProfileItemConnection struct {
	// A list of edges.
	Edges []*DeliveryProfileItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DeliveryProfileItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DeliveryProfileItemEdge.
	Node *DeliveryProfileItem `json:"node"`
}

// Links a location group with zones associated to a delivery profile.
type DeliveryProfileLocationGroup struct {
	// The countries already selected in any zone for the given location group and profile.
	CountriesInAnyZone []*DeliveryCountryAndZone `json:"countriesInAnyZone"`
	// The location group associated to a delivery profile.
	LocationGroup *DeliveryLocationGroup `json:"locationGroup"`
	// The applicable zones associated to a location group and delivery profile.
	LocationGroupZones *DeliveryLocationGroupZoneConnection `json:"locationGroupZones"`
}

// Input fields for a delivery location group associated to a profile.
type DeliveryProfileLocationGroupInput struct {
	// Globally unique identifier of the LocationGroup.
	ID *string `json:"id,omitempty"`
	// The location ids of the locations to be moved to this location group.
	Locations []string `json:"locations,omitempty"`
	// Zones to create.
	ZonesToCreate []*DeliveryLocationGroupZoneInput `json:"zonesToCreate,omitempty"`
	// Zones to update.
	ZonesToUpdate []*DeliveryLocationGroupZoneInput `json:"zonesToUpdate,omitempty"`
}

// A region that is used to define a zone.
type DeliveryProvince struct {
	// The code of this region.
	Code string `json:"code"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The name of the region.
	Name string `json:"name"`
}

func (DeliveryProvince) IsNode() {}

// The input fields to specify a region.
type DeliveryProvinceInput struct {
	// The code of the region.
	Code string `json:"code,omitempty"`
}

// The merchant-defined rate of the DeliveryMethodDefinition.
type DeliveryRateDefinition struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The price of this rate.
	Price *MoneyV2 `json:"price"`
}

func (DeliveryRateDefinition) IsDeliveryRateProvider() {}
func (DeliveryRateDefinition) IsNode()                 {}

// Input fields for a rate definition.
type DeliveryRateDefinitionInput struct {
	// Globally unique identifier of the rate definition.
	ID *string `json:"id,omitempty"`
	// The price of the rate definition.
	Price *MoneyInput `json:"price,omitempty"`
}

// Delivery shop-level settings.
type DeliverySetting struct {
	// Whether the shop is blocked from converting to full multi-location delivery profiles mode. If the shop is blocked, then the blocking reasons are also returned.
	LegacyModeBlocked *DeliveryLegacyModeBlocked `json:"legacyModeBlocked"`
	// Enables legacy compatability mode for the multi-location delivery profiles feature.
	LegacyModeProfiles bool `json:"legacyModeProfiles"`
}

// Input fields for shop-level delivery settings.
type DeliverySettingInput struct {
	// Enables legacy compatability mode for the multi-location delivery profiles feature.
	LegacyModeProfiles *bool `json:"legacyModeProfiles,omitempty"`
}

// Return type for `deliverySettingUpdate` mutation.
type DeliverySettingUpdatePayload struct {
	// The updated delivery shop level settings.
	Setting *DeliverySetting `json:"setting"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `deliveryShippingOriginAssign` mutation.
type DeliveryShippingOriginAssignPayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Input fields for updating the conditions of a method definition.
type DeliveryUpdateConditionInput struct {
	// Globally unique identifier of the condition.
	ID string `json:"id,omitempty"`
	// The value of the criteria of the condition.
	Criteria *float64 `json:"criteria,omitempty"`
	// The unit of the criteria of the condition.
	CriteriaUnit *string `json:"criteriaUnit,omitempty"`
	// The field to use, either total_weight or total_price.
	Field *DeliveryConditionField `json:"field,omitempty"`
	// The operator to use for comparison.
	Operator *DeliveryConditionOperator `json:"operator,omitempty"`
}

// Input fields for the weight-based conditions of a method definition.
type DeliveryWeightConditionInput struct {
	// The criteria for the weight.
	Criteria *WeightInput `json:"criteria,omitempty"`
	// The operator to use for comparison.
	Operator *DeliveryConditionOperator `json:"operator,omitempty"`
}

// A zone is a geographical area that contains delivery methods within a delivery profile.
type DeliveryZone struct {
	// The list of countries within the zone.
	Countries []*DeliveryCountry `json:"countries"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The name of the zone.
	Name string `json:"name"`
}

func (DeliveryZone) IsNode() {}

// An amount discounting the line that has been allocated by an associated discount application.
//
type DiscountAllocation struct {
	// Money amount allocated by the discount application.
	AllocatedAmount *MoneyV2 `json:"allocatedAmount"`
	// Money amount allocated by the discount application in shop and presentment currencies.
	AllocatedAmountSet *MoneyBag `json:"allocatedAmountSet"`
	// The discount of which this allocated amount originated from.
	DiscountApplication DiscountApplication `json:"discountApplication"`
}

// The fixed amount value of a discount.
type DiscountAmount struct {
	// The value of the discount.
	Amount *MoneyV2 `json:"amount"`
	// If true, then the discount is applied to each of the entitled items. If false, then the amount is split across all of the entitled items.
	AppliesOnEachItem bool `json:"appliesOnEachItem"`
}

func (DiscountAmount) IsDiscountCustomerGetsValue() {}

// Specifies the value of the discount and how it is applied.
type DiscountAmountInput struct {
	// The value of the discount.
	Amount *string `json:"amount,omitempty"`
	// If true, then the discount is applied to each of the entitled items. If false, then the amount is split across all of the entitled items.
	AppliesOnEachItem *bool `json:"appliesOnEachItem,omitempty"`
}

type DiscountApplicationConnection struct {
	// A list of edges.
	Edges []*DiscountApplicationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DiscountApplicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DiscountApplicationEdge.
	Node DiscountApplication `json:"node"`
}

// Return type for `discountAutomaticActivate` mutation.
type DiscountAutomaticActivatePayload struct {
	// The activated automatic discount.
	AutomaticDiscountNode *DiscountAutomaticNode `json:"automaticDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// An automatic basic discount.
type DiscountAutomaticBasic struct {
	// The number of times the discount has been used. This value is updated asynchronously and can be different than the actual usage count.
	AsyncUsageCount int64 `json:"asyncUsageCount"`
	// The date and time when the discount was created.
	CreatedAt string `json:"createdAt"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGets `json:"customerGets"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt"`
	// The minimum subtotal or quantity that's required for the discount to be applied.
	MinimumRequirement DiscountMinimumRequirement `json:"minimumRequirement"`
	// A short summary of the discount.
	ShortSummary string `json:"shortSummary"`
	// The date and time when the discount starts.
	StartsAt string `json:"startsAt"`
	// The status of the discount.
	Status DiscountStatus `json:"status"`
	// A detailed summary of the discount.
	Summary string `json:"summary"`
	// The title of the discount.
	Title string `json:"title"`
	// The number of times that the discount has been used.
	UsageCount int64 `json:"usageCount"`
}

func (DiscountAutomaticBasic) IsDiscountAutomatic() {}

// Return type for `discountAutomaticBasicCreate` mutation.
type DiscountAutomaticBasicCreatePayload struct {
	// The created automatic discount.
	AutomaticDiscountNode *DiscountAutomaticNode `json:"automaticDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Specifies input field to create or update automatic basic discount.
type DiscountAutomaticBasicInput struct {
	// The title of the discount.
	Title *string `json:"title,omitempty"`
	// The date and time when the discount starts.
	StartsAt *string `json:"startsAt,omitempty"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt,omitempty"`
	// The minimum subtotal or quantity that's required for the discount to be applied.
	MinimumRequirement *DiscountMinimumRequirementInput `json:"minimumRequirement,omitempty"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGetsInput `json:"customerGets,omitempty"`
}

// Return type for `discountAutomaticBasicUpdate` mutation.
type DiscountAutomaticBasicUpdatePayload struct {
	// The updated automatic discount.
	AutomaticDiscountNode *DiscountAutomaticNode `json:"automaticDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Return type for `discountAutomaticBulkDelete` mutation.
type DiscountAutomaticBulkDeletePayload struct {
	// The asynchronous job removing the automatic discounts.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// An automatic BXGY discount.
type DiscountAutomaticBxgy struct {
	// The number of times the discount has been used. This value is updated asynchronously and can be different than the actual usage count.
	AsyncUsageCount int64 `json:"asyncUsageCount"`
	// The date and time when the discount was created.
	CreatedAt string `json:"createdAt"`
	// The qualifying items and the quantity of each one that the customer has to buy to be eligible for the discount.
	CustomerBuys *DiscountCustomerBuys `json:"customerBuys"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGets `json:"customerGets"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt"`
	// The paginated list of events associated with the host subject.
	Events *EventConnection `json:"events"`
	// A legacy unique identifier for the discount.
	ID string `json:"id"`
	// The date and time when the discount starts.
	StartsAt string `json:"startsAt"`
	// The status of the discount.
	Status DiscountStatus `json:"status"`
	// A detailed summary of the discount.
	Summary string `json:"summary"`
	// The title of the discount.
	Title string `json:"title"`
	// The number of times that the discount has been used.
	UsageCount int64 `json:"usageCount"`
	// The maximum number of times that the discount can be applied to an order.
	UsesPerOrderLimit *int64 `json:"usesPerOrderLimit"`
}

func (DiscountAutomaticBxgy) IsDiscountAutomatic() {}
func (DiscountAutomaticBxgy) IsNode()              {}
func (DiscountAutomaticBxgy) IsHasEvents()         {}

// Return type for `discountAutomaticBxgyCreate` mutation.
type DiscountAutomaticBxgyCreatePayload struct {
	// The created automatic discount.
	AutomaticDiscountNode *DiscountAutomaticNode `json:"automaticDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Specifies input field to create or update automatic bogo discount.
type DiscountAutomaticBxgyInput struct {
	// The date and time when the discount starts.
	StartsAt *string `json:"startsAt,omitempty"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt,omitempty"`
	// The title of the discount.
	Title *string `json:"title,omitempty"`
	// The maximum number of times that the discount can be applied to an order.
	UsesPerOrderLimit *string `json:"usesPerOrderLimit,omitempty"`
	// The qualifying items and the quantity of each one that the customer has to buy to be eligible for the discount.
	CustomerBuys *DiscountCustomerBuysInput `json:"customerBuys,omitempty"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGetsInput `json:"customerGets,omitempty"`
}

// Return type for `discountAutomaticBxgyUpdate` mutation.
type DiscountAutomaticBxgyUpdatePayload struct {
	// The updated automatic discount.
	AutomaticDiscountNode *DiscountAutomaticNode `json:"automaticDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

type DiscountAutomaticConnection struct {
	// A list of edges.
	Edges []*DiscountAutomaticEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `discountAutomaticDeactivate` mutation.
type DiscountAutomaticDeactivatePayload struct {
	// The deactivated automatic discount.
	AutomaticDiscountNode *DiscountAutomaticNode `json:"automaticDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Return type for `discountAutomaticDelete` mutation.
type DiscountAutomaticDeletePayload struct {
	// The deleted automatic discount ID.
	DeletedAutomaticDiscountID *string `json:"deletedAutomaticDiscountId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

type DiscountAutomaticEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DiscountAutomaticEdge.
	Node DiscountAutomatic `json:"node"`
}

// An automatic discount wrapper node.
type DiscountAutomaticNode struct {
	// An automatic discount.
	AutomaticDiscount DiscountAutomatic `json:"automaticDiscount"`
	// The paginated list of events associated with the host subject.
	Events *EventConnection `json:"events"`
	// Globally unique identifier.
	ID string `json:"id"`
}

func (DiscountAutomaticNode) IsNode()      {}
func (DiscountAutomaticNode) IsHasEvents() {}

type DiscountAutomaticNodeConnection struct {
	// A list of edges.
	Edges []*DiscountAutomaticNodeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DiscountAutomaticNodeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DiscountAutomaticNodeEdge.
	Node *DiscountAutomaticNode `json:"node"`
}

// Return type for `discountCodeActivate` mutation.
type DiscountCodeActivatePayload struct {
	// The activated code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Discount code applications capture the intentions of a discount code at
// the time that it is applied onto an order.
//
type DiscountCodeApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The string identifying the discount code that was used at the time of application.
	Code string `json:"code"`
	// An ordered index that can be used to identify the discount application and indicate the precedence
	// of the discount application for calculations.
	//
	Index int64 `json:"index"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (DiscountCodeApplication) IsDiscountApplication() {}

// A basic code discount.
type DiscountCodeBasic struct {
	// Whether the discount can be applied only once per customer.
	AppliesOncePerCustomer bool `json:"appliesOncePerCustomer"`
	// The number of times that the discount has been used.
	AsyncUsageCount int64 `json:"asyncUsageCount"`
	// The number of redeem codes for the discount.
	CodeCount int64 `json:"codeCount"`
	// A list of redeem codes for the discount.
	Codes *DiscountRedeemCodeConnection `json:"codes"`
	// The date and time when the discount was created.
	CreatedAt string `json:"createdAt"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGets `json:"customerGets"`
	// The customers that can use the discount.
	CustomerSelection DiscountCustomerSelection `json:"customerSelection"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt"`
	// Indicates whether there are any timeline comments on the discount.
	HasTimelineComment bool `json:"hasTimelineComment"`
	// The minimum subtotal or quantity that's required for the discount to be applied.
	MinimumRequirement DiscountMinimumRequirement `json:"minimumRequirement"`
	// URLs that can be used to share the discount.
	ShareableUrls []*DiscountShareableURL `json:"shareableUrls"`
	// A short summary of the discount.
	ShortSummary string `json:"shortSummary"`
	// The date and time when the discount starts.
	StartsAt string `json:"startsAt"`
	// The status of the discount.
	Status DiscountStatus `json:"status"`
	// A detailed summary of the discount.
	Summary string `json:"summary"`
	// The title of the discount.
	Title string `json:"title"`
	// The total sales from orders where the discount was used.
	TotalSales *MoneyV2 `json:"totalSales"`
	// The maximum number of times that the discount can be used.
	UsageLimit *int64 `json:"usageLimit"`
}

func (DiscountCodeBasic) IsDiscountCode() {}

// Return type for `discountCodeBasicCreate` mutation.
type DiscountCodeBasicCreatePayload struct {
	// The created code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Specifies input field to create or update code basic discount.
type DiscountCodeBasicInput struct {
	// The title of the discount.
	Title *string `json:"title,omitempty"`
	// The date and time when the discount starts.
	StartsAt *string `json:"startsAt,omitempty"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt,omitempty"`
	// The maximum number of times that the discount can be used. For open-ended discounts, use `null`.
	UsageLimit *int64 `json:"usageLimit,omitempty"`
	// Whether the discount can be applied only once per customer.
	AppliesOncePerCustomer *bool `json:"appliesOncePerCustomer,omitempty"`
	// The minimum subtotal or quantity that's required for the discount to be applied.
	MinimumRequirement *DiscountMinimumRequirementInput `json:"minimumRequirement,omitempty"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGetsInput `json:"customerGets,omitempty"`
	// The customers that can use the discount.
	CustomerSelection *DiscountCustomerSelectionInput `json:"customerSelection,omitempty"`
	// The code to use the discount.
	Code *string `json:"code,omitempty"`
}

// Return type for `discountCodeBasicUpdate` mutation.
type DiscountCodeBasicUpdatePayload struct {
	// The updated code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Return type for `discountCodeBulkActivate` mutation.
type DiscountCodeBulkActivatePayload struct {
	// The asynchronous job that activates the code discounts.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Return type for `discountCodeBulkDeactivate` mutation.
type DiscountCodeBulkDeactivatePayload struct {
	// The asynchronous job that deactivates the code discounts.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Return type for `discountCodeBulkDelete` mutation.
type DiscountCodeBulkDeletePayload struct {
	// The asynchronous job that deletes the code discounts.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// A BXGY code discount.
type DiscountCodeBxgy struct {
	// Whether the discount can be applied only once per customer.
	AppliesOncePerCustomer bool `json:"appliesOncePerCustomer"`
	// The number of times that the discount has been used.
	AsyncUsageCount int64 `json:"asyncUsageCount"`
	// The number of redeem codes for the discount.
	CodeCount int64 `json:"codeCount"`
	// A list of redeem codes for the discount.
	Codes *DiscountRedeemCodeConnection `json:"codes"`
	// The date and time when the discount was created.
	CreatedAt string `json:"createdAt"`
	// The qualifying items and the quantity of each one that the customer has to buy to be eligible for the discount.
	CustomerBuys *DiscountCustomerBuys `json:"customerBuys"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGets `json:"customerGets"`
	// The customers that can use the discount.
	CustomerSelection DiscountCustomerSelection `json:"customerSelection"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt"`
	// Indicates whether there are any timeline comments on the discount.
	HasTimelineComment bool `json:"hasTimelineComment"`
	// URLs that can be used to share the discount.
	ShareableUrls []*DiscountShareableURL `json:"shareableUrls"`
	// The date and time when the discount starts.
	StartsAt string `json:"startsAt"`
	// The status of the discount.
	Status DiscountStatus `json:"status"`
	// A detailed summary of the discount.
	Summary string `json:"summary"`
	// The title of the discount.
	Title string `json:"title"`
	// The total sales from orders where the discount was used.
	TotalSales *MoneyV2 `json:"totalSales"`
	// The maximum number of times that the discount can be used.
	UsageLimit *int64 `json:"usageLimit"`
	// The maximum number of times that the discount can be applied to an order.
	UsesPerOrderLimit *int64 `json:"usesPerOrderLimit"`
}

func (DiscountCodeBxgy) IsDiscountCode() {}

// Return type for `discountCodeBxgyCreate` mutation.
type DiscountCodeBxgyCreatePayload struct {
	// The created code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Specifies input field to create or update a BXGY code discount.
type DiscountCodeBxgyInput struct {
	// The title of the discount.
	Title *string `json:"title,omitempty"`
	// The date and time when the discount starts.
	StartsAt *string `json:"startsAt,omitempty"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt,omitempty"`
	// The qualifying items and the quantity of each one that the customer has to buy to be eligible for the discount.
	CustomerBuys *DiscountCustomerBuysInput `json:"customerBuys,omitempty"`
	// The qualifying items in an order, the quantity of each one, and the total value of the discount.
	CustomerGets *DiscountCustomerGetsInput `json:"customerGets,omitempty"`
	// The customers that can use the discount.
	CustomerSelection *DiscountCustomerSelectionInput `json:"customerSelection,omitempty"`
	// The code to use the discount.
	Code *string `json:"code,omitempty"`
	// The maximum number of times that the discount can be used. For open-ended discounts, use `null`.
	UsageLimit *int64 `json:"usageLimit,omitempty"`
	// The maximum number of times that the discount can be applied to an order.
	UsesPerOrderLimit *int64 `json:"usesPerOrderLimit,omitempty"`
	// Whether the discount can be applied only once per customer.
	AppliesOncePerCustomer *bool `json:"appliesOncePerCustomer,omitempty"`
}

// Return type for `discountCodeBxgyUpdate` mutation.
type DiscountCodeBxgyUpdatePayload struct {
	// The updated code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Return type for `discountCodeDeactivate` mutation.
type DiscountCodeDeactivatePayload struct {
	// The deactivated code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Return type for `discountCodeDelete` mutation.
type DiscountCodeDeletePayload struct {
	// The deleted code discount ID.
	DeletedCodeDiscountID *string `json:"deletedCodeDiscountId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// A free shipping code discount.
type DiscountCodeFreeShipping struct {
	// Whether the discount can be applied only once per customer.
	AppliesOncePerCustomer bool `json:"appliesOncePerCustomer"`
	// The number of times that the discount has been used.
	AsyncUsageCount int64 `json:"asyncUsageCount"`
	// The number of redeem codes for the discount.
	CodeCount int64 `json:"codeCount"`
	// A list of redeem codes for the discount.
	Codes *DiscountRedeemCodeConnection `json:"codes"`
	// The date and time when the discount was created.
	CreatedAt string `json:"createdAt"`
	// The customers that can use the discount.
	CustomerSelection DiscountCustomerSelection `json:"customerSelection"`
	// A shipping destination that qualifies for the discount.
	DestinationSelection DiscountShippingDestinationSelection `json:"destinationSelection"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt"`
	// Indicates whether there are any timeline comments on the discount.
	HasTimelineComment bool `json:"hasTimelineComment"`
	// The maximum shipping price amount accepted to qualify for the discount.
	MaximumShippingPrice *MoneyV2 `json:"maximumShippingPrice"`
	// The minimum subtotal or quantity that's required for the discount to be applied.
	MinimumRequirement DiscountMinimumRequirement `json:"minimumRequirement"`
	// URLs that can be used to share the discount.
	ShareableUrls []*DiscountShareableURL `json:"shareableUrls"`
	// A short summary of the discount.
	ShortSummary string `json:"shortSummary"`
	// The date and time when the discount starts.
	StartsAt string `json:"startsAt"`
	// The status of the discount.
	Status DiscountStatus `json:"status"`
	// A detailed summary of the discount.
	Summary string `json:"summary"`
	// The title of the discount.
	Title string `json:"title"`
	// The total sales from orders where the discount was used.
	TotalSales *MoneyV2 `json:"totalSales"`
	// The maximum number of times that the discount can be used.
	UsageLimit *int64 `json:"usageLimit"`
}

func (DiscountCodeFreeShipping) IsDiscountCode() {}

// Return type for `discountCodeFreeShippingCreate` mutation.
type DiscountCodeFreeShippingCreatePayload struct {
	// The created code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// Specifies input field to create or update free shipping code discount.
type DiscountCodeFreeShippingInput struct {
	// The title of the discount.
	Title *string `json:"title,omitempty"`
	// The date and time when the discount starts.
	StartsAt *string `json:"startsAt,omitempty"`
	// The date and time when the discount ends. For open-ended discounts, use `null`.
	EndsAt *string `json:"endsAt,omitempty"`
	// The code to use the discount.
	Code *string `json:"code,omitempty"`
	// The maximum number of times that the discount can be used. For open-ended discounts, use `null`.
	UsageLimit *int64 `json:"usageLimit,omitempty"`
	// Whether the discount can be applied only once per customer.
	AppliesOncePerCustomer *bool `json:"appliesOncePerCustomer,omitempty"`
	// The minimum subtotal or quantity that's required for the discount to be applied.
	MinimumRequirement *DiscountMinimumRequirementInput `json:"minimumRequirement,omitempty"`
	// The customers that can use the discount.
	CustomerSelection *DiscountCustomerSelectionInput `json:"customerSelection,omitempty"`
	// A list of destinations where the discount will apply.
	Destination *DiscountShippingDestinationSelectionInput `json:"destination,omitempty"`
	// The maximum shipping price that qualifies for the discount.
	MaximumShippingPrice *string `json:"maximumShippingPrice,omitempty"`
}

// Return type for `discountCodeFreeShippingUpdate` mutation.
type DiscountCodeFreeShippingUpdatePayload struct {
	// The updated code discount.
	CodeDiscountNode *DiscountCodeNode `json:"codeDiscountNode"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// A code discount wrapper node.
type DiscountCodeNode struct {
	// A code discount.
	CodeDiscount DiscountCode `json:"codeDiscount"`
	// The paginated list of events associated with the host subject.
	Events *EventConnection `json:"events"`
	// Globally unique identifier.
	ID string `json:"id"`
}

func (DiscountCodeNode) IsNode()      {}
func (DiscountCodeNode) IsHasEvents() {}

type DiscountCodeNodeConnection struct {
	// A list of edges.
	Edges []*DiscountCodeNodeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DiscountCodeNodeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DiscountCodeNodeEdge.
	Node *DiscountCodeNode `json:"node"`
}

// Return type for `discountCodeRedeemCodeBulkDelete` mutation.
type DiscountCodeRedeemCodeBulkDeletePayload struct {
	// The asynchronous job that deletes the discount redeem codes.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*DiscountUserError `json:"userErrors"`
}

// A list of collections that the discount can have as a prerequisite or entitlement.
type DiscountCollections struct {
	// A list of collections that the discount can have as a prerequisite or entitlement.
	Collections *CollectionConnection `json:"collections"`
}

func (DiscountCollections) IsDiscountItems() {}

// Specifies the collections attached to a discount.
type DiscountCollectionsInput struct {
	// Specifies list of collection ids to add.
	Add []string `json:"add,omitempty"`
	// Specifies list of collection ids to remove.
	Remove []string `json:"remove,omitempty"`
}

// The shipping destination where the discount applies.
type DiscountCountries struct {
	// The codes for the countries where the discount can be used.
	Countries []CountryCode `json:"countries"`
	// Whether the discount is applicable to countries that have not been defined in the shop's shipping zones.
	IncludeRestOfWorld bool `json:"includeRestOfWorld"`
}

func (DiscountCountries) IsDiscountShippingDestinationSelection() {}

// Specifies a list of countries to add or remove from the free shipping discount.
type DiscountCountriesInput struct {
	// The country codes to add to the list of countries where the discount applies.
	Add []CountryCode `json:"add,omitempty"`
	// The country codes to remove from the list of countries where the discount applies.
	Remove []CountryCode `json:"remove,omitempty"`
	// Whether the discount code is applicable to countries that have not been defined in the shop's shipping zones.
	IncludeRestOfWorld *bool `json:"includeRestOfWorld,omitempty"`
}

// Whether the discount applies to all countries.
type DiscountCountryAll struct {
	// Always true when resolved to this type.
	AllCountries bool `json:"allCountries"`
}

func (DiscountCountryAll) IsDiscountShippingDestinationSelection() {}

// Whether the discount applies to all customers.
type DiscountCustomerAll struct {
	// Always true when resolved to this type.
	AllCustomers bool `json:"allCustomers"`
}

func (DiscountCustomerAll) IsDiscountCustomerSelection() {}

// The prerequisite items and prerequisite value.
type DiscountCustomerBuys struct {
	// The items required for the discount to be applicable.
	Items DiscountItems `json:"items"`
	// The prerequisite value.
	Value DiscountCustomerBuysValue `json:"value"`
}

// Specifies the prerequisite items and prerequisite quantity.
type DiscountCustomerBuysInput struct {
	// The quantity of prerequisite items.
	Value *DiscountCustomerBuysValueInput `json:"value,omitempty"`
	// The IDs of items that the customer buys. The items can be either collections or products.
	Items *DiscountItemsInput `json:"items,omitempty"`
}

// Specifies the prerequisite quantity for the discount.
type DiscountCustomerBuysValueInput struct {
	// The quantity of prerequisite items.
	Quantity *string `json:"quantity,omitempty"`
	// The prerequisite purchase amount required for the discount to be applicable.
	Amount *string `json:"amount,omitempty"`
}

// The qualifying items in an order, the quantity of each one, and the total value of the discount.
type DiscountCustomerGets struct {
	// The items to which the discount applies.
	Items DiscountItems `json:"items"`
	// Entitled quantity and the discount value.
	Value DiscountCustomerGetsValue `json:"value"`
}

// Specifies the items that will be discounted, the quantity of items that will be discounted, and the value of discount.
type DiscountCustomerGetsInput struct {
	// The quantity of items discounted and the discount value.
	Value *DiscountCustomerGetsValueInput `json:"value,omitempty"`
	// The IDs of the items that the customer gets. The items can be either collections or products.
	Items *DiscountItemsInput `json:"items,omitempty"`
}

// Specifies the quantity of items discounted and the discount value.
type DiscountCustomerGetsValueInput struct {
	// The quantity of the items that are discounted and the discount value.
	DiscountOnQuantity *DiscountOnQuantityInput `json:"discountOnQuantity,omitempty"`
	// The percentage value of the discount. Value must be between 0.00 - 1.00.
	Percentage *float64 `json:"percentage,omitempty"`
	// The value of the discount.
	DiscountAmount *DiscountAmountInput `json:"discountAmount,omitempty"`
}

// A list of customer saved searches that contain the customers to whom the discount applies.
type DiscountCustomerSavedSearches struct {
	// A list of customer saved searches that contain the customers who can use the discount.
	SavedSearches []*SavedSearch `json:"savedSearches"`
}

func (DiscountCustomerSavedSearches) IsDiscountCustomerSelection() {}

// Specifies which customer saved searches to add to or remove from the discount.
type DiscountCustomerSavedSearchesInput struct {
	// A list of customer saved searches to add to the current list of customer saved searches.
	Add []string `json:"add,omitempty"`
	// A list of customer saved searches to remove from the current list of customer saved searches.
	Remove []string `json:"remove,omitempty"`
}

// Specifies the customers who can use this discount.
type DiscountCustomerSelectionInput struct {
	// Whether all customers can use this discount.
	All *bool `json:"all,omitempty"`
	// The list of customer IDs to add or remove from the list of customers.
	Customers *DiscountCustomersInput `json:"customers,omitempty"`
	// The list of customer saved search IDs to add or remove from the list of customer saved searches.
	CustomerSavedSearches *DiscountCustomerSavedSearchesInput `json:"customerSavedSearches,omitempty"`
}

// A list of customers to whom the discount applies.
type DiscountCustomers struct {
	// A list of the customers that can use the discount.
	Customers []*Customer `json:"customers"`
}

func (DiscountCustomers) IsDiscountCustomerSelection() {}

// Specifies which customers to add to or remove from the discount.
type DiscountCustomersInput struct {
	// A list of customers to add to the current list of customers who can use the discount.
	Add []string `json:"add,omitempty"`
	// A list of customers to remove from the current list of customers who can use the discount.
	Remove []string `json:"remove,omitempty"`
}

// Specifies how the discount will be applied. Currently, only percentage off is supported.
type DiscountEffectInput struct {
	// The percentage value of the discount. Value must be between 0.00 - 1.00.
	Percentage *float64 `json:"percentage,omitempty"`
}

// Specifies the items attached to a discount.
type DiscountItemsInput struct {
	// The products and product variants that are attached to a discount.
	Products *DiscountProductsInput `json:"products,omitempty"`
	// The collections that are attached to a discount.
	Collections *DiscountCollectionsInput `json:"collections,omitempty"`
	// Whether all items should be selected.
	All *bool `json:"all,omitempty"`
}

// The minimum quantity of items required for the discount to apply.
type DiscountMinimumQuantity struct {
	// The minimum quantity of items that's required for the discount to be applied.
	GreaterThanOrEqualToQuantity string `json:"greaterThanOrEqualToQuantity"`
}

func (DiscountMinimumQuantity) IsDiscountMinimumRequirement() {}

// Specifies the quantity minimum requirements for a discount.
type DiscountMinimumQuantityInput struct {
	// The minimum quantity of items that's required for the discount to be applied.
	GreaterThanOrEqualToQuantity *string `json:"greaterThanOrEqualToQuantity,omitempty"`
}

// Specifies the quantity or subtotal minimum requirements for a discount.
type DiscountMinimumRequirementInput struct {
	// The minimum required quantity.
	Quantity *DiscountMinimumQuantityInput `json:"quantity,omitempty"`
	// The minimum required subtotal.
	Subtotal *DiscountMinimumSubtotalInput `json:"subtotal,omitempty"`
}

// The minimum subtotal required for the discount to apply.
type DiscountMinimumSubtotal struct {
	// The minimum subtotal that's required for the discount to be applied.
	GreaterThanOrEqualToSubtotal *MoneyV2 `json:"greaterThanOrEqualToSubtotal"`
}

func (DiscountMinimumSubtotal) IsDiscountMinimumRequirement() {}

// Specifies the subtotal minimum requirements for a discount.
type DiscountMinimumSubtotalInput struct {
	// The minimum subtotal that's required for the discount to be applied.
	GreaterThanOrEqualToSubtotal *string `json:"greaterThanOrEqualToSubtotal,omitempty"`
}

// The quantity of items discounted, the discount value, and how the discount will be applied.
type DiscountOnQuantity struct {
	// The discount's effect on qualifying items.
	Effect DiscountEffect `json:"effect"`
	// The number of items being discounted.
	Quantity *DiscountQuantity `json:"quantity"`
}

func (DiscountOnQuantity) IsDiscountCustomerGetsValue() {}

// Specifies the quantity of items discounted and the discount value.
type DiscountOnQuantityInput struct {
	// The quantity of items that are discounted.
	Quantity *string `json:"quantity,omitempty"`
	// The percentage value of the discount.
	Effect *DiscountEffectInput `json:"effect,omitempty"`
}

// The percentage value of the discount.
type DiscountPercentage struct {
	// The percentage value of the discount.
	Percentage float64 `json:"percentage"`
}

func (DiscountPercentage) IsDiscountEffect()            {}
func (DiscountPercentage) IsDiscountCustomerGetsValue() {}

// The entitled or prerequisite products and product variants for a discount.
type DiscountProducts struct {
	// A list of product variants that the discount can have as a prerequisite or entitlement.
	ProductVariants *ProductVariantConnection `json:"productVariants"`
	// A list of products that the discount can have as a prerequisite or entitlement.
	Products *ProductConnection `json:"products"`
}

func (DiscountProducts) IsDiscountItems() {}

// Specifies the products and product variants attached to a discount.
type DiscountProductsInput struct {
	// Specifies list of product ids to add.
	ProductsToAdd []string `json:"productsToAdd,omitempty"`
	// Specifies list of product ids to remove.
	ProductsToRemove []string `json:"productsToRemove,omitempty"`
	// Specifies list of product variant ids to add.
	ProductVariantsToAdd []string `json:"productVariantsToAdd,omitempty"`
	// Specifies list of product variant ids to remove.
	ProductVariantsToRemove []string `json:"productVariantsToRemove,omitempty"`
}

// The prerequisite purchase amount required for the discount to be applicable.
type DiscountPurchaseAmount struct {
	// Decimal money amount.
	Amount string `json:"amount"`
}

func (DiscountPurchaseAmount) IsDiscountCustomerBuysValue() {}

// The quantity of items in discount.
type DiscountQuantity struct {
	// The quantity of items.
	Quantity string `json:"quantity"`
}

func (DiscountQuantity) IsDiscountCustomerBuysValue() {}

// A redeem code for a code discount.
type DiscountRedeemCode struct {
	// The number of times the discount has been used. This value is updated asynchronously and can be different than the actual usage count.
	AsyncUsageCount int64 `json:"asyncUsageCount"`
	// The code of a discount.
	Code string `json:"code"`
	// The application that created the discount code.
	CreatedBy *App `json:"createdBy"`
	// Globally unique identifier of the discount redeem code.
	ID string `json:"id"`
}

type DiscountRedeemCodeConnection struct {
	// A list of edges.
	Edges []*DiscountRedeemCodeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DiscountRedeemCodeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DiscountRedeemCodeEdge.
	Node *DiscountRedeemCode `json:"node"`
}

// The shareable URL for the discount code.
type DiscountShareableURL struct {
	// The image URL of the item (product or collection) to which the discount applies.
	TargetItemImage *Image `json:"targetItemImage"`
	// The type of page that's associated with the URL.
	TargetType DiscountShareableURLTargetType `json:"targetType"`
	// The title of the page that's associated with the URL.
	Title string `json:"title"`
	// The URL for the discount code.
	URL string `json:"url"`
}

// Specifies the destinations where the free shipping discount will be applied.
type DiscountShippingDestinationSelectionInput struct {
	// Whether the discount code applies to all countries.
	All *bool `json:"all,omitempty"`
	// A list of countries where the discount code will apply.
	Countries *DiscountCountriesInput `json:"countries,omitempty"`
}

// An error that occurs during the execution of a discount mutation.
type DiscountUserError struct {
	// Error code to uniquely identify the error.
	Code *DiscountErrorCode `json:"code"`
	// Extra information about this error.
	ExtraInfo *string `json:"extraInfo"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (DiscountUserError) IsDisplayableError() {}

// A unique string that represents the address of a Shopify store on the Internet.
type Domain struct {
	// The host name of the domain (eg: `example.com`).
	Host string `json:"host"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The localization of the domain, if it does not redirect.
	Localization *DomainLocalization `json:"localization"`
	// Whether SSL is enabled or not.
	SslEnabled bool `json:"sslEnabled"`
	// The URL of the domain (eg: `https://example.com`).
	URL string `json:"url"`
}

func (Domain) IsNode() {}

// The country and language settings assigned to a domain.
type DomainLocalization struct {
	// The ISO codes for the domain’s alternate locales.
	AlternateLocales []string `json:"alternateLocales"`
	// The ISO code for the country assigned to the domain, or "*" for a domain set to "Rest of world".
	Country *string `json:"country"`
	// The ISO code for the domain’s default locale.
	DefaultLocale string `json:"defaultLocale"`
}

// Returns unfulfilled line items grouped by their fulfillment service. Each draft fulfillment contains additional information, such as whether the fulfillment requires shipping and whether a shipping label can be printed for it.
//
type DraftFulfillment struct {
	// Whether a label can be purchased.
	AllowLabelPurchase bool `json:"allowLabelPurchase"`
	// The line items (which might correspond to a variant) that are part of this draft fulfillment.
	LineItems []*LineItem `json:"lineItems"`
	// Whether a fulfillment requires shipping.
	RequiresShipping bool `json:"requiresShipping"`
	// The service responsible for fulfilling the fulfillment.
	Service *FulfillmentService `json:"service"`
}

// Represents a draft order. Merchants can use draft orders to create orders on behalf of their customers.
//
type DraftOrder struct {
	// Order-level discount applied to the draft order.
	AppliedDiscount *DraftOrderAppliedDiscount `json:"appliedDiscount"`
	// Billing address of the customer.
	//
	BillingAddress *MailingAddress `json:"billingAddress"`
	// Date and time when the draft order converted to a new order,
	// and the draft order's status changed to **Completed**.
	//
	CompletedAt *string `json:"completedAt"`
	// Date and time when the draft order was created in Shopify.
	CreatedAt string `json:"createdAt"`
	// Three letter code for the currency of the store at the time that the invoice is sent.
	//
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// Custom information added to the draft order on behalf of your customer.
	//
	CustomAttributes []*Attribute `json:"customAttributes"`
	// Customer who will be sent an invoice for the draft order, if there is one.
	Customer *Customer `json:"customer"`
	// Email address of the customer, which is used to send notifications to.
	Email *string `json:"email"`
	// List of events associated with the draft order.
	Events *EventConnection `json:"events"`
	// Whether the merchant has added timeline comments to the draft order.
	HasTimelineComment bool `json:"hasTimelineComment"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Date and time when the invoice was last emailed to the customer.
	InvoiceSentAt *string `json:"invoiceSentAt"`
	// Link to the checkout, which is sent to your customer in the invoice email.
	InvoiceURL *string `json:"invoiceUrl"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// List of the line items in the draft order.
	LineItems *DraftOrderLineItemConnection `json:"lineItems"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// Unique identifier for the draft order, which is unique within the store. For example, _#D1223_.
	//
	Name string `json:"name"`
	// Text from an optional note attached to the draft order.
	Note2 *string `json:"note2"`
	// Order that was created from this draft order.
	Order *Order `json:"order"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// Whether or not the Draft Order is ready and can be completed. Draft Orders
	//         may have asynchronous operations that can take time to finish.
	Ready bool `json:"ready"`
	// Shipping mailing address of the customer.
	ShippingAddress *MailingAddress `json:"shippingAddress"`
	// Line item that contains the shipping costs.
	ShippingLine *ShippingLine `json:"shippingLine"`
	// Status of the draft order.
	Status DraftOrderStatus `json:"status"`
	// Subtotal of the line items and their discounts (does not contain shipping charges or shipping discounts, or taxes).
	//
	SubtotalPrice string `json:"subtotalPrice"`
	// A comma separated list of tags that have been added to the draft order.
	Tags []string `json:"tags"`
	// Whether the draft order is tax exempt.
	TaxExempt bool `json:"taxExempt"`
	// Total amount of taxes charged for each line item and shipping line.
	TaxLines []*TaxLine `json:"taxLines"`
	// Whether the line item prices include taxes.
	TaxesIncluded bool `json:"taxesIncluded"`
	// Total amount of the draft order (includes taxes, shipping charges, and discounts).
	TotalPrice string `json:"totalPrice"`
	// Total shipping charge for the draft order.
	TotalShippingPrice string `json:"totalShippingPrice"`
	// Total amount of taxes for the draft order.
	TotalTax string `json:"totalTax"`
	// Total weight (grams) of the draft order.
	TotalWeight string `json:"totalWeight"`
	// Date and time when the draft order was last changed.
	// The format is YYYY-MM-DD HH:mm:ss (for example, 2016-02-05 17:04:01).
	//
	UpdatedAt string `json:"updatedAt"`
}

func (DraftOrder) IsCommentEventEmbed()      {}
func (DraftOrder) IsNode()                   {}
func (DraftOrder) IsHasMetafields()          {}
func (DraftOrder) IsCommentEventSubject()    {}
func (DraftOrder) IsLegacyInteroperability() {}
func (DraftOrder) IsHasEvents()              {}

// The order-level discount applied to a draft order.
type DraftOrderAppliedDiscount struct {
	// Amount of the order-level discount that is applied to the draft order.
	Amount string `json:"amount"`
	// Amount of money discounted.
	AmountV2 *MoneyV2 `json:"amountV2"`
	// Description of the order-level discount.
	Description string `json:"description"`
	// Name of the order-level discount.
	Title *string `json:"title"`
	// Amount of the order level discount (when value_type is percentage,
	// the value in this field is the percentage discount).
	//
	Value float64 `json:"value"`
	// Type of the order-level discount.
	ValueType DraftOrderAppliedDiscountType `json:"valueType"`
}

// The input fields for applying an order-level discount to a draft order.
type DraftOrderAppliedDiscountInput struct {
	// The applied amount of the discount.
	//
	Amount *string `json:"amount,omitempty"`
	// Reason for the discount.
	//
	Description *string `json:"description,omitempty"`
	// Title of the discount.
	//
	Title *string `json:"title,omitempty"`
	// The value of the discount.
	// If the type of the discount is fixed amount, then this is a fixed dollar amount.
	// If the type is percentage, then this is the percentage.
	//
	Value float64 `json:"value,omitempty"`
	// The type of discount.
	//
	ValueType DraftOrderAppliedDiscountType `json:"valueType,omitempty"`
}

// Return type for `draftOrderCalculate` mutation.
type DraftOrderCalculatePayload struct {
	// The calculated properties for a draft order.
	CalculatedDraftOrder *CalculatedDraftOrder `json:"calculatedDraftOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `draftOrderComplete` mutation.
type DraftOrderCompletePayload struct {
	// The completed draft order.
	DraftOrder *DraftOrder `json:"draftOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type DraftOrderConnection struct {
	// A list of edges.
	Edges []*DraftOrderEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `draftOrderCreate` mutation.
type DraftOrderCreatePayload struct {
	// The created draft order.
	//
	DraftOrder *DraftOrder `json:"draftOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the draft order to delete by its ID.
type DraftOrderDeleteInput struct {
	// The ID of the draft order to delete.
	//
	ID string `json:"id,omitempty"`
}

// Return type for `draftOrderDelete` mutation.
type DraftOrderDeletePayload struct {
	// The ID of the deleted draft order.
	//
	DeletedID *string `json:"deletedId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type DraftOrderEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DraftOrderEdge.
	Node *DraftOrder `json:"node"`
}

// The input fields used to create or update a draft order.
type DraftOrderInput struct {
	// The discount that will be applied to the draft order.
	// A draft order line item can have one discount. A draft order can also have one order-level discount.
	//
	AppliedDiscount *DraftOrderAppliedDiscountInput `json:"appliedDiscount,omitempty"`
	// The mailing address associated with the payment method.
	//
	BillingAddress *MailingAddressInput `json:"billingAddress,omitempty"`
	// Customer associated with the draft order.
	//
	CustomerID *string `json:"customerId,omitempty"`
	// Extra information added to the customer.
	//
	CustomAttributes []*AttributeInput `json:"customAttributes,omitempty"`
	// The customer's email address.
	//
	Email *string `json:"email,omitempty"`
	// Product variant line item or custom line item associated to the draft order.
	// Each draft order must include at least one line item.
	//
	LineItems []*DraftOrderLineItemInput `json:"lineItems,omitempty"`
	// Metafields attached to the draft order.
	//
	Metafields []*MetafieldInput `json:"metafields,omitempty"`
	// The private metafields attached to the draft order.
	PrivateMetafields []*PrivateMetafieldInput `json:"privateMetafields,omitempty"`
	// The text of an optional note that a shop owner can attach to the draft order.
	//
	Note *string `json:"note,omitempty"`
	// The mailing address to where the order will be shipped.
	//
	ShippingAddress *MailingAddressInput `json:"shippingAddress,omitempty"`
	// A shipping line object, which details the shipping method used.
	//
	ShippingLine *ShippingLineInput `json:"shippingLine,omitempty"`
	// A comma separated list of tags that have been added to the draft order.
	//
	Tags []string `json:"tags,omitempty"`
	// Whether or not taxes are exempt for the draft order.
	// If false, then Shopify will refer to the taxable field for each line item.
	// If a customer is applied to the draft order, then Shopify will use the customer's tax exempt field instead.
	//
	TaxExempt *bool `json:"taxExempt,omitempty"`
	// Sent as part of a draft order object to load customer shipping information.
	//
	UseCustomerDefaultAddress *bool `json:"useCustomerDefaultAddress,omitempty"`
}

// Return type for `draftOrderInvoicePreview` mutation.
type DraftOrderInvoicePreviewPayload struct {
	// HTML to preview the draft order invoice email.
	PreviewHTML *string `json:"previewHtml"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `draftOrderInvoiceSend` mutation.
type DraftOrderInvoiceSendPayload struct {
	// The draft order an invoice email is sent for.
	DraftOrder *DraftOrder `json:"draftOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents a line item included in a draft order.
type DraftOrderLineItem struct {
	// Discount which will be applied to the line item or the overall order.
	//
	AppliedDiscount *DraftOrderAppliedDiscount `json:"appliedDiscount"`
	// Whether this is a product variant line item, or a custom line item.
	// If set to true indicates a custom line item. If set to false indicates a product variant line item.
	//
	Custom bool `json:"custom"`
	// List of additional information (metafields) about the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// Line item price after discounts are applied.
	//
	DiscountedTotal string `json:"discountedTotal"`
	// The `discountedTotal` divided by `quantity`, resulting in the value of the discount per unit.
	//
	DiscountedUnitPrice string `json:"discountedUnitPrice"`
	// Name of the service provider who fulfilled the order.
	//
	// Valid values are either **manual** or the name of the provider.
	// For example, **amazon**, **shipwire**.
	//
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// Weight in grams. Can only be specified if this is a custom line item.
	//
	Grams *int64 `json:"grams"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Image associated with the draft order line item.
	Image *Image `json:"image"`
	// Whether the line item represents the puchase of a gift card.
	IsGiftCard bool `json:"isGiftCard"`
	// Name of the product.
	Name string `json:"name"`
	// Total price (without discounts) of the line item, based on the original unit price of the variant x quantity.
	//
	OriginalTotal string `json:"originalTotal"`
	// Variant price without any discounts applied.
	OriginalUnitPrice string `json:"originalUnitPrice"`
	// The product corresponding to the line item’s product variant.
	//
	Product *Product `json:"product"`
	// Number of variant items requested in the draft order.
	Quantity int64 `json:"quantity"`
	// Whether physical shipping is required for the variant.
	RequiresShipping bool `json:"requiresShipping"`
	// Variant SKU number.
	Sku *string `json:"sku"`
	// A list of tax line objects, each of which details the total taxes applicable to the order.
	//
	TaxLines []*TaxLine `json:"taxLines"`
	// Whether the variant is taxable.
	Taxable bool `json:"taxable"`
	// Title of the product or variant (this field only applies to custom line items).
	Title string `json:"title"`
	// Total value of the discount applied to the line item.
	//
	TotalDiscount string `json:"totalDiscount"`
	// Associated variant for the line item.
	//
	Variant *ProductVariant `json:"variant"`
	// Name of the variant.
	VariantTitle *string `json:"variantTitle"`
	// Name of the vendor who made the variant.
	Vendor *string `json:"vendor"`
	// Weight unit and value for a draft order line item.
	Weight *Weight `json:"weight"`
}

func (DraftOrderLineItem) IsNode() {}

type DraftOrderLineItemConnection struct {
	// A list of edges.
	Edges []*DraftOrderLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type DraftOrderLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of DraftOrderLineItemEdge.
	Node *DraftOrderLineItem `json:"node"`
}

// The input fields used to create a line item for a draft order.
type DraftOrderLineItemInput struct {
	// Discount which will be applied to the line item.
	//
	AppliedDiscount *DraftOrderAppliedDiscountInput `json:"appliedDiscount,omitempty"`
	// Represents a generic custom attribute using a key value pair.
	//
	CustomAttributes []*AttributeInput `json:"customAttributes,omitempty"`
	// Ignored when variant ID is provided. This argument is deprecated: Use `weight` instead.
	Grams *int64 `json:"grams,omitempty"`
	// Ignored when variant ID is provided.
	OriginalUnitPrice *string `json:"originalUnitPrice,omitempty"`
	// The number of products that were purchased.
	//
	Quantity int64 `json:"quantity,omitempty"`
	// Ignored when variant ID is provided.
	RequiresShipping *bool `json:"requiresShipping,omitempty"`
	// Ignored when variant ID is provided.
	Sku *string `json:"sku,omitempty"`
	// Ignored when variant ID is provided.
	Taxable *bool `json:"taxable,omitempty"`
	// Ignored when variant ID is provided.
	Title *string `json:"title,omitempty"`
	// The ID of the product variant corresponding to the line item.
	// Null if custom line item. Required if product variant line item.
	//
	VariantID *string `json:"variantId,omitempty"`
	// Specifies the weight unit and value inputs.
	// Ignored when variant ID is provided.
	//
	Weight *WeightInput `json:"weight,omitempty"`
}

// Return type for `draftOrderUpdate` mutation.
type DraftOrderUpdatePayload struct {
	// The updated draft order.
	DraftOrder *DraftOrder `json:"draftOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents a single duty for a line item.
type Duty struct {
	// The ISO code of the country of origin of the line item.
	CountryCodeOfOrigin *CountryCode `json:"countryCodeOfOrigin"`
	// The harmonized system code of the line item.
	HarmonizedSystemCode *string `json:"harmonizedSystemCode"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The price of the duty for the line item.
	Price *MoneyBag `json:"price"`
	// The TaxLine objects connected to the duty for the line item.
	TaxLines []*TaxLine `json:"taxLines"`
}

func (Duty) IsNode() {}

// The attribute editable information.
type EditableProperty struct {
	// Whether the attribute is locked for editing.
	Locked bool `json:"locked"`
	// The reason the attribute is locked for editing.
	Reason *string `json:"reason"`
}

// Specifies the fields for an email.
type EmailInput struct {
	// Specifies the email subject.
	Subject *string `json:"subject,omitempty"`
	// Specifies the email recipient.
	To *string `json:"to,omitempty"`
	// Specifies the email sender.
	From *string `json:"from,omitempty"`
	// Specifies the email body.
	Body *string `json:"body,omitempty"`
	// Specifies any bcc recipients for the email.
	Bcc []string `json:"bcc,omitempty"`
	// Specifies a custom message to include in the email.
	CustomMessage *string `json:"customMessage,omitempty"`
}

// Return type for `eventBridgeWebhookSubscriptionCreate` mutation.
type EventBridgeWebhookSubscriptionCreatePayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
	// The webhook subscription that was created.
	WebhookSubscription *WebhookSubscription `json:"webhookSubscription"`
}

// Specifies the input fields for an EventBridge webhook subscription.
//
type EventBridgeWebhookSubscriptionInput struct {
	// ARN of the EventBridge event source.
	Arn *string `json:"arn,omitempty"`
	// The format in which the webhook subscription should send the data.
	Format *WebhookSubscriptionFormat `json:"format,omitempty"`
	// The list of fields to be included in the webhook subscription.
	IncludeFields []string `json:"includeFields,omitempty"`
	// The list of namespaces for any metafields that should be included in the webhook subscription.
	MetafieldNamespaces []string `json:"metafieldNamespaces,omitempty"`
}

// Return type for `eventBridgeWebhookSubscriptionUpdate` mutation.
type EventBridgeWebhookSubscriptionUpdatePayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
	// The webhook subscription that was updated.
	WebhookSubscription *WebhookSubscription `json:"webhookSubscription"`
}

type EventConnection struct {
	// A list of edges.
	Edges []*EventEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type EventEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of EventEdge.
	Node Event `json:"node"`
}

// Represents a video hosted outside of Shopify.
//
type ExternalVideo struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt"`
	// The URL.
	EmbeddedURL string `json:"embeddedUrl"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// Any errors which have occurred on the media.
	MediaErrors []*MediaError `json:"mediaErrors"`
	// The preview image for the media.
	Preview *MediaPreviewImage `json:"preview"`
	// Current status of the media.
	Status MediaStatus `json:"status"`
}

func (ExternalVideo) IsNode()  {}
func (ExternalVideo) IsMedia() {}

// Requirements that must be met before an app can be installed.
type FailedRequirement struct {
	// Action to be taken to resolve a failed requirement, including URL link.
	Action *NavigationItem `json:"action"`
	// A concise set of copy strings to be displayed to merchants, to guide them in resolving problems your app
	// encounters when trying to make use of their Shop and its resources.
	//
	Message string `json:"message"`
}

// A filter option is one possible value in a search filter.
type FilterOption struct {
	// The filter option's label for display purposes.
	Label string `json:"label"`
	// The filter option's value.
	Value string `json:"value"`
}

// Return type for `flowTriggerReceive` mutation.
type FlowTriggerReceivePayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents a fulfillment. In Shopify, a fulfillment represents a shipment of one or more items in an order. When an order has been completely fulfilled, it means that all the items that are included in the order have been sent to the customer. There can be more than one fulfillment for an order.
//
type Fulfillment struct {
	// The date and time when the fulfillment was created.
	CreatedAt string `json:"createdAt"`
	// The date that this fulfillment was delivered.
	DeliveredAt *string `json:"deliveredAt"`
	// Human readable display status for this fulfillment.
	DisplayStatus *FulfillmentDisplayStatus `json:"displayStatus"`
	// The estimated date that this fulfillment will arrive.
	EstimatedDeliveryAt *string `json:"estimatedDeliveryAt"`
	// The history of events associated with this fulfillment.
	Events *FulfillmentEventConnection `json:"events"`
	// List of the fulfillment's line items.
	FulfillmentLineItems *FulfillmentLineItemConnection `json:"fulfillmentLineItems"`
	// A list of fulfillment orders for the fulfillment.
	FulfillmentOrders *FulfillmentOrderConnection `json:"fulfillmentOrders"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The date and time when the fulfillment went into transit.
	InTransitAt *string `json:"inTransitAt"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The location that the fulfillment was processed at.
	Location *Location `json:"location"`
	// Human readable reference identifier for this fulfillment.
	Name string `json:"name"`
	// The order for which the fulfillment was created.
	Order *Order `json:"order"`
	// Whether any of the line items in the fulfillment require shipping.
	RequiresShipping bool `json:"requiresShipping"`
	// Fulfillment service associated with the fulfillment.
	Service *FulfillmentService `json:"service"`
	// The status of the fulfillment.
	Status FulfillmentStatus `json:"status"`
	// Sum of all line item quantities for the fulfillment.
	TotalQuantity int64 `json:"totalQuantity"`
	// Tracking information associated with the fulfillment,
	// such as the tracking company, tracking number, and tracking URL.
	//
	TrackingInfo []*FulfillmentTrackingInfo `json:"trackingInfo"`
	// The date and time when the fulfillment was last modified.
	//
	UpdatedAt string `json:"updatedAt"`
}

func (Fulfillment) IsLegacyInteroperability() {}
func (Fulfillment) IsNode()                   {}

// Return type for `fulfillmentCancel` mutation.
type FulfillmentCancelPayload struct {
	// The canceled fulfillment.
	Fulfillment *Fulfillment `json:"fulfillment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type FulfillmentConnection struct {
	// A list of edges.
	Edges []*FulfillmentEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `fulfillmentCreate` mutation.
type FulfillmentCreatePayload struct {
	// The created fulfillment.
	Fulfillment *Fulfillment `json:"fulfillment"`
	// The order for which the fulfillment is created.
	Order *Order `json:"order"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentCreateV2` mutation.
type FulfillmentCreateV2Payload struct {
	// The created fulfillment.
	Fulfillment *Fulfillment `json:"fulfillment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type FulfillmentEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentEdge.
	Node *Fulfillment `json:"node"`
}

// An event that describes a fulfillment at a time.
type FulfillmentEvent struct {
	// The time at which this fulfillment event happened.
	HappenedAt string `json:"happenedAt"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The status of this fulfillment event.
	Status FulfillmentEventStatus `json:"status"`
}

func (FulfillmentEvent) IsNode() {}

type FulfillmentEventConnection struct {
	// A list of edges.
	Edges []*FulfillmentEventEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type FulfillmentEventEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentEventEdge.
	Node *FulfillmentEvent `json:"node"`
}

// The input fields used to create a fulfillment.
type FulfillmentInput struct {
	// The ID of the order to be fulfilled.
	OrderID string `json:"orderId,omitempty"`
	// The line items to be fulfilled.
	LineItems []*FulfillmentLineItemInput `json:"lineItems,omitempty"`
	// Tracking numbers associated with the fulfillment.
	TrackingNumbers []string `json:"trackingNumbers,omitempty"`
	// The URLs to track the fulfillment.
	TrackingUrls []string `json:"trackingUrls,omitempty"`
	// The name of the tracking company.
	TrackingCompany *string `json:"trackingCompany,omitempty"`
	// Whether the customer is notified.
	// If set to true, a notification is sent when the fulfillment is created.
	//
	NotifyCustomer *bool `json:"notifyCustomer,omitempty"`
	// A reference to the shipping method, such as `Free Shipping`.
	ShippingMethod *string `json:"shippingMethod,omitempty"`
	// The ID of the location from which the items will be fulfilled.
	LocationID string `json:"locationId,omitempty"`
}

// Represents a line item from an order that's included in a fulfillment.
type FulfillmentLineItem struct {
	// The total price after discounts are applied.
	DiscountedTotal string `json:"discountedTotal"`
	// The total price after discounts are applied in shop and presentment currencies.
	DiscountedTotalSet *MoneyBag `json:"discountedTotalSet"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The associated order's line item.
	LineItem *LineItem `json:"lineItem"`
	// The total price before discounts are applied.
	OriginalTotal string `json:"originalTotal"`
	// The total price before discounts are applied in shop and presentment currencies.
	OriginalTotalSet *MoneyBag `json:"originalTotalSet"`
	// Number of line items in the fulfillment.
	Quantity *int64 `json:"quantity"`
}

func (FulfillmentLineItem) IsNode() {}

type FulfillmentLineItemConnection struct {
	// A list of edges.
	Edges []*FulfillmentLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type FulfillmentLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentLineItemEdge.
	Node *FulfillmentLineItem `json:"node"`
}

// The input fields used to include a line item from an order in a fulfillment.
type FulfillmentLineItemInput struct {
	// The ID of the line item.
	ID string `json:"id,omitempty"`
	// The quantity of the line item to be fulfilled.
	Quantity *int64 `json:"quantity,omitempty"`
}

// Represents a fulfillment order. In Shopify, a fulfillment order represents a group of one or more items
// in an order that are to be fulfilled from the same location. There can be more than one fulfillment order
// for an order at a given location.
//
type FulfillmentOrder struct {
	// The fulfillment order's assigned location. This is the location expected to perform fulfillment.
	AssignedLocation *FulfillmentOrderAssignedLocation `json:"assignedLocation"`
	// Delivery method of this fulfillment order.
	DeliveryMethod *DeliveryMethod `json:"deliveryMethod"`
	// The destination where the items should be sent.
	Destination *FulfillmentOrderDestination `json:"destination"`
	// A list of fulfillments for the fulfillment order.
	Fulfillments *FulfillmentConnection `json:"fulfillments"`
	// Globally unique identifier.
	ID string `json:"id"`
	// A list of the fulfillment order's line items.
	LineItems *FulfillmentOrderLineItemConnection `json:"lineItems"`
	// A list of locations that the fulfillment order can potentially move to.
	LocationsForMove *FulfillmentOrderLocationForMoveConnection `json:"locationsForMove"`
	// A list of requests sent by the merchant to the fulfillment service for this fulfillment order.
	MerchantRequests *FulfillmentOrderMerchantRequestConnection `json:"merchantRequests"`
	// The order that's associated with the fulfillment order.
	Order *Order `json:"order"`
	// The request status of the fulfillment order.
	RequestStatus FulfillmentOrderRequestStatus `json:"requestStatus"`
	// The status of the fulfillment order.
	Status FulfillmentOrderStatus `json:"status"`
	// The actions that can be performed on this fulfillment order.
	SupportedActions []*FulfillmentOrderSupportedAction `json:"supportedActions"`
}

func (FulfillmentOrder) IsNode() {}

// Return type for `fulfillmentOrderAcceptCancellationRequest` mutation.
type FulfillmentOrderAcceptCancellationRequestPayload struct {
	// The fulfillment order whose cancellation request was accepted.
	FulfillmentOrder *FulfillmentOrder `json:"fulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentOrderAcceptFulfillmentRequest` mutation.
type FulfillmentOrderAcceptFulfillmentRequestPayload struct {
	// The fulfillment order whose fulfillment request was accepted.
	FulfillmentOrder *FulfillmentOrder `json:"fulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents the assigned location of a fulfillment order, which is a snapshot of the location
// at which the fulfillment order was created. The assigned location is expected to perform fulfillment.
//
type FulfillmentOrderAssignedLocation struct {
	// The first line of the address for the location.
	Address1 *string `json:"address1"`
	// The second line of the address for the location.
	Address2 *string `json:"address2"`
	// The city of the location.
	City *string `json:"city"`
	// The two-letter country code of the location.
	CountryCode CountryCode `json:"countryCode"`
	// The location where the fulfillment order was created. This can differ from the
	// `FulfillmentOrderAssignedLocation` if the location was updated since the fulfillment order
	// was closed.
	//
	Location *Location `json:"location"`
	// The name of the location.
	Name string `json:"name"`
	// The phone number of the location.
	Phone *string `json:"phone"`
	// The province of the location.
	Province *string `json:"province"`
	// The ZIP code of the location.
	Zip *string `json:"zip"`
}

// Return type for `fulfillmentOrderCancel` mutation.
type FulfillmentOrderCancelPayload struct {
	// The fulfillment order that was marked as canceled.
	FulfillmentOrder *FulfillmentOrder `json:"fulfillmentOrder"`
	// The fulfillment order that was created to replace the canceled fulfillment order.
	ReplacementFulfillmentOrder *FulfillmentOrder `json:"replacementFulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentOrderClose` mutation.
type FulfillmentOrderClosePayload struct {
	// The fulfillment order that was marked as incomplete.
	FulfillmentOrder *FulfillmentOrder `json:"fulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type FulfillmentOrderConnection struct {
	// A list of edges.
	Edges []*FulfillmentOrderEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Represents the destination where the items should be sent upon fulfillment.
//
type FulfillmentOrderDestination struct {
	// The first line of the address of the destination.
	Address1 *string `json:"address1"`
	// The second line of the address of the destination.
	Address2 *string `json:"address2"`
	// The city of the destination.
	City *string `json:"city"`
	// The company of the destination.
	Company *string `json:"company"`
	// The two-letter country code of the destination.
	CountryCode *CountryCode `json:"countryCode"`
	// The email of the customer at the destination.
	Email *string `json:"email"`
	// The first name of the customer at the destination.
	FirstName *string `json:"firstName"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The last name of the customer at the destination.
	LastName *string `json:"lastName"`
	// The phone number of the customer at the destination.
	Phone *string `json:"phone"`
	// The province of the destination.
	Province *string `json:"province"`
	// The ZIP code of the destination.
	Zip *string `json:"zip"`
}

func (FulfillmentOrderDestination) IsNode() {}

type FulfillmentOrderEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentOrderEdge.
	Node *FulfillmentOrder `json:"node"`
}

// Represents a line item belonging to a fulfillment order.
//
type FulfillmentOrderLineItem struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The associated order line item.
	LineItem *LineItem `json:"lineItem"`
	// The number of units remaining to be fulfilled.
	RemainingQuantity int64 `json:"remainingQuantity"`
	// The total number of units to be fulfilled.
	TotalQuantity int64 `json:"totalQuantity"`
}

func (FulfillmentOrderLineItem) IsNode() {}

type FulfillmentOrderLineItemConnection struct {
	// A list of edges.
	Edges []*FulfillmentOrderLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type FulfillmentOrderLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentOrderLineItemEdge.
	Node *FulfillmentOrderLineItem `json:"node"`
}

// The input fields used to include a line item from a fulfillment order.
type FulfillmentOrderLineItemInput struct {
	// The ID of the fulfillment order line item.
	ID string `json:"id,omitempty"`
	// The quantity of the fulfillment order line item.
	Quantity int64 `json:"quantity,omitempty"`
}

// The input fields used to include the line items of a specified fulfillment order that should be fulfilled.
//
type FulfillmentOrderLineItemsInput struct {
	// The ID of the fulfillment order.
	FulfillmentOrderID string `json:"fulfillmentOrderId,omitempty"`
	// The fulfillment order line items to be fulfilled.
	// If left blank, all line items of the fulfillment order will be fulfilled.
	//
	FulfillmentOrderLineItems []*FulfillmentOrderLineItemInput `json:"fulfillmentOrderLineItems,omitempty"`
}

// A location that a fulfillment order can potentially move to.
//
type FulfillmentOrderLocationForMove struct {
	// The location being considered as the fulfillment order's new assigned location.
	Location *Location `json:"location"`
	// A human-readable string with the reason why the fulfillment order, or some of its line items, can't be
	// moved to the location.
	//
	Message *string `json:"message"`
	// Whether the fulfillment order can be moved to the location.
	Movable bool `json:"movable"`
}

type FulfillmentOrderLocationForMoveConnection struct {
	// A list of edges.
	Edges []*FulfillmentOrderLocationForMoveEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type FulfillmentOrderLocationForMoveEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentOrderLocationForMoveEdge.
	Node *FulfillmentOrderLocationForMove `json:"node"`
}

// Represents a request made by the merchant to a fulfillment service for a fulfillment order.
//
type FulfillmentOrderMerchantRequest struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The kind of request made.
	Kind FulfillmentOrderMerchantRequestKind `json:"kind"`
	// The optional message that the merchant included in the request.
	Message *string `json:"message"`
	// Additional options requested by the merchant. These depend on the `kind` of the request.
	// For example, for a `FULFILLMENT_REQUEST`, one option is `notify_customer`, which indicates whether the
	// merchant intends to notify the customer upon fulfillment. The fulfillment service can then set
	// `notifyCustomer` when making calls to `FulfillmentCreateV2`.
	//
	RequestOptions *string `json:"requestOptions"`
	// The response from the fulfillment service.
	ResponseData *string `json:"responseData"`
	// The timestamp when the request was made.
	SentAt string `json:"sentAt"`
}

func (FulfillmentOrderMerchantRequest) IsNode() {}

type FulfillmentOrderMerchantRequestConnection struct {
	// A list of edges.
	Edges []*FulfillmentOrderMerchantRequestEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type FulfillmentOrderMerchantRequestEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of FulfillmentOrderMerchantRequestEdge.
	Node *FulfillmentOrderMerchantRequest `json:"node"`
}

// Return type for `fulfillmentOrderMove` mutation.
type FulfillmentOrderMovePayload struct {
	// A new fulfillment order representing all items that were able to be moved to the new location.
	MovedFulfillmentOrder *FulfillmentOrder `json:"movedFulfillmentOrder"`
	// The fulfillment order that was moved. On success, this fulfillment order will be closed.
	OriginalFulfillmentOrder *FulfillmentOrder `json:"originalFulfillmentOrder"`
	// A new fulfillment order representing any items still assigned to the original location.
	// This is created if all line items on the original fulfillment order could not be moved to the new location
	// due to not being stocked there.
	//
	RemainingFulfillmentOrder *FulfillmentOrder `json:"remainingFulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentOrderRejectCancellationRequest` mutation.
type FulfillmentOrderRejectCancellationRequestPayload struct {
	// The fulfillment order whose cancellation request was rejected.
	FulfillmentOrder *FulfillmentOrder `json:"fulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentOrderRejectFulfillmentRequest` mutation.
type FulfillmentOrderRejectFulfillmentRequestPayload struct {
	// The fulfillment order whose fulfillment request was rejected.
	FulfillmentOrder *FulfillmentOrder `json:"fulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentOrderSubmitCancellationRequest` mutation.
type FulfillmentOrderSubmitCancellationRequestPayload struct {
	// The fulfillment order whose cancellation was requested.
	FulfillmentOrder *FulfillmentOrder `json:"fulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentOrderSubmitFulfillmentRequest` mutation.
type FulfillmentOrderSubmitFulfillmentRequestPayload struct {
	// The original fulfillment order intended to request fulfillment for.
	//
	OriginalFulfillmentOrder *FulfillmentOrder `json:"originalFulfillmentOrder"`
	// The fulfillment order that was submitted to the fulfillment service. This will be the same as
	// the original fulfillment order field. The exception to this is partial fulfillment requests or
	// fulfillment request for cancelled or incomplete fulfillment orders.
	//
	SubmittedFulfillmentOrder *FulfillmentOrder `json:"submittedFulfillmentOrder"`
	// This field will only be present for partial fulfillment requests. This will represent the new
	// fulfillment order with the remaining line items not submitted to the fulfillment service.
	//
	UnsubmittedFulfillmentOrder *FulfillmentOrder `json:"unsubmittedFulfillmentOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents one of the methods that the fulfillment order supports.
//
type FulfillmentOrderSupportedAction struct {
	// The action value.
	Action FulfillmentOrderAction `json:"action"`
	// The external URL to be used to initiate the fulfillment process outside Shopify.
	ExternalURL *string `json:"externalUrl"`
}

// Represents a fulfillment service. A fulfillment service is a third-party service that prepares and ships orders on behalf of the store owner.
//
type FulfillmentService struct {
	// The callback URL the fulfillment service has registered for requests.
	CallbackURL *string `json:"callbackUrl"`
	// Whether the fulfillment service has opted into fulfillment order based requests.
	FulfillmentOrdersOptIn bool `json:"fulfillmentOrdersOptIn"`
	// Human-readable unique identifier for this fulfillment service.
	Handle string `json:"handle"`
	// The ID of the fulfillment service.
	ID string `json:"id"`
	// Whether the fulfillment service tracks product inventory and provides updates to Shopify.
	InventoryManagement bool `json:"inventoryManagement"`
	// Location associated with the fulfillment service.
	Location *Location `json:"location"`
	// Whether the fulfillment service supports local deliveries.
	ProductBased bool `json:"productBased"`
	// The name of the fulfillment service as seen by merchants.
	ServiceName string `json:"serviceName"`
	// Shipping methods associated with the fulfillment service provider.
	ShippingMethods []*ShippingMethod `json:"shippingMethods"`
	// Type associated with the fulfillment service.
	Type FulfillmentServiceType `json:"type"`
}

// Return type for `fulfillmentServiceCreate` mutation.
type FulfillmentServiceCreatePayload struct {
	// The created fulfillment service.
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentServiceDelete` mutation.
type FulfillmentServiceDeletePayload struct {
	// The ID of the deleted fulfillment service.
	DeletedID *string `json:"deletedId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentServiceUpdate` mutation.
type FulfillmentServiceUpdatePayload struct {
	// The updated fulfillment service.
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents the tracking information for a fulfillment.
type FulfillmentTrackingInfo struct {
	// The name of the tracking company.
	Company *string `json:"company"`
	// The tracking number of the fulfillment.
	Number *string `json:"number"`
	// The URLs to track the fulfillment.
	URL *string `json:"url"`
}

// Return type for `fulfillmentTrackingInfoUpdate` mutation.
type FulfillmentTrackingInfoUpdatePayload struct {
	// The updated fulfillment with tracking information.
	Fulfillment *Fulfillment `json:"fulfillment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `fulfillmentTrackingInfoUpdateV2` mutation.
type FulfillmentTrackingInfoUpdateV2Payload struct {
	// The updated fulfillment with tracking information.
	Fulfillment *Fulfillment `json:"fulfillment"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The input fields used to specify all possible fields for tracking information.
type FulfillmentTrackingInput struct {
	// The tracking number of the fulfillment.
	Number *string `json:"number,omitempty"`
	// The URL to track the fulfillment.
	URL *string `json:"url,omitempty"`
	// The name of the tracking company.
	Company *string `json:"company,omitempty"`
}

// The input fields used to create a fulfillment from fulfillment orders.
type FulfillmentV2Input struct {
	// The fulfillment's tracking information, including a tracking URL, a tracking number,
	// and the company associated with the fulfillment.
	//
	TrackingInfo *FulfillmentTrackingInput `json:"trackingInfo,omitempty"`
	// Whether the customer is notified.
	// If set to true, a notification is sent when the fulfillment is created.
	//
	NotifyCustomer *bool `json:"notifyCustomer,omitempty"`
	// Pairs of `fulfillment_order_id` and `fulfillment_order_line_items` that represent the fulfillment
	// order line items that have to be fulfilled for each fulfillment order.  For any given pair, if the
	// fulfillment order line items are left blank then all the fulfillment order line items of the
	// associated fulfillment order ID will be fulfilled.
	//
	LineItemsByFulfillmentOrder []*FulfillmentOrderLineItemsInput `json:"lineItemsByFulfillmentOrder,omitempty"`
}

// Represents an image resource.
type Image struct {
	// A word or phrase to share the nature or contents of an image.
	AltText *string `json:"altText"`
	// A unique identifier for the image.
	ID *string `json:"id"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// The location of the original image as a URL.
	//
	// If there are any existing transformations in the original source URL, they will remain and not be stripped.
	//
	OriginalSrc string `json:"originalSrc"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// The location of the image as a URL.
	Src string `json:"src"`
	// The location of the transformed image as a URL.
	//
	// All transformation arguments are considered "best-effort". If they can be applied to an image, they will be.
	// Otherwise any transformations which an image type does not support will be ignored.
	//
	TransformedSrc string `json:"transformedSrc"`
}

func (Image) IsHasMetafields() {}

type ImageConnection struct {
	// A list of edges.
	Edges []*ImageEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ImageEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ImageEdge.
	Node *Image `json:"node"`
}

// Specifies the input fields for an image.
type ImageInput struct {
	// Globally unique identifier.
	ID *string `json:"id,omitempty"`
	// A word or phrase to share the nature or contents of an image.
	AltText *string `json:"altText,omitempty"`
	// The URL of the image. May be a signed upload URL.
	Src *string `json:"src,omitempty"`
}

// Upload parameter of an image.
type ImageUploadParameter struct {
	// Parameter name.
	Name string `json:"name"`
	// Parameter value.
	Value string `json:"value"`
}

// Return type for `inventoryActivate` mutation.
type InventoryActivatePayload struct {
	// The newly activated inventory level.
	InventoryLevel *InventoryLevel `json:"inventoryLevel"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the items and their adjustments.
type InventoryAdjustItemInput struct {
	// ID of the inventory item to adjust.
	InventoryItemID string `json:"inventoryItemId,omitempty"`
	// Count by which to adjust the available quantity.
	AvailableDelta int64 `json:"availableDelta,omitempty"`
}

// Specifies the fields required to adjust the inventory quantity.
type InventoryAdjustQuantityInput struct {
	// ID of the inventory level to adjust.
	InventoryLevelID string `json:"inventoryLevelId,omitempty"`
	// Count by which to adjust the available quantity.
	AvailableDelta int64 `json:"availableDelta,omitempty"`
}

// Return type for `inventoryAdjustQuantity` mutation.
type InventoryAdjustQuantityPayload struct {
	// Represents the updated inventory quantity of an inventory item at a specific location.
	InventoryLevel *InventoryLevel `json:"inventoryLevel"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `inventoryBulkAdjustQuantityAtLocation` mutation.
type InventoryBulkAdjustQuantityAtLocationPayload struct {
	// The updated inventory quantities.
	InventoryLevels []*InventoryLevel `json:"inventoryLevels"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `inventoryDeactivate` mutation.
type InventoryDeactivatePayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents the goods available to be shipped to a customer.
// It holds essential information about the goods, including SKU and whether it is tracked.
//
type InventoryItem struct {
	// The ISO code of the country of origin.
	CountryCodeOfOrigin *CountryCode `json:"countryCodeOfOrigin"`
	// List of country specific harmonized system codes.
	CountryHarmonizedSystemCodes *CountryHarmonizedSystemCodeConnection `json:"countryHarmonizedSystemCodes"`
	// The date and time when the inventory item was created.
	CreatedAt string `json:"createdAt"`
	// The number of inventory items that share the same SKU with this item.
	DuplicateSkuCount int64 `json:"duplicateSkuCount"`
	// The harmonized system code of the item.
	HarmonizedSystemCode *string `json:"harmonizedSystemCode"`
	// Globally unique identifier.
	ID string `json:"id"`
	// URL for inventory history web page.
	InventoryHistoryURL *string `json:"inventoryHistoryUrl"`
	// Get the inventory level at a specific location.
	InventoryLevel *InventoryLevel `json:"inventoryLevel"`
	// Paginated list of inventory levels for each location that the inventory item is stocked at.
	InventoryLevels *InventoryLevelConnection `json:"inventoryLevels"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The number of locations where this inventory item is stocked.
	LocationsCount int64 `json:"locationsCount"`
	// The ISO code of the province of origin.
	ProvinceCodeOfOrigin *string `json:"provinceCodeOfOrigin"`
	// Whether the item requires shipping or not.
	RequiresShipping bool `json:"requiresShipping"`
	// Inventory item SKU.
	Sku *string `json:"sku"`
	// Whether the inventory quantities of inventory levels for the item are tracked or not.
	Tracked bool `json:"tracked"`
	// Whether changes to the inventory item tracked attribute are allowed.
	TrackedEditable *EditableProperty `json:"trackedEditable"`
	// Unit cost associated with the inventory item.
	UnitCost *MoneyV2 `json:"unitCost"`
	// The date and time when the inventory item was updated.
	UpdatedAt string `json:"updatedAt"`
	// The variant that owns this inventory item.
	Variant *ProductVariant `json:"variant"`
}

func (InventoryItem) IsNode()                   {}
func (InventoryItem) IsLegacyInteroperability() {}

type InventoryItemConnection struct {
	// A list of edges.
	Edges []*InventoryItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type InventoryItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of InventoryItemEdge.
	Node *InventoryItem `json:"node"`
}

// Inventory items.
type InventoryItemInput struct {
	// Unit cost associated with the inventory item, the currency is the shop's default currency.
	Cost *string `json:"cost,omitempty"`
	// Whether the inventory item is tracked.
	Tracked *bool `json:"tracked,omitempty"`
}

// Inventory items.
type InventoryItemUpdateInput struct {
	// Unit cost associated with the inventory item, the currency is the shop's default currency.
	Cost *string `json:"cost,omitempty"`
	// Whether the inventory item is tracked.
	Tracked *bool `json:"tracked,omitempty"`
	// The ISO code of the country of origin.
	CountryCodeOfOrigin *CountryCode `json:"countryCodeOfOrigin,omitempty"`
	// The ISO code of the province of origin.
	ProvinceCodeOfOrigin *string `json:"provinceCodeOfOrigin,omitempty"`
	// The harmonized system code of the inventory item.
	HarmonizedSystemCode *string `json:"harmonizedSystemCode,omitempty"`
	// List of country-specific harmonized system codes.
	CountryHarmonizedSystemCodes []*CountryHarmonizedSystemCodeInput `json:"countryHarmonizedSystemCodes,omitempty"`
}

// Return type for `inventoryItemUpdate` mutation.
type InventoryItemUpdatePayload struct {
	// The updated inventory item.
	InventoryItem *InventoryItem `json:"inventoryItem"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents the inventory quantity of an inventory item at a specific location.
//
type InventoryLevel struct {
	// Quantity of items available at the location.
	Available int64 `json:"available"`
	// Whether inventoryDeactivate is allowed for this inventory level.
	CanDeactivate bool `json:"canDeactivate"`
	// The date and time when the inventory level was created.
	CreatedAt string `json:"createdAt"`
	// Reason why canDeactivate is false, or impact of deactivating the inventory level.
	DeactivationAlert *string `json:"deactivationAlert"`
	// Reason why canDeactivate is false with URLs linked in HTML, or impact of deactivating the inventory level.
	DeactivationAlertHTML *string `json:"deactivationAlertHtml"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Quantity of items incoming to the location.
	Incoming int64 `json:"incoming"`
	// Inventory item associated with the inventory level.
	Item *InventoryItem `json:"item"`
	// Location associated with the inventory level.
	Location *Location `json:"location"`
	// The date and time when the inventory level was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (InventoryLevel) IsNode() {}

type InventoryLevelConnection struct {
	// A list of edges.
	Edges []*InventoryLevelEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type InventoryLevelEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of InventoryLevelEdge.
	Node *InventoryLevel `json:"node"`
}

// Inventory quantity at a specific location.
type InventoryLevelInput struct {
	// Sets the quantity available at the location.
	AvailableQuantity int64 `json:"availableQuantity,omitempty"`
	// ID of the location.
	LocationID string `json:"locationId,omitempty"`
}

// A job corresponds to some long running task that the client should poll for status.
type Job struct {
	// This indicates if the job is still queued or has been run.
	Done bool `json:"done"`
	// Globally unique identifier.
	ID string `json:"id"`
	// This field will only resolve once the job is done. Can be used to ask for object(s) that have been changed by the job.
	Query *QueryRoot `json:"query"`
}

// Return type for `kitSkillTriggerRequest` mutation.
type KitSkillTriggerRequestPayload struct {
	// Conversation unique identifier sent to Conversation API and returned to app developer.
	ConversationUID *string `json:"conversationUid"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The total number of pending orders on a shop if less then a maximum, or that maximum.
// The atMax field indicates when this maximum has been reached.
//
type LimitedPendingOrderCount struct {
	// This is set when the number of pending orders has reached the maximum.
	AtMax bool `json:"atMax"`
	// The number of pendings orders on the shop.
	// Limited to a maximum of 10000.
	//
	Count int64 `json:"count"`
}

// Represents a single line in a shopping cart.
type LineItem struct {
	// Whether the line item's variant has an ID and inventory is managed by Shopify.
	CanRestock bool `json:"canRestock"`
	// List of additional information (metafields) about the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The discounts that have been allocated onto the line item by discount applications.
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// The total line price after discounts are applied.
	DiscountedTotal string `json:"discountedTotal"`
	// The total line price after discounts are applied in shop and presentment currencies.
	DiscountedTotalSet *MoneyBag `json:"discountedTotalSet"`
	// The price of a single variant unit after line item discounts are applied.
	DiscountedUnitPrice string `json:"discountedUnitPrice"`
	// The price of a single variant unit after line item discounts are applied in shop and presentment currencies.
	DiscountedUnitPriceSet *MoneyBag `json:"discountedUnitPriceSet"`
	// The duties associated with the line item.
	Duties []*Duty `json:"duties"`
	// The total number of units to fulfill.
	FulfillableQuantity int64 `json:"fulfillableQuantity"`
	// Name of the service provider who fulfilled the order.
	//
	// Valid values are either **manual** or the name of the provider.
	// For example, **amazon**, **shipwire**.
	//
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// The line item's fulfillment status. Returns 'fulfilled' if fulfillableQuantity >= quantity,
	// 'partial' if  fulfillableQuantity > 0, and 'unfulfilled' otherwise.
	//
	FulfillmentStatus string `json:"fulfillmentStatus"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The Image object associated to the line item's variant.
	Image *Image `json:"image"`
	// Whether the line item can be edited or not.
	MerchantEditable bool `json:"merchantEditable"`
	// Name of the product.
	Name string `json:"name"`
	// A count of the number of line items that cannot be fulfilled.
	NonFulfillableQuantity int64 `json:"nonFulfillableQuantity"`
	// Total price (without discounts) of the line item, based on the original unit price of the variant x quantity.
	//
	OriginalTotal string `json:"originalTotal"`
	// Total price (without discounts) of the line item, based on the original unit price of the  variant x quantity in shop and presentment currencies.
	OriginalTotalSet *MoneyBag `json:"originalTotalSet"`
	// Variant price without any discounts applied.
	OriginalUnitPrice string `json:"originalUnitPrice"`
	// Variant price without any discounts applied in shop and presentment currencies.
	OriginalUnitPriceSet *MoneyBag `json:"originalUnitPriceSet"`
	// The Product object associated with this line item's variant.
	Product *Product `json:"product"`
	// Number of variant items ordered.
	Quantity int64 `json:"quantity"`
	// The line item's quantity minus its refundedQuantity.
	RefundableQuantity int64 `json:"refundableQuantity"`
	// Whether physical shipping is required for the variant.
	RequiresShipping bool `json:"requiresShipping"`
	// Whether the line item's variant has an ID and inventory is managed by Shopify.
	Restockable bool `json:"restockable"`
	// Variant SKU number.
	Sku *string `json:"sku"`
	// The TaxLine object connected to this line item.
	TaxLines []*TaxLine `json:"taxLines"`
	// Whether the variant is taxable.
	Taxable bool `json:"taxable"`
	// Title of the product or variant (this field only applies to custom line items).
	Title string `json:"title"`
	// The sum of all AppliedDiscounts on this line item.
	TotalDiscount string `json:"totalDiscount"`
	// The sum of all AppliedDiscounts on this line item in shop and presentment currencies.
	TotalDiscountSet *MoneyBag `json:"totalDiscountSet"`
	// The total discounted value of unfulfilled units.
	UnfulfilledDiscountedTotal string `json:"unfulfilledDiscountedTotal"`
	// The total discounted value of unfulfilled units in shop and presentment currencies.
	UnfulfilledDiscountedTotalSet *MoneyBag `json:"unfulfilledDiscountedTotalSet"`
	// The total value before discount of all unfulfilled units.
	UnfulfilledOriginalTotal string `json:"unfulfilledOriginalTotal"`
	// The total value before discount of all unfulfilled units in shop and presentment currencies.
	UnfulfilledOriginalTotalSet *MoneyBag `json:"unfulfilledOriginalTotalSet"`
	// The number of units not yet fulfilled.
	UnfulfilledQuantity int64 `json:"unfulfilledQuantity"`
	// The Variant object associated with this line item.
	Variant *ProductVariant `json:"variant"`
	// Name of the variant.
	VariantTitle *string `json:"variantTitle"`
	// Name of the vendor who made the variant.
	Vendor *string `json:"vendor"`
}

func (LineItem) IsNode() {}

type LineItemConnection struct {
	// A list of edges.
	Edges []*LineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type LineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of LineItemEdge.
	Node *LineItem `json:"node"`
}

// Represents a single line in a shopping cart.
type LineItemMutable struct {
	// Whether the line item's variant has an ID and inventory is managed by Shopify.
	CanRestock bool `json:"canRestock"`
	// List of additional information (metafields) about the line item.
	CustomAttributes []*Attribute `json:"customAttributes"`
	// The discounts that have been allocated onto the line item by discount applications.
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// The total line price after discounts are applied.
	DiscountedTotal string `json:"discountedTotal"`
	// The total line price after discounts are applied in shop and presentment currencies.
	DiscountedTotalSet *MoneyBag `json:"discountedTotalSet"`
	// The price of a single variant unit after line item discounts are applied.
	DiscountedUnitPrice string `json:"discountedUnitPrice"`
	// The price of a single variant unit after line item discounts are applied in shop and presentment currencies.
	DiscountedUnitPriceSet *MoneyBag `json:"discountedUnitPriceSet"`
	// The total number of units to fulfill.
	FulfillableQuantity int64 `json:"fulfillableQuantity"`
	// Name of the service provider who fulfilled the order.
	//
	// Valid values are either **manual** or the name of the provider.
	// For example, **amazon**, **shipwire**.
	//
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// The line item's fulfillment status. Returns 'fulfilled' if fulfillableQuantity >= quantity,
	// 'partial' if  fulfillableQuantity > 0, and 'unfulfilled' otherwise.
	//
	FulfillmentStatus string `json:"fulfillmentStatus"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The Image object associated to the line item's variant.
	Image *Image `json:"image"`
	// Whether the line item can be edited or not.
	MerchantEditable bool `json:"merchantEditable"`
	// Name of the product.
	Name string `json:"name"`
	// A count of the number of line items that cannot be fulfilled.
	NonFulfillableQuantity int64 `json:"nonFulfillableQuantity"`
	// Total price (without discounts) of the line item, based on the original unit price of the variant x quantity.
	//
	OriginalTotal string `json:"originalTotal"`
	// Total price (without discounts) of the line item, based on the original unit price of the  variant x quantity in shop and presentment currencies.
	OriginalTotalSet *MoneyBag `json:"originalTotalSet"`
	// Variant price without any discounts applied.
	OriginalUnitPrice string `json:"originalUnitPrice"`
	// Variant price without any discounts applied in shop and presentment currencies.
	OriginalUnitPriceSet *MoneyBag `json:"originalUnitPriceSet"`
	// The Product object associated with this line item's variant.
	Product *Product `json:"product"`
	// Number of variant items ordered.
	Quantity int64 `json:"quantity"`
	// The line item's quantity minus its refundedQuantity.
	RefundableQuantity int64 `json:"refundableQuantity"`
	// Whether physical shipping is required for the variant.
	RequiresShipping bool `json:"requiresShipping"`
	// Whether the line item's variant has an ID and inventory is managed by Shopify.
	Restockable bool `json:"restockable"`
	// Variant SKU number.
	Sku *string `json:"sku"`
	// The TaxLine object connected to this line item.
	TaxLines []*TaxLine `json:"taxLines"`
	// Whether the variant is taxable.
	Taxable bool `json:"taxable"`
	// Title of the product or variant (this field only applies to custom line items).
	Title string `json:"title"`
	// The sum of all AppliedDiscounts on this line item.
	TotalDiscount string `json:"totalDiscount"`
	// The sum of all AppliedDiscounts on this line item in shop and presentment currencies.
	TotalDiscountSet *MoneyBag `json:"totalDiscountSet"`
	// The total discounted value of unfulfilled units.
	UnfulfilledDiscountedTotal string `json:"unfulfilledDiscountedTotal"`
	// The total discounted value of unfulfilled units in shop and presentment currencies.
	UnfulfilledDiscountedTotalSet *MoneyBag `json:"unfulfilledDiscountedTotalSet"`
	// The total value before discount of all unfulfilled units.
	UnfulfilledOriginalTotal string `json:"unfulfilledOriginalTotal"`
	// The total value before discount of all unfulfilled units in shop and presentment currencies.
	UnfulfilledOriginalTotalSet *MoneyBag `json:"unfulfilledOriginalTotalSet"`
	// The number of units not yet fulfilled.
	UnfulfilledQuantity int64 `json:"unfulfilledQuantity"`
	// The Variant object associated with this line item.
	Variant *ProductVariant `json:"variant"`
	// Name of the variant.
	VariantTitle *string `json:"variantTitle"`
	// Name of the vendor who made the variant.
	Vendor *string `json:"vendor"`
}

func (LineItemMutable) IsNode() {}

type LineItemMutableConnection struct {
	// A list of edges.
	Edges []*LineItemMutableEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type LineItemMutableEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of LineItemMutableEdge.
	Node *LineItemMutable `json:"node"`
}

// A link to direct users to.
type Link struct {
	// A context-sensitive label for the link.
	Label string `json:"label"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
	// The URL that the link visits.
	URL string `json:"url"`
}

func (Link) IsHasPublishedTranslations() {}

// A locale.
type Locale struct {
	// Locale ISO code.
	IsoCode string `json:"isoCode"`
	// Locale name.
	Name string `json:"name"`
}

// Represents the value captured by a localization extension, like a tax id.
type LocalizationExtension struct {
	// Country ISO 3166-1 alpha-2 code.
	CountryCode CountryCode `json:"countryCode"`
	// The purpose of this localization extension.
	Purpose LocalizationExtensionPurpose `json:"purpose"`
	// The localized extension title.
	Title string `json:"title"`
	// The value of the field.
	Value string `json:"value"`
}

type LocalizationExtensionConnection struct {
	// A list of edges.
	Edges []*LocalizationExtensionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type LocalizationExtensionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of LocalizationExtensionEdge.
	Node *LocalizationExtension `json:"node"`
}

// Represents the location where the physical good resides.
//
type Location struct {
	// Whether this location can be reactivated.
	Activatable bool `json:"activatable"`
	// The LocationAddress object for location.
	Address *LocationAddress `json:"address"`
	// Whether the location address has been verified.
	AddressVerified bool `json:"addressVerified"`
	// Whether this location can be deactivated.
	Deactivatable bool `json:"deactivatable"`
	// Date and time the location was deactivated (null if location is still active). Following UTC ISO8601 format, e.g.: "2019-04-24T13:42:24Z".
	DeactivatedAt *string `json:"deactivatedAt"`
	// Whether this location can be deleted.
	Deletable bool `json:"deletable"`
	// Name of the service provider that fulfills from this location.
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// Indicates whether this location can fulfill online orders.
	FulfillsOnlineOrders bool `json:"fulfillsOnlineOrders"`
	// Indicates whether or not this location has active inventory.
	HasActiveInventory bool `json:"hasActiveInventory"`
	// Indicates whether or not this location has unfulfilled orders.
	HasUnfulfilledOrders bool `json:"hasUnfulfilledOrders"`
	// Globally unique identifier.
	ID string `json:"id"`
	// A single inventory level for the given inventory item.
	InventoryLevel *InventoryLevel `json:"inventoryLevel"`
	// Paginated list of inventory levels for inventory items stocked at the location.
	InventoryLevels *InventoryLevelConnection `json:"inventoryLevels"`
	// Whether the location is active.
	IsActive bool `json:"isActive"`
	// Whether the location is your primary location for shipping inventory.
	IsPrimary bool `json:"isPrimary"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The name of the location.
	Name string `json:"name"`
	// Indicates whether or not this location is used for calculating shipping rates.
	ShipsInventory bool `json:"shipsInventory"`
	// List of suggested addresses for this location (empty if none).
	SuggestedAddresses []*LocationSuggestedAddress `json:"suggestedAddresses"`
}

func (Location) IsNode()                   {}
func (Location) IsLegacyInteroperability() {}

// Represents the address of the location.
//
type LocationAddress struct {
	// The first line of the address for the location.
	Address1 *string `json:"address1"`
	// The second line of the address for the location.
	Address2 *string `json:"address2"`
	// The city of the location.
	City *string `json:"city"`
	// The country of the location.
	Country *string `json:"country"`
	// The two-letter country code of the location.
	CountryCode *string `json:"countryCode"`
	// A formatted version of the location address.
	Formatted []string `json:"formatted"`
	// The latitude coordinates of the location.
	Latitude *float64 `json:"latitude"`
	// The longitude coordinates of the location.
	Longitude *float64 `json:"longitude"`
	// The phone number of the location.
	Phone *string `json:"phone"`
	// The province of the location.
	Province *string `json:"province"`
	// The code for the region of the address, such as the province, state, or district.
	// For example QC for Quebec, Canada.
	//
	ProvinceCode *string `json:"provinceCode"`
	// The ZIP code of the location.
	Zip *string `json:"zip"`
}

type LocationConnection struct {
	// A list of edges.
	Edges []*LocationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type LocationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of LocationEdge.
	Node *Location `json:"node"`
}

// Represents a suggested address for a location.
//
type LocationSuggestedAddress struct {
	// The first line of the suggested address.
	Address1 *string `json:"address1"`
	// The second line of the suggested address.
	Address2 *string `json:"address2"`
	// The city of the suggested address.
	City *string `json:"city"`
	// The country of the suggested address.
	Country *string `json:"country"`
	// The country code of the suggested address.
	CountryCode *CountryCode `json:"countryCode"`
	// A formatted version of the suggested address.
	Formatted []string `json:"formatted"`
	// The province of the suggested address.
	Province *string `json:"province"`
	// The province code of the suggested address.
	ProvinceCode *string `json:"provinceCode"`
	// The ZIP code of the suggested address.
	Zip *string `json:"zip"`
}

// Represents a customer mailing address.
//
// For example, a customer's default address and an order's billing address are both mailling addresses.
//
type MailingAddress struct {
	// The first line of the address. Typically the street address or PO Box number.
	//
	Address1 *string `json:"address1"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	//
	Address2 *string `json:"address2"`
	// The name of the city, district, village, or town.
	//
	City *string `json:"city"`
	// The name of the customer's company or organization.
	//
	Company *string `json:"company"`
	// The name of the country.
	//
	Country *string `json:"country"`
	// The two-letter code for the country of the address.
	//
	// For example, US.
	//
	CountryCode *string `json:"countryCode"`
	// The two-letter code for the country of the address.
	//
	// For example, US.
	//
	CountryCodeV2 *CountryCode `json:"countryCodeV2"`
	// The first name of the customer.
	FirstName *string `json:"firstName"`
	// A formatted version of the address, customized by the provided arguments.
	Formatted []string `json:"formatted"`
	// A comma-separated list of the values for city, province, and country.
	FormattedArea *string `json:"formattedArea"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The last name of the customer.
	LastName *string `json:"lastName"`
	// The latitude coordinate of the customer address.
	Latitude *float64 `json:"latitude"`
	// The longitude coordinate of the customer address.
	Longitude *float64 `json:"longitude"`
	// The full name of the customer, based on firstName and lastName.
	//
	Name *string `json:"name"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	//
	Phone *string `json:"phone"`
	// The region of the address, such as the province, state, or district.
	Province *string `json:"province"`
	// The two-letter code for the region.
	//
	// For example, ON.
	//
	ProvinceCode *string `json:"provinceCode"`
	// The zip or postal code of the address.
	Zip *string `json:"zip"`
}

func (MailingAddress) IsNode() {}

// The fields used to create or update a mailing address.
type MailingAddressInput struct {
	// The first line of the address. Typically the street address or PO Box number.
	//
	Address1 *string `json:"address1,omitempty"`
	// The second line of the address. Typically the number of the apartment, suite, or unit.
	//
	Address2 *string `json:"address2,omitempty"`
	// The name of the city, district, village, or town.
	//
	City *string `json:"city,omitempty"`
	// The name of the customer's company or organization.
	//
	Company *string `json:"company,omitempty"`
	// The name of the country. This argument is deprecated: Use `countryCode` instead.
	Country *string `json:"country,omitempty"`
	// The two-letter code for the country of the address.
	CountryCode *CountryCode `json:"countryCode,omitempty"`
	// The first name of the customer.
	FirstName *string `json:"firstName,omitempty"`
	// This argument is deprecated: Not needed for 90% of mutations, and provided separately where it is needed.
	ID *string `json:"id,omitempty"`
	// The last name of the customer.
	LastName *string `json:"lastName,omitempty"`
	// A unique phone number for the customer.
	//
	// Formatted using E.164 standard. For example, _+16135551111_.
	//
	Phone *string `json:"phone,omitempty"`
	// The region of the address, such as the province, state, or district. This argument is deprecated: Use `provinceCode` instead.
	Province *string `json:"province,omitempty"`
	// The code for the region of the address, such as the province, state, or district.
	// For example QC for Quebec, Canada.
	//
	ProvinceCode *string `json:"provinceCode,omitempty"`
	// The zip or postal code of the address.
	Zip *string `json:"zip,omitempty"`
}

// Manual discount applications capture the intentions of a discount that was manually created for an order.
//
type ManualDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The description of the discount application.
	Description *string `json:"description"`
	// An ordered index that can be used to identify the discount application and indicate the precedence
	// of the discount application for calculations.
	//
	Index int64 `json:"index"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the discount application.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (ManualDiscountApplication) IsDiscountApplication() {}

// A marketing activity represents marketing created by an app on behalf of the merchant.
type MarketingActivity struct {
	// The url of the activity listing page of this marketing activity in the marketing section.
	ActivityListURL *string `json:"activityListUrl"`
	// Amount spent on this marketing activity.
	AdSpend *MoneyV2 `json:"adSpend"`
	// The app which created this marketing activity.
	App *App `json:"app"`
	// Errors generated when app was trying to complete this activity.
	AppErrors *MarketingActivityExtensionAppErrors `json:"appErrors"`
	// The budget for this marketing activity.
	Budget *MarketingBudget `json:"budget"`
	// The date and time when the marketing activity was created.
	CreatedAt string `json:"createdAt"`
	// The form data of the marketing activity.
	FormData *string `json:"formData"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The broad category of marketing, used for reporting aggregation.
	MarketingChannel MarketingChannel `json:"marketingChannel"`
	// Associated marketing event of this marketing activity.
	MarketingEvent *MarketingEvent `json:"marketingEvent"`
	// A contextual description of the marketing activity based on the platform and tactic used.
	SourceAndMedium string `json:"sourceAndMedium"`
	// Status helps to identify if this marketing activity has been completed, queued, failed etc.
	Status MarketingActivityStatus `json:"status"`
	// StatusBadgeType helps to identify the color of the status badge.
	StatusBadgeType *MarketingActivityStatusBadgeType `json:"statusBadgeType"`
	// Status label to describe the status of the marketing activity.
	StatusLabel string `json:"statusLabel"`
	// The [date and time](
	//           https://help.shopify.com/https://en.wikipedia.org/wiki/ISO_8601
	//           ) when the activity's status last changed.
	StatusTransitionedAt *string `json:"statusTransitionedAt"`
	// The method of marketing used for this marketing activity.
	Tactic MarketingTactic `json:"tactic"`
	// Expected status set by app in prior to an asynchronous operation.
	TargetStatus *MarketingActivityStatus `json:"targetStatus"`
	// Title of this marketing activity.
	Title string `json:"title"`
	// The date and time when the marketing activity was updated.
	UpdatedAt string `json:"updatedAt"`
	// The set of UTM parameters being tracked for this marketing activity.
	UtmParameters *UTMParameters `json:"utmParameters"`
}

func (MarketingActivity) IsNode() {}

// This type combines budget amount and its marketing budget type.
type MarketingActivityBudgetInput struct {
	// Budget type for marketing activity.
	BudgetType *MarketingBudgetBudgetType `json:"budgetType,omitempty"`
	// Amount of budget for the marketing activity.
	Total *MoneyInput `json:"total,omitempty"`
}

type MarketingActivityConnection struct {
	// A list of edges.
	Edges []*MarketingActivityEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Specifies the input fields required to create a marketing activity.
type MarketingActivityCreateInput struct {
	// The title of the marketing activity.
	MarketingActivityTitle *string `json:"marketingActivityTitle,omitempty"`
	// The form data in JSON serialized as a string.
	FormData *string `json:"formData,omitempty"`
	// The ID of the marketing activity extension.
	MarketingActivityExtensionID string `json:"marketingActivityExtensionId,omitempty"`
	// Encoded context containing marketing campaign id.
	Context *string `json:"context,omitempty"`
	// Specifies the
	// [Urchin Traffic Module (UTM) parameters](https://en.wikipedia.org/wiki/UTM_parameters)
	// that are associated with a related marketing campaign. UTMInput is required for all Marketing
	// tactics except Storefront App.
	//
	Utm *UTMInput `json:"utm,omitempty"`
	// The current state of the marketing activity.
	Status MarketingActivityStatus `json:"status,omitempty"`
	// The budget for this marketing activity.
	Budget *MarketingActivityBudgetInput `json:"budget,omitempty"`
}

// Return type for `marketingActivityCreate` mutation.
type MarketingActivityCreatePayload struct {
	// The created marketing activity.
	MarketingActivity *MarketingActivity `json:"marketingActivity"`
	// The path to return back to shopify admin from embedded editor.
	RedirectPath *string `json:"redirectPath"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type MarketingActivityEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MarketingActivityEdge.
	Node *MarketingActivity `json:"node"`
}

// Represents errors returned from apps when using the marketing activity extension.
type MarketingActivityExtensionAppErrors struct {
	// The app error type.
	Code MarketingActivityExtensionAppErrorCode `json:"code"`
	// The list of errors returned by the app.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the input fields required to update a marketing activity.
type MarketingActivityUpdateInput struct {
	// The id for this marketing activity.
	ID string `json:"id,omitempty"`
	// The ID of the recommendation this marketing activity was created from, if one exists.
	MarketingRecommendationID *string `json:"marketingRecommendationId,omitempty"`
	// The title of this marketing activity.
	Title *string `json:"title,omitempty"`
	// The budget for this marketing activity.
	Budget *MarketingActivityBudgetInput `json:"budget,omitempty"`
	// The cumulative amount spent on this marketing activity. This argument is deprecated: Use `MarketingEngagementCreate.MarketingEngagementInput.adSpend` GraphQL to send the ad spend.
	AdSpend *MoneyInput `json:"adSpend,omitempty"`
	// The current state of the marketing activity.
	Status *MarketingActivityStatus `json:"status,omitempty"`
	// The target state of the marketing activity.
	TargetStatus *MarketingActivityStatus `json:"targetStatus,omitempty"`
	// The form data of the marketing activity.
	FormData *string `json:"formData,omitempty"`
	// Specifies the
	// [Urchin Traffic Module (UTM) parameters](https://en.wikipedia.org/wiki/UTM_parameters)
	// that are associated with a related marketing campaign. UTMInput is required for all Marketing
	// tactics except Storefront App. This utm param can be only set once and never modified.
	//
	Utm *UTMInput `json:"utm,omitempty"`
	// A list of the items that were marketed in this marketing activity. Valid types for these items are:
	// * `Product`
	// * `Shop` (Must be your current shop).
	//
	MarketedResources []string `json:"marketedResources,omitempty"`
	// Encoded context provided by Shopify during the update marketing activity callback. This argument is deprecated: This context is no longer needed by Shopify in the callback.
	Context *string `json:"context,omitempty"`
	// Error messages generated when app was trying to complete this activity.
	Errors *string `json:"errors,omitempty"`
}

// Return type for `marketingActivityUpdate` mutation.
type MarketingActivityUpdatePayload struct {
	// The updated marketing activity.
	MarketingActivity *MarketingActivity `json:"marketingActivity"`
	// The path to return back to shopify admin from embedded editor.
	RedirectPath *string `json:"redirectPath"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// This type combines budget amount and its marketing budget type.
//
type MarketingBudget struct {
	// The budget type for a marketing activity.
	BudgetType MarketingBudgetBudgetType `json:"budgetType"`
	// The amount of budget for marketing activity.
	Total *MoneyV2 `json:"total"`
}

// Marketing engagement represents customer activity taken on a marketing event.
type MarketingEngagement struct {
	// The total ad spend for the day, if the marketing event is a paid ad with a daily spend.
	AdSpend *MoneyV2 `json:"adSpend"`
	// The total number of clicks on the marketing event for the day.
	ClicksCount *int64 `json:"clicksCount"`
	// The total number of comments for the day.
	CommentsCount *int64 `json:"commentsCount"`
	// The total number of complaints for the day.
	ComplaintsCount *int64 `json:"complaintsCount"`
	// The total number of fails for the day.
	FailsCount *int64 `json:"failsCount"`
	// The total number of favorites for the day.
	FavoritesCount *int64 `json:"favoritesCount"`
	// The date time at which the data was fetched.
	FetchedAt *string `json:"fetchedAt"`
	// The total number of impressions for the day.
	ImpressionsCount *int64 `json:"impressionsCount"`
	// Whether the engagements are reported as lifetime values rather than daily totals.
	IsCumulative *bool `json:"isCumulative"`
	// The marketing activity related to this engagement.
	MarketingActivity *MarketingActivity `json:"marketingActivity"`
	// The date that these engagements occurred on.
	OccurredOn time.Time `json:"occurredOn"`
	// The total number of sends for the day.
	SendsCount *int64 `json:"sendsCount"`
	// The total number of shares for the day.
	SharesCount *int64 `json:"sharesCount"`
	// The total number of unique clicks for the day.
	UniqueClicksCount *int64 `json:"uniqueClicksCount"`
	// The total number of unique views for the day.
	UniqueViewsCount *int64 `json:"uniqueViewsCount"`
	// The total number of unsubscribes for the day.
	UnsubscribesCount *int64 `json:"unsubscribesCount"`
	// The UTC Offset that the app is using to determine which date to allocate spend to.
	UtcOffset *string `json:"utcOffset"`
	// The total number of views for the day.
	ViewsCount *int64 `json:"viewsCount"`
}

// Return type for `marketingEngagementCreate` mutation.
type MarketingEngagementCreatePayload struct {
	// The marketing engagement that was created.
	MarketingEngagement *MarketingEngagement `json:"marketingEngagement"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// This object represents marketing engagement input fields for a marketing engagement.
type MarketingEngagementInput struct {
	// The date that these engagements occurred on.
	OccurredOn time.Time `json:"occurredOn,omitempty"`
	// The total number of impressions for the day.
	ImpressionsCount *int64 `json:"impressionsCount,omitempty"`
	// The total number of views for the day.
	ViewsCount *int64 `json:"viewsCount,omitempty"`
	// The total number of clicks on the marketing event for the day.
	ClicksCount *int64 `json:"clicksCount,omitempty"`
	// The total number of shares for the day.
	SharesCount *int64 `json:"sharesCount,omitempty"`
	// The total number of favorites for the day.
	FavoritesCount *int64 `json:"favoritesCount,omitempty"`
	// The total number of comments for the day.
	CommentsCount *int64 `json:"commentsCount,omitempty"`
	// The total number of unsubscribes for the day.
	UnsubscribesCount *int64 `json:"unsubscribesCount,omitempty"`
	// The total number of complaints for the day.
	ComplaintsCount *int64 `json:"complaintsCount,omitempty"`
	// The total number of fails for the day.
	FailsCount *int64 `json:"failsCount,omitempty"`
	// The total number of sends for the day.
	SendsCount *int64 `json:"sendsCount,omitempty"`
	// The total number of unique views for the day.
	UniqueViewsCount *int64 `json:"uniqueViewsCount,omitempty"`
	// The total number of unique clicks for the day.
	UniqueClicksCount *int64 `json:"uniqueClicksCount,omitempty"`
	// The total ad spend for the day, if the marketing event is a paid ad with a daily spend.
	AdSpend *MoneyInput `json:"adSpend,omitempty"`
	// Whether the engagements are reported as lifetime values rather than daily totals.
	IsCumulative *bool `json:"isCumulative,omitempty"`
	// The UTC Offset that the app is using to determine which date to allocate spend to.
	UtcOffset *string `json:"utcOffset,omitempty"`
	// The date time at which the data was fetched.
	FetchedAt *string `json:"fetchedAt,omitempty"`
}

// Represents actions that market a merchant's store or products.
type MarketingEvent struct {
	// The app that the marketing event is attributed to.
	App *App `json:"app"`
	// The marketing channel used by the marketing event.
	Channel *MarketingChannel `json:"channel"`
	// A human-readable description of the marketing event.
	Description *string `json:"description"`
	// The date and time when the marketing event ended.
	EndedAt *string `json:"endedAt"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The URL where the marketing event can be managed.
	ManageURL *string `json:"manageUrl"`
	// The URL where the marketing event can be previewed.
	PreviewURL *string `json:"previewUrl"`
	// An optional ID that helps Shopify validate engagement data.
	RemoteID *string `json:"remoteId"`
	// The date and time when the marketing event is scheduled to end.
	ScheduledToEndAt *string `json:"scheduledToEndAt"`
	// Where the `MarketingEvent` occurred and what kind of content was used.
	// Because `utmSource` and `utmMedium` are often used interchangeably, this is
	// based on a combination of `marketingChannel`, `referringDomain`, and `type` to
	// provide a consistent representation for any given piece of marketing
	// regardless of the app that created it.
	//
	SourceAndMedium string `json:"sourceAndMedium"`
	// The date and time when the marketing event started.
	StartedAt string `json:"startedAt"`
	// The display text for the marketing event type.
	TargetTypeDisplayText string `json:"targetTypeDisplayText"`
	// The marketing event type.
	Type MarketingTactic `json:"type"`
	// The name of the marketing campaign.
	UtmCampaign *string `json:"utmCampaign"`
	// The medium that the marketing campaign is using. Example values: `cpc`, `banner`.
	UtmMedium *string `json:"utmMedium"`
	// The referrer of the marketing event. Example values: `google`, `newsletter`.
	UtmSource *string `json:"utmSource"`
}

func (MarketingEvent) IsNode()                   {}
func (MarketingEvent) IsLegacyInteroperability() {}

type MarketingEventConnection struct {
	// A list of edges.
	Edges []*MarketingEventEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type MarketingEventEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MarketingEventEdge.
	Node *MarketingEvent `json:"node"`
}

type MediaConnection struct {
	// A list of edges.
	Edges []*MediaEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type MediaEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MediaEdge.
	Node Media `json:"node"`
}

// Represents a media error.
//
type MediaError struct {
	// Code representing the type of error.
	Code MediaErrorCode `json:"code"`
	// Additional details regarding the error.
	Details *string `json:"details"`
	// Translated error message.
	Message string `json:"message"`
}

// Represents a Shopify hosted image.
//
type MediaImage struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The image for the media.
	Image *Image `json:"image"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// Any errors which have occurred on the media.
	MediaErrors []*MediaError `json:"mediaErrors"`
	// The MIME type of the image.
	MimeType *string `json:"mimeType"`
	// The preview image for the media.
	Preview *MediaPreviewImage `json:"preview"`
	// Current status of the media.
	Status MediaStatus `json:"status"`
}

func (MediaImage) IsNode()  {}
func (MediaImage) IsMedia() {}

// Represents the preview image for a media.
type MediaPreviewImage struct {
	// The preview image for the media.
	Image *Image `json:"image"`
	// Current status of the preview image.
	Status MediaPreviewImageStatus `json:"status"`
}

// Represents an error that happens during execution of a Media query or mutation.
type MediaUserError struct {
	// Error code to uniquely identify the error.
	Code *MediaUserErrorCode `json:"code"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (MediaUserError) IsDisplayableError() {}

// Metafields represent custom metadata attached to a resource. Metafields can be sorted into namespaces and are
// composed of keys, values, and value types.
//
type Metafield struct {
	// The date and time when the metafield was created.
	CreatedAt string `json:"createdAt"`
	// The description of a metafield.
	Description *string `json:"description"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The key name for a metafield.
	Key string `json:"key"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The namespace for a metafield.
	Namespace string `json:"namespace"`
	// Owner type of a metafield visible to the Storefront API.
	OwnerType MetafieldOwnerType `json:"ownerType"`
	// The date and time when the metafield was updated.
	UpdatedAt string `json:"updatedAt"`
	// The value of a metafield.
	Value string `json:"value"`
	// Represents the metafield value type.
	ValueType MetafieldValueType `json:"valueType"`
}

func (Metafield) IsNode()                   {}
func (Metafield) IsLegacyInteroperability() {}

type MetafieldConnection struct {
	// A list of edges.
	Edges []*MetafieldEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Specifies the input fields to delete a metafield.
type MetafieldDeleteInput struct {
	// The ID of the metafield to delete.
	ID string `json:"id,omitempty"`
}

// Return type for `metafieldDelete` mutation.
type MetafieldDeletePayload struct {
	// The ID of the deleted metafield.
	DeletedID *string `json:"deletedId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type MetafieldEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MetafieldEdge.
	Node *Metafield `json:"node"`
}

// Specifies the input fields for a metafield.
type MetafieldInput struct {
	// The description of the metafield .
	Description *string `json:"description,omitempty"`
	// The unique ID of the metafield.
	ID *string `json:"id,omitempty"`
	// The key name of the metafield.
	Key *string `json:"key,omitempty"`
	// The namespace for a metafield.
	Namespace *string `json:"namespace,omitempty"`
	// The value of a metafield.
	Value *string `json:"value,omitempty"`
	// The value type of a metafield.
	ValueType *MetafieldValueType `json:"valueType,omitempty"`
}

// Represents an allowlist record that enables a metafield to be visible to the storefront.
//
type MetafieldStorefrontVisibility struct {
	// The date and time when the allowlist record was created.
	CreatedAt string `json:"createdAt"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Key of a metafield in the visibility allowlist.
	Key string `json:"key"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// Namespace of a metafield in the visibility allowlist.
	Namespace string `json:"namespace"`
	// Owner type of a metafield in the visibility allowlist.
	OwnerType MetafieldOwnerType `json:"ownerType"`
	// The date and time when the allowlist record was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (MetafieldStorefrontVisibility) IsNode()                   {}
func (MetafieldStorefrontVisibility) IsLegacyInteroperability() {}

type MetafieldStorefrontVisibilityConnection struct {
	// A list of edges.
	Edges []*MetafieldStorefrontVisibilityEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `metafieldStorefrontVisibilityCreate` mutation.
type MetafieldStorefrontVisibilityCreatePayload struct {
	// The metafield storefront visibility that was created.
	MetafieldStorefrontVisibility *MetafieldStorefrontVisibility `json:"metafieldStorefrontVisibility"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `metafieldStorefrontVisibilityDelete` mutation.
type MetafieldStorefrontVisibilityDeletePayload struct {
	// The ID of the deleted metafield storefront visibility.
	DeletedMetafieldStorefrontVisibilityID *string `json:"deletedMetafieldStorefrontVisibilityId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type MetafieldStorefrontVisibilityEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of MetafieldStorefrontVisibilityEdge.
	Node *MetafieldStorefrontVisibility `json:"node"`
}

// Specifies the input fields for a MetafieldStorefrontVisibilityInput.
//
type MetafieldStorefrontVisibilityInput struct {
	// The namespace of the metafield to be visible to the storefront api.
	Namespace string `json:"namespace,omitempty"`
	// The key of the metafield to be visible to the storefront api.
	Key string `json:"key,omitempty"`
	// The core resource ( e.g.: Product ) that owns this metafield.
	OwnerType MetafieldOwnerType `json:"ownerType,omitempty"`
}

// Represents a Shopify hosted 3D model.
//
type Model3d struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt"`
	// The filename of the 3d model.
	Filename string `json:"filename"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// Any errors which have occurred on the media.
	MediaErrors []*MediaError `json:"mediaErrors"`
	// The original source for a 3d model.
	OriginalSource *Model3dSource `json:"originalSource"`
	// The preview image for the media.
	Preview *MediaPreviewImage `json:"preview"`
	// The sources for a 3d model.
	Sources []*Model3dSource `json:"sources"`
	// Current status of the media.
	Status MediaStatus `json:"status"`
}

func (Model3d) IsNode()  {}
func (Model3d) IsMedia() {}

// Represents a source for a Shopify hosted 3d model.
//
type Model3dSource struct {
	// The filesize of the 3d model.
	Filesize int64 `json:"filesize"`
	// The format of the 3d model.
	Format string `json:"format"`
	// The MIME type of the 3d model.
	MimeType string `json:"mimeType"`
	// The URL of the 3d model.
	URL string `json:"url"`
}

// A collection of monetary values in their respective currencies.
//
type MoneyBag struct {
	// Amount in presentment currency.
	PresentmentMoney *MoneyV2 `json:"presentmentMoney"`
	// Amount in shop currency.
	ShopMoney *MoneyV2 `json:"shopMoney"`
}

// Specifies the fields for a monetary value with currency.
type MoneyInput struct {
	// Decimal money amount.
	Amount string `json:"amount,omitempty"`
	// Currency of the money.
	CurrencyCode CurrencyCode `json:"currencyCode,omitempty"`
}

// A monetary value with currency.
//
// To format currencies, combine this type's amount and currencyCode fields with your client's locale.
//
// For example, in JavaScript you could use Intl.NumberFormat:
//
// ```js
// new Intl.NumberFormat(locale, {
//   style: 'currency',
//   currency: currencyCode
// }).format(amount);
// ```
//
// Other formatting libraries include:
//
// * iOS - [NumberFormatter](https://developer.apple.com/documentation/foundation/numberformatter)
// * Android - [NumberFormat](https://developer.android.com/reference/java/text/NumberFormat.html)
// * PHP - [NumberFormatter](http://php.net/manual/en/class.numberformatter.php)
//
// For a more general solution, the [Unicode CLDR number formatting database] is available with many implementations
// (such as [TwitterCldr](https://github.com/twitter/twitter-cldr-rb)).
//
type MoneyV2 struct {
	// Decimal money amount.
	Amount string `json:"amount"`
	// Currency of the money.
	CurrencyCode CurrencyCode `json:"currencyCode"`
}

func (MoneyV2) IsPricingValue()              {}
func (MoneyV2) IsDeliveryConditionCriteria() {}

// An individual move to perform of an object to a position.
type MoveInput struct {
	// The ID of the object to be moved.
	ID string `json:"id,omitempty"`
	// The new position of the object in the set, using a 0 based index.
	NewPosition string `json:"newPosition,omitempty"`
}

// A signed upload parameter for uploading an asset to Shopify.
type MutationsStagedUploadTargetGenerateUploadParameter struct {
	// The upload parameter name.
	Name string `json:"name"`
	// The upload parameter value.
	Value string `json:"value"`
}

// A navigation item, holding basic link attributes.
type NavigationItem struct {
	// The unique identifier of the navigation item.
	ID string `json:"id"`
	// The name of the navigation item.
	Title string `json:"title"`
	// The URL of the page that the navigation item links to.
	URL string `json:"url"`
}

// Represents an article in an OnlineStoreBlog object. Articles appear in reverse chronological order, with the
// most recent entry at the top of the blog's page. A blog can contain any number of articles.
//
type OnlineStoreArticle struct {
	// A default cursor for use in pagination.
	DefaultCursor string `json:"defaultCursor"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
}

func (OnlineStoreArticle) IsNode()                     {}
func (OnlineStoreArticle) IsNavigable()                {}
func (OnlineStoreArticle) IsHasPublishedTranslations() {}

// Shopify stores come with a built-in blogging engine, allowing a shop to have one or more blogs.  Blogs are meant
// to be used as a type of magazine or newsletter for the shop, with content that changes over time.
//
type OnlineStoreBlog struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
}

func (OnlineStoreBlog) IsNode()                     {}
func (OnlineStoreBlog) IsHasPublishedTranslations() {}

// A custom page on the Online Store.
type OnlineStorePage struct {
	// A default cursor for use in pagination.
	DefaultCursor string `json:"defaultCursor"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
}

func (OnlineStorePage) IsNode()                     {}
func (OnlineStorePage) IsNavigable()                {}
func (OnlineStorePage) IsHasPublishedTranslations() {}

// An order represents an agreement to do business between a customer and a merchant.
type Order struct {
	// Generated messages that appear at the top of an order page in the Shopify admin.
	// For example, _this is a test order_.
	//
	Alerts []*ResourceAlert `json:"alerts"`
	// Mailing address provided by the customer.
	// Not all orders have mailing addresses.
	//
	BillingAddress *MailingAddress `json:"billingAddress"`
	// Whether the billing address matches the shipping address.
	BillingAddressMatchesShippingAddress bool `json:"billingAddressMatchesShippingAddress"`
	// Whether the order can be manually marked as paid.
	CanMarkAsPaid bool `json:"canMarkAsPaid"`
	// Whether notifications can be sent to the customer or not.
	CanNotifyCustomer bool `json:"canNotifyCustomer"`
	// Reason the order was canceled.
	// Returns null if the order wasn't canceled.
	//
	CancelReason *OrderCancelReason `json:"cancelReason"`
	// Date and time when the order was canceled.
	// Returns null if the order wasn't canceled.
	//
	CancelledAt *string `json:"cancelledAt"`
	// Whether payment for the order can be captured.
	// Returns true when the customer's credit card has been authorized for payment and the authorization period has not expired.
	//
	Capturable bool `json:"capturable"`
	// Amount of the order-level discount (does not contain any line item discounts).
	CartDiscountAmount *string `json:"cartDiscountAmount"`
	// Amount of the order-level discount (does not contain any line item discounts) in shop and presentment currencies.
	CartDiscountAmountSet *MoneyBag `json:"cartDiscountAmountSet"`
	// Channel that created the order.
	Channel *Channel `json:"channel"`
	// The ip address of the client that is associated with this order.
	ClientIP *string `json:"clientIp"`
	// Whether the order is closed.
	Closed bool `json:"closed"`
	// Date and time when the order closed.
	// If the order is not closed, then this field is null.
	//
	ClosedAt *string `json:"closedAt"`
	// Whether inventory has been reserved for the order.
	Confirmed bool `json:"confirmed"`
	// Date and time when the order was created in Shopify.
	CreatedAt string `json:"createdAt"`
	// The currency of the store at the time of the order.
	// If payment hasn't occurred, then this field is null.
	//
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// The amount of the order-level discount minus the amounts for line items that have been returned. This doesn't include line item discounts.
	CurrentCartDiscountAmountSet *MoneyBag `json:"currentCartDiscountAmountSet"`
	// The sum of the quantities for the line items that contribute to the order's subtotal.
	CurrentSubtotalLineItemsQuantity int64 `json:"currentSubtotalLineItemsQuantity"`
	// The subtotal of line items and their discounts minus the line items that have been returned. This includes order-level discounts, unless the argument with_cart_discount is set to false. This doesn't include shipping costs and shipping discounts. Taxes are not included unless the order is a taxes-included order.
	CurrentSubtotalPriceSet *MoneyBag `json:"currentSubtotalPriceSet"`
	// The taxes charged for the order minus the taxes for line items that have been returned.
	CurrentTaxLines []*TaxLine `json:"currentTaxLines"`
	// The total amount discounted from the order (including order-level and line item discounts) minus the amounts for items that have been returned.
	CurrentTotalDiscountsSet *MoneyBag `json:"currentTotalDiscountsSet"`
	// Total amount of duties for the order. If duties are not applicable, then this value is `null`.
	CurrentTotalDutiesSet *MoneyBag `json:"currentTotalDutiesSet"`
	// The total amount of the order (including taxes and discounts) minus the amounts for line items that have been returned.
	CurrentTotalPriceSet *MoneyBag `json:"currentTotalPriceSet"`
	// The total of all taxes applied to the order minus the taxes for line items that have been returned.
	CurrentTotalTaxSet *MoneyBag `json:"currentTotalTaxSet"`
	// The total weight (grams) of the order minus the weights for line items that have been returned.
	CurrentTotalWeight string `json:"currentTotalWeight"`
	// Custom information added to the order by your customer
	// (Also referred to as note attributes).
	//
	CustomAttributes []*Attribute `json:"customAttributes"`
	// Unique identifier of the customer who placed the order.
	// Not all orders have customers associated with them.
	//
	Customer *Customer `json:"customer"`
	// Whether the customer agreed to receive marketing materials.
	CustomerAcceptsMarketing bool `json:"customerAcceptsMarketing"`
	// Description of the customer's experience with the store leading up to the order.
	//
	CustomerJourney *CustomerJourney `json:"customerJourney"`
	// Description of the customer's experience with the store leading up to the order.
	// Loaded asynchronously, consumers should poll until the 'ready' field resolves to true.
	//
	CustomerJourneySummary *CustomerJourneySummary `json:"customerJourneySummary"`
	// A two-letter or three-letter language code, optionally followed by a region modifier.
	// Example values could be 'en', 'en-CA', 'en-PIRATE'.
	//
	CustomerLocale *string `json:"customerLocale"`
	// Discounts that have been applied on the order.
	DiscountApplications *DiscountApplicationConnection `json:"discountApplications"`
	// Discount code provided by the customer.
	DiscountCode *string `json:"discountCode"`
	// Primary address of the customer, which is shown on the order.
	DisplayAddress *MailingAddress `json:"displayAddress"`
	// Financial status of the order that can be shown to the merchant.
	// This field does not capture all the possible details of an order's financial state and should only be used for display summary purposes.
	//
	DisplayFinancialStatus *OrderDisplayFinancialStatus `json:"displayFinancialStatus"`
	// Fulfillment status for the order that can be shown to the merchant.
	// This field does not capture all the possible details of an order's fulfillment state. It should only be used for display summary purposes.
	//
	DisplayFulfillmentStatus OrderDisplayFulfillmentStatus `json:"displayFulfillmentStatus"`
	// Summary of each dispute associated with the order. Sorted in ascending (ASC) order by ID.
	Disputes []*OrderDisputeSummary `json:"disputes"`
	// List of possible fulfilments that can be made for the order (includes line items that can be partially fulfilled).
	//
	DraftFulfillments []*DraftFulfillment `json:"draftFulfillments"`
	// Whether the order has had any edits applied or not.
	Edited bool `json:"edited"`
	// Email address provided by the customer.
	Email *string `json:"email"`
	// List of internal events associated with the order.
	Events *EventConnection `json:"events"`
	// Whether there are items that can be fulfilled.
	// After an order is completely fulfilled (or completely refunded without any fulfillments) then this field returns false.
	//
	Fulfillable bool `json:"fulfillable"`
	// List of fulfillment orders with pagination.
	FulfillmentOrders *FulfillmentOrderConnection `json:"fulfillmentOrders"`
	// List of shipments for the order.
	Fulfillments []*Fulfillment `json:"fulfillments"`
	// Whether the order has been paid in full.
	FullyPaid bool `json:"fullyPaid"`
	// Whether the merchant added timeline comments to the order.
	HasTimelineComment bool `json:"hasTimelineComment"`
	// Globally unique identifier.
	ID string `json:"id"`
	// First page of the online store that the customer visited before they submitted the order, for displaying to humans.
	LandingPageDisplayText *string `json:"landingPageDisplayText"`
	// First page of the online store that the customer visited before they submitted the order.
	LandingPageURL *string `json:"landingPageUrl"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// List of the order's line items.
	LineItems *LineItemConnection `json:"lineItems"`
	// List of the order's line items after any edits. Only available on Developer Preview.
	LineItemsMutable *LineItemMutableConnection `json:"lineItemsMutable"`
	// List of localization extensions for the resource.
	LocalizationExtensions *LocalizationExtensionConnection `json:"localizationExtensions"`
	// If the order was processed using Shopify POS, then this is its location as provided by the merchant.
	//
	Location *string `json:"location"`
	// Whether the order can be edited or not.
	MerchantEditable bool `json:"merchantEditable"`
	// A list of reasons of why the order cannot be edited.
	MerchantEditableErrors []string `json:"merchantEditableErrors"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// Unique identifier for the order that appears on the order.
	// For example, _#1000_ or _Store1001.
	// This value is not unique across multiple stores.
	//
	Name string `json:"name"`
	// Net payment for the order, based on the total amount received - total amount refunded.
	//
	NetPayment string `json:"netPayment"`
	// Net payment for the order, based on the total amount received - total amount refunded in shop and presentment currencies.
	NetPaymentSet *MoneyBag `json:"netPaymentSet"`
	// Line items that can't be fulfilled.
	// For example, because some or all of the items have been refunded, or the item is not one which can be fulfilled, such as a tip.
	// These line items would be 'lost' if you only considered the line items in draft fulfillments or fulfillments.
	//
	NonFulfillableLineItems *LineItemConnection `json:"nonFulfillableLineItems"`
	// Contents of the note associated with the order.
	//
	Note *string `json:"note"`
	// Total amount of duties prior to any applied edits for the order. If duties are not applicable, then this value is `null`.
	OriginalTotalDutiesSet *MoneyBag `json:"originalTotalDutiesSet"`
	// Total price of the order prior to any applied edits in shop and presentment currencies.
	OriginalTotalPriceSet *MoneyBag `json:"originalTotalPriceSet"`
	// The payment collection details for an order requiring additional payment.
	PaymentCollectionDetails *OrderPaymentCollectionDetails `json:"paymentCollectionDetails"`
	// List of all payment gateways used for the order.
	// For example, _authorize_net_ and _Cash on Delivery (COD)_.
	//
	PaymentGatewayNames []string `json:"paymentGatewayNames"`
	// Phone number provided by the customer.
	Phone *string `json:"phone"`
	// If the order was processed using Shopify POS, then this is its location as provided by the merchant.
	//
	PhysicalLocation *Location `json:"physicalLocation"`
	// The payment currency of the customer for this order.
	PresentmentCurrencyCode CurrencyCode `json:"presentmentCurrencyCode"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// Date and time when the order was processed.
	// When orders are imported from an app, this date and time may not match the date and time when the order was created.
	//
	ProcessedAt string `json:"processedAt"`
	// Publication that created the order.
	Publication *Publication `json:"publication"`
	// Marketing referral code from the link that the customer clicked to visit your store.
	// Supports the following URL attributes: _ref_, _source_, or _r_. For example, if the URL is myshopifystore.com/products/slide?ref=j2tj1tn2, then this value is j2tj1tn2.
	//
	ReferralCode *string `json:"referralCode"`
	// Website that sent the customer to your online store.
	//
	ReferrerDisplayText *string `json:"referrerDisplayText"`
	// Webpage where the customer clicked a link that sent them to your online store.
	// For example, _Google_ or _randomblog.com/page1_.
	//
	ReferrerURL *string `json:"referrerUrl"`
	// The difference between suggested and actual refund amounts.  A positive value indicates a difference in the merchants favor and a negative value indicates a difference in the customers favor.
	RefundDiscrepancySet *MoneyBag `json:"refundDiscrepancySet"`
	// Whether the order can be refunded.
	//
	Refundable bool `json:"refundable"`
	// List of refunds that have been applied to the order.
	//
	Refunds []*Refund `json:"refunds"`
	// Whether any line item in the order requires physical shipping.
	//
	RequiresShipping bool `json:"requiresShipping"`
	// Whether the order can be restocked.
	//
	Restockable bool `json:"restockable"`
	// Fraud risk level of the order.
	RiskLevel OrderRiskLevel `json:"riskLevel"`
	// The order risks associated with this order.
	Risks []*OrderRisk `json:"risks"`
	// Mailing address for shipping provided by the customer.
	ShippingAddress *MailingAddress `json:"shippingAddress"`
	// Line item that contains the shipping costs.
	ShippingLine *ShippingLine `json:"shippingLine"`
	// List of line items that contains the shipping costs.
	ShippingLines *ShippingLineConnection `json:"shippingLines"`
	// The sum of the quantities for the line items that contribute to the order's subtotal.
	SubtotalLineItemsQuantity int64 `json:"subtotalLineItemsQuantity"`
	// Subtotal of the line items and their discounts (does not contain shipping costs and shipping discounts).
	//
	SubtotalPrice *string `json:"subtotalPrice"`
	// Subtotal of the line items and their discounts (does not contain shipping costs and shipping discounts) in shop and presentment currencies.
	SubtotalPriceSet *MoneyBag `json:"subtotalPriceSet"`
	// The details of the suggested refund. This response can be used to submit a RefundCreate mutation.
	SuggestedRefund *SuggestedRefund `json:"suggestedRefund"`
	// A comma separated list of tags that have been added to the order.
	Tags []string `json:"tags"`
	// Taxes charged for the line item.
	TaxLines []*TaxLine `json:"taxLines"`
	// Whether taxes are included in the subtotal price of the order.
	TaxesIncluded bool `json:"taxesIncluded"`
	// Whether the order is a test.
	// Test orders are made using the Shopify Bogus Gateway or a payment provider with test mode enabled.
	//
	Test bool `json:"test"`
	// Amount authorized for the order, that is uncaptured or undercaptured.
	TotalCapturable string `json:"totalCapturable"`
	// Amount authorized for the order, that is uncaptured or undercaptured in shop and presentment currencies.
	TotalCapturableSet *MoneyBag `json:"totalCapturableSet"`
	// Total amount discounted from the order (includes order-level and line item discounts).
	TotalDiscounts *string `json:"totalDiscounts"`
	// Total amount discounted from the order (includes order-level and line item discounts) in shop and presentment currencies.
	TotalDiscountsSet *MoneyBag `json:"totalDiscountsSet"`
	// Total amount of money not yet authorized for the order.
	TotalOutstandingSet *MoneyBag `json:"totalOutstandingSet"`
	// Total amount of the order (includes taxes and discounts).
	TotalPrice string `json:"totalPrice"`
	// Total amount of the order (includes taxes and discounts) in shop and presentment currencies.
	TotalPriceSet *MoneyBag `json:"totalPriceSet"`
	// Total amount received by the customer for the order.
	TotalReceived string `json:"totalReceived"`
	// Total amount received by the customer for the order in shop and presentment currencies.
	TotalReceivedSet *MoneyBag `json:"totalReceivedSet"`
	// Total amount refunded for the order.
	TotalRefunded string `json:"totalRefunded"`
	// Total amount refunded for the order in shop and presentment currencies.
	TotalRefundedSet *MoneyBag `json:"totalRefundedSet"`
	// Total amount refunded for shipping in shop and presentment currencies.
	TotalRefundedShippingSet *MoneyBag `json:"totalRefundedShippingSet"`
	// Total amount charged for shipping the order.
	TotalShippingPrice string `json:"totalShippingPrice"`
	// Total amount charged for shipping the order in shop and presentment currencies.
	TotalShippingPriceSet *MoneyBag `json:"totalShippingPriceSet"`
	// Total of all taxes applied to the order.
	TotalTax *string `json:"totalTax"`
	// Total of all taxes applied to the order in shop and presentment currencies.
	TotalTaxSet *MoneyBag `json:"totalTaxSet"`
	// Total tip amount received for the order.
	TotalTipReceived *MoneyV2 `json:"totalTipReceived"`
	// Total weight (grams) of the order.
	TotalWeight *string `json:"totalWeight"`
	// List of all transactions associated with the order.
	Transactions []*OrderTransaction `json:"transactions"`
	// Whether no payments have been made for the order.
	// If no payments have been made for the order, then this returns true.
	//
	Unpaid bool `json:"unpaid"`
	// Date and time when the order was last modified.
	UpdatedAt string `json:"updatedAt"`
}

func (Order) IsNode()                      {}
func (Order) IsCommentEventSubject()       {}
func (Order) IsHasMetafields()             {}
func (Order) IsLegacyInteroperability()    {}
func (Order) IsHasEvents()                 {}
func (Order) IsHasLocalizationExtensions() {}
func (Order) IsCommentEventEmbed()         {}

// Specifies the authorized transaction to capture and the total amount to capture from it.
type OrderCaptureInput struct {
	// The ID of the order to capture.
	ID string `json:"id,omitempty"`
	// The ID of the authorized transaction to capture.
	ParentTransactionID string `json:"parentTransactionId,omitempty"`
	// The amount to capture.
	Amount string `json:"amount,omitempty"`
	// The currency (in ISO format) that is used to capture the order. This must be the presentment currency (the currency used by the customer) and is a required field for orders where the currency and presentment currency differ.
	Currency *CurrencyCode `json:"currency,omitempty"`
}

// Return type for `orderCapture` mutation.
type OrderCapturePayload struct {
	// The transaction of the capture.
	Transaction *OrderTransaction `json:"transaction"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies an open order to close.
type OrderCloseInput struct {
	// The ID of the order to close.
	ID string `json:"id,omitempty"`
}

// Return type for `orderClose` mutation.
type OrderClosePayload struct {
	// The closed order.
	Order *Order `json:"order"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type OrderConnection struct {
	// A list of edges.
	Edges []*OrderEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// A summary of the important details for a dispute on an order.
type OrderDisputeSummary struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The type that the dispute was initiated as.
	InitiatedAs DisputeType `json:"initiatedAs"`
	// The current status of the dispute.
	Status DisputeStatus `json:"status"`
}

func (OrderDisputeSummary) IsNode() {}

type OrderEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of OrderEdge.
	Node *Order `json:"node"`
}

// Return type for `orderEditAddCustomItem` mutation.
type OrderEditAddCustomItemPayload struct {
	// The added line item.
	CalculatedLineItem *CalculatedLineItem `json:"calculatedLineItem"`
	// An order with the edits calculated.
	CalculatedOrder *CalculatedOrder `json:"calculatedOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `orderEditAddLineItemDiscount` mutation.
type OrderEditAddLineItemDiscountPayload struct {
	// The staged change produced by this mutation.
	AddedDiscountStagedChange *OrderStagedChangeAddLineItemDiscount `json:"addedDiscountStagedChange"`
	// The line item with the discount applied.
	CalculatedLineItem *CalculatedLineItem `json:"calculatedLineItem"`
	// An order with the edits calculated.
	CalculatedOrder *CalculatedOrder `json:"calculatedOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `orderEditAddVariant` mutation.
type OrderEditAddVariantPayload struct {
	// The added line item.
	CalculatedLineItem *CalculatedLineItem `json:"calculatedLineItem"`
	// An order with the edits calculated.
	CalculatedOrder *CalculatedOrder `json:"calculatedOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The input fields used to add a discount during an order edit.
type OrderEditAppliedDiscountInput struct {
	// The description of the discount.
	Description *string `json:"description,omitempty"`
	// The value of the discount as a fixed amount.
	FixedValue *MoneyInput `json:"fixedValue,omitempty"`
	// The value of the discount as a percentage.
	PercentValue *float64 `json:"percentValue,omitempty"`
}

// Return type for `orderEditBegin` mutation.
type OrderEditBeginPayload struct {
	// The order that will be edited.
	CalculatedOrder *CalculatedOrder `json:"calculatedOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `orderEditCommit` mutation.
type OrderEditCommitPayload struct {
	// The order with changes applied.
	Order *Order `json:"order"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `orderEditRemoveLineItemDiscount` mutation.
type OrderEditRemoveLineItemDiscountPayload struct {
	// The line item with the discount removed.
	CalculatedLineItem *CalculatedLineItem `json:"calculatedLineItem"`
	// An order with the edits calculated.
	CalculatedOrder *CalculatedOrder `json:"calculatedOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `orderEditSetQuantity` mutation.
type OrderEditSetQuantityPayload struct {
	// The line item with changes calculated.
	CalculatedLineItem *CalculatedLineItem `json:"calculatedLineItem"`
	// An order with the edits calculated.
	CalculatedOrder *CalculatedOrder `json:"calculatedOrder"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the information to be updated on the requested order.
type OrderInput struct {
	// The email address associated with the order.
	Email *string `json:"email,omitempty"`
	// The ID of the order to update.
	ID string `json:"id,omitempty"`
	// The order note.
	Note *string `json:"note,omitempty"`
	// A comma separated list of tags that have been added to the order.
	Tags []string `json:"tags,omitempty"`
	// The shipping address associated with the order.
	ShippingAddress *MailingAddressInput `json:"shippingAddress,omitempty"`
	// Custom information to add to the order, represented as a key value pair. Also referred to as note attributes.
	//
	CustomAttributes []*AttributeInput `json:"customAttributes,omitempty"`
	// The metafields to associate with this order.
	Metafields []*MetafieldInput `json:"metafields,omitempty"`
}

// Specifies the order to mark as paid.
type OrderMarkAsPaidInput struct {
	// The ID of the order to mark as paid.
	ID string `json:"id,omitempty"`
}

// Return type for `orderMarkAsPaid` mutation.
type OrderMarkAsPaidPayload struct {
	// The order marked as paid.
	Order *Order `json:"order"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies a closed order to open.
type OrderOpenInput struct {
	// The ID of the order to open.
	ID string `json:"id,omitempty"`
}

// Return type for `orderOpen` mutation.
type OrderOpenPayload struct {
	// The opened order.
	Order *Order `json:"order"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// The payment collection details for an order requiring additional payment.
type OrderPaymentCollectionDetails struct {
	// URL allowing additional payments to be collected on the order.
	AdditionalPaymentCollectionURL *string `json:"additionalPaymentCollectionUrl"`
}

// Represents a fraud check on an order.
type OrderRisk struct {
	// Whether the risk level is shown in the Shopify admin. If false, then this order risk is ignored when Shopify determines the overall risk level for the order.
	Display bool `json:"display"`
	// The likelihood that an order is fraudulent, based on this order risk.
	//
	// The level can be set by Shopify risk analysis or by an app.
	//
	Level *OrderRiskLevel `json:"level"`
	// The risk message that's shown to the merchant in the Shopify admin.
	Message *string `json:"message"`
}

// A newly created custom item.
//
type OrderStagedChangeAddCustomItem struct {
	// The price of an individual item without any discounts applied.
	OriginalUnitPrice *MoneyV2 `json:"originalUnitPrice"`
	// The number of items.
	Quantity int64 `json:"quantity"`
	// The title of the item.
	Title string `json:"title"`
}

func (OrderStagedChangeAddCustomItem) IsOrderStagedChange() {}

// A discount application added as part of an order edit.
//
type OrderStagedChangeAddLineItemDiscount struct {
	// The description of the discount.
	Description string `json:"description"`
	// A globally unique identifier.
	ID string `json:"id"`
	// The amount of the discount.
	Value PricingValue `json:"value"`
}

func (OrderStagedChangeAddLineItemDiscount) IsOrderStagedChange() {}

// A new shipping line added as part of an order edit.
//
type OrderStagedChangeAddShippingLine struct {
	// Shipping line phone number.
	Phone *string `json:"phone"`
	// The presentment title of the shipping line.
	PresentmentTitle *string `json:"presentmentTitle"`
	// Price of shipping line.
	Price *MoneyV2 `json:"price"`
	// The title of the shipping line.
	Title *string `json:"title"`
}

func (OrderStagedChangeAddShippingLine) IsOrderStagedChange() {}

// A new item created from an existing product variant.
//
type OrderStagedChangeAddVariant struct {
	// The number of items.
	Quantity int64 `json:"quantity"`
	// The product variant of the added item.
	Variant *ProductVariant `json:"variant"`
}

func (OrderStagedChangeAddVariant) IsOrderStagedChange() {}

type OrderStagedChangeConnection struct {
	// A list of edges.
	Edges []*OrderStagedChangeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// An removal of items from an existing line item on the order.
//
type OrderStagedChangeDecrementItem struct {
	// The number of items removed.
	Delta int64 `json:"delta"`
	// The original line item.
	LineItem *LineItem `json:"lineItem"`
	// The intention to restock the removed items.
	Restock bool `json:"restock"`
}

func (OrderStagedChangeDecrementItem) IsOrderStagedChange() {}

type OrderStagedChangeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of OrderStagedChangeEdge.
	Node OrderStagedChange `json:"node"`
}

// An addition of items to an existing line item on the order.
//
type OrderStagedChangeIncrementItem struct {
	// The number of items added.
	Delta int64 `json:"delta"`
	// The original line item.
	LineItem *LineItem `json:"lineItem"`
}

func (OrderStagedChangeIncrementItem) IsOrderStagedChange() {}

// A transaction represents an exchange of money as part of an order.
type OrderTransaction struct {
	// The masked account number associated with the payment method.
	AccountNumber *string `json:"accountNumber"`
	// The amount of money.
	Amount string `json:"amount"`
	// The amount and currency of the transaction in shop and presentment currencies.
	AmountSet *MoneyBag `json:"amountSet"`
	// The amount and currency of the transaction.
	AmountV2 *MoneyV2 `json:"amountV2"`
	// Authorization code associated with the transaction.
	AuthorizationCode *string `json:"authorizationCode"`
	// Date and time when the transaction was created.
	CreatedAt string `json:"createdAt"`
	// A standardized error code, independent of the payment provider.
	ErrorCode *OrderTransactionErrorCode `json:"errorCode"`
	// The human-readable payment gateway name used to process the transaction.
	FormattedGateway *string `json:"formattedGateway"`
	// The payment gateway used to process the transaction.
	Gateway *string `json:"gateway"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The kind of transaction.
	Kind OrderTransactionKind `json:"kind"`
	// Whether the transaction can be manually captured.
	ManuallyCapturable bool `json:"manuallyCapturable"`
	// Specifies the available amount to refund on the gateway. Only available within SuggestedRefund.
	MaximumRefundable *string `json:"maximumRefundable"`
	// Specifies the available amount with currency to refund on the gateway.
	// Only available within SuggestedRefund.
	//
	MaximumRefundableV2 *MoneyV2 `json:"maximumRefundableV2"`
	// The associated order.
	Order *Order `json:"order"`
	// The associated parent transaction, for example the authorization of a capture.
	ParentTransaction *OrderTransaction `json:"parentTransaction"`
	// Specifies the payment icon to display for this transaction.
	PaymentIcon *Image `json:"paymentIcon"`
	// Specifies the credit card company used to pay for this transaction.
	PaymentMethod *PaymentMethods `json:"paymentMethod"`
	// Date and time when the transaction was processed.
	ProcessedAt *string `json:"processedAt"`
	// A transaction receipt attached to the transaction by the gateway.
	// The value of this field depends on which gateway processed the transaction.
	//
	Receipt *string `json:"receipt"`
	// The status of this transaction.
	Status OrderTransactionStatus `json:"status"`
	// Whether the transaction is a test transaction.
	Test bool `json:"test"`
	// Specifies the available amount to capture on the gateway.
	// Only available when an amount is capturable or manually mark as paid.
	//
	TotalUnsettled *string `json:"totalUnsettled"`
	// Specifies the available amount with currency to capture on the gateway in shop and presentment currencies.
	// Only available when an amount is capturable or manually mark as paid.
	//
	TotalUnsettledSet *MoneyBag `json:"totalUnsettledSet"`
	// Specifies the available amount with currency to capture on the gateway.
	// Only available when an amount is capturable or manually mark as paid.
	//
	TotalUnsettledV2 *MoneyV2 `json:"totalUnsettledV2"`
}

func (OrderTransaction) IsNode() {}

type OrderTransactionConnection struct {
	// A list of edges.
	Edges []*OrderTransactionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type OrderTransactionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of OrderTransactionEdge.
	Node *OrderTransaction `json:"node"`
}

// Specifies the information needed to create an order transaction.
type OrderTransactionInput struct {
	// The amount of money for this transaction.
	Amount string `json:"amount,omitempty"`
	// The payment gateway to use for this transaction.
	Gateway string `json:"gateway,omitempty"`
	// The kind of transaction.
	Kind OrderTransactionKind `json:"kind,omitempty"`
	// The ID of the order associated with the transaction.
	OrderID string `json:"orderId,omitempty"`
	// The ID of the optional parent transaction, for example the authorization of a capture.
	ParentID *string `json:"parentId,omitempty"`
}

// Return type for `orderUpdate` mutation.
type OrderUpdatePayload struct {
	// The updated order.
	Order *Order `json:"order"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Information about pagination in a connection.
type PageInfo struct {
	// Indicates if there are more pages to fetch.
	HasNextPage bool `json:"hasNextPage"`
	// Indicates if there are any pages prior to the current page.
	HasPreviousPage bool `json:"hasPreviousPage"`
}

// Settings related to payments.
type PaymentSettings struct {
	// List of the digital wallets which the shop supports.
	SupportedDigitalWallets []DigitalWallet `json:"supportedDigitalWallets"`
}

// Price rules are a set of conditions, including entitlements and prerequisites, that must be met in order for a discount code to apply.
type PriceRule struct {
	// The maximum number of times that the price rule can be allocated onto an order.
	AllocationLimit *int64 `json:"allocationLimit"`
	// The method by which the price rule's value is allocated to its entitled items.
	AllocationMethod PriceRuleAllocationMethod `json:"allocationMethod"`
	// The application that created the price rule.
	App *App `json:"app"`
	// The date and time when the price rule was created.
	CreatedAt string `json:"createdAt"`
	// The customers that can use this price rule.
	CustomerSelection *PriceRuleCustomerSelection `json:"customerSelection"`
	// List of the price rule's discount codes.
	DiscountCodes *PriceRuleDiscountCodeConnection `json:"discountCodes"`
	// How many discount codes associated with the price rule.
	DiscountCodesCount int64 `json:"discountCodesCount"`
	// The date and time when the price rule ends. For open-ended price rules, use `null`.
	EndsAt *string `json:"endsAt"`
	// Quantity of prerequisite items required for the price rule to be applicable,  compared to quantity of entitled items.
	EntitlementToPrerequisiteQuantityRatio *PriceRuleEntitlementToPrerequisiteQuantityRatio `json:"entitlementToPrerequisiteQuantityRatio"`
	// The paginated list of events associated with the price rule.
	Events *EventConnection `json:"events"`
	// A list of the price rule's features.
	Features []PriceRuleFeature `json:"features"`
	// Indicates whether there are any timeline comments on the price rule.
	HasTimelineComment bool `json:"hasTimelineComment"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The items to which the price rule applies.
	ItemEntitlements *PriceRuleItemEntitlements `json:"itemEntitlements"`
	// The items required for the price rule to be applicable.
	ItemPrerequisites *PriceRuleLineItemPrerequisites `json:"itemPrerequisites"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// Whether the price rule can be applied only once per customer.
	OncePerCustomer bool `json:"oncePerCustomer"`
	// The number of the entitled items must fall within this range for the price rule to be applicable.
	PrerequisiteQuantityRange *PriceRuleQuantityRange `json:"prerequisiteQuantityRange"`
	// The shipping cost must fall within this range for the price rule to be applicable.
	PrerequisiteShippingPriceRange *PriceRuleMoneyRange `json:"prerequisiteShippingPriceRange"`
	// The sum of the entitled items subtotal prices must fall within this range for the price rule to be applicable.
	PrerequisiteSubtotalRange *PriceRuleMoneyRange `json:"prerequisiteSubtotalRange"`
	// Quantity of prerequisite items required for the price rule to be applicable,  compared to quantity of entitled items.
	PrerequisiteToEntitlementQuantityRatio *PriceRulePrerequisiteToEntitlementQuantityRatio `json:"prerequisiteToEntitlementQuantityRatio"`
	// URLs that can be used to share the discount.
	ShareableUrls []*PriceRuleShareableURL `json:"shareableUrls"`
	// The shipping lines to which the price rule applies.
	ShippingEntitlements *PriceRuleShippingLineEntitlements `json:"shippingEntitlements"`
	// The date and time when the price rule starts.
	StartsAt string `json:"startsAt"`
	// The status of the price rule.
	Status PriceRuleStatus `json:"status"`
	// A detailed summary of the price rule.
	Summary *string `json:"summary"`
	// The type of lines (line_item or shipping_line) to which the price rule applies.
	Target PriceRuleTarget `json:"target"`
	// The title of the price rule.
	Title string `json:"title"`
	// The total sales from orders where the price rule was used.
	TotalSales *MoneyV2 `json:"totalSales"`
	// A list of the price rule's features.
	Traits []PriceRuleTrait `json:"traits"`
	// The number of times that the price rule has been used. This value is updated asynchronously and can be different than the actual usage count.
	UsageCount int64 `json:"usageCount"`
	// The maximum number of times that the price rule can be used in total.
	UsageLimit *int64 `json:"usageLimit"`
	// A time period during which a price rule is applicable.
	ValidityPeriod *PriceRuleValidityPeriod `json:"validityPeriod"`
	// The value of the price rule.
	Value PriceRuleValue `json:"value"`
	// The value of the price rule.
	ValueV2 PricingValue `json:"valueV2"`
}

func (PriceRule) IsNode()                   {}
func (PriceRule) IsCommentEventSubject()    {}
func (PriceRule) IsLegacyInteroperability() {}
func (PriceRule) IsHasEvents()              {}

// Return type for `priceRuleActivate` mutation.
type PriceRuleActivatePayload struct {
	// The activated price rule.
	PriceRule *PriceRule `json:"priceRule"`
	// List of errors that occurred executing the mutation.
	PriceRuleUserErrors []*PriceRuleUserError `json:"priceRuleUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type PriceRuleConnection struct {
	// A list of edges.
	Edges []*PriceRuleEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `priceRuleCreate` mutation.
type PriceRuleCreatePayload struct {
	// The newly created price rule.
	PriceRule *PriceRule `json:"priceRule"`
	// The newly created discount code.
	PriceRuleDiscountCode *PriceRuleDiscountCode `json:"priceRuleDiscountCode"`
	// List of errors that occurred executing the mutation.
	PriceRuleUserErrors []*PriceRuleUserError `json:"priceRuleUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// A selection of customers for whom the price rule applies.
type PriceRuleCustomerSelection struct {
	// List of customers to whom the price rule applies.
	Customers *CustomerConnection `json:"customers"`
	// Whether the price rule applies to all customers.
	ForAllCustomers bool `json:"forAllCustomers"`
	// A list of customer saved searches that contain the customers who can use the price rule.
	SavedSearches []*SavedSearch `json:"savedSearches"`
}

// Specifies the input fields to update a price rule customer selection.
type PriceRuleCustomerSelectionInput struct {
	// Whether the price rule applies to all customers.
	ForAllCustomers *bool `json:"forAllCustomers,omitempty"`
	// List of customer saved searches that contain the customers to whom the price rule applies. No single customer IDs may be present.
	SavedSearchIds []string `json:"savedSearchIds,omitempty"`
	// List of customers to add to the current list of customers to whom the price rule applies. `savedSearchIds` must be empty.
	CustomerIdsToAdd []string `json:"customerIdsToAdd,omitempty"`
	// A list of customers to remove from the current list of customers to whom the price rule applies.
	CustomerIdsToRemove []string `json:"customerIdsToRemove,omitempty"`
}

// Return type for `priceRuleDeactivate` mutation.
type PriceRuleDeactivatePayload struct {
	// The deactivated price rule.
	PriceRule *PriceRule `json:"priceRule"`
	// List of errors that occurred executing the mutation.
	PriceRuleUserErrors []*PriceRuleUserError `json:"priceRuleUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `priceRuleDelete` mutation.
type PriceRuleDeletePayload struct {
	// The id price of the deleted price rule.
	DeletedPriceRuleID *string `json:"deletedPriceRuleId"`
	// List of errors that occurred executing the mutation.
	PriceRuleUserErrors []*PriceRuleUserError `json:"priceRuleUserErrors"`
	// The shop of the deleted price rule.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// A discount code of a price rule.
type PriceRuleDiscountCode struct {
	// The application that created the discount code.
	App *App `json:"app"`
	// The code to use the discount.
	Code string `json:"code"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The number of times that the price rule has been used. This value is updated asynchronously and can be different than the actual usage count.
	UsageCount int64 `json:"usageCount"`
}

func (PriceRuleDiscountCode) IsNode() {}

type PriceRuleDiscountCodeConnection struct {
	// A list of edges.
	Edges []*PriceRuleDiscountCodeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `priceRuleDiscountCodeCreate` mutation.
type PriceRuleDiscountCodeCreatePayload struct {
	// The updated price rule.
	PriceRule *PriceRule `json:"priceRule"`
	// The newly created discount code.
	PriceRuleDiscountCode *PriceRuleDiscountCode `json:"priceRuleDiscountCode"`
	// List of errors that occurred executing the mutation.
	PriceRuleUserErrors []*PriceRuleUserError `json:"priceRuleUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type PriceRuleDiscountCodeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of PriceRuleDiscountCodeEdge.
	Node *PriceRuleDiscountCode `json:"node"`
}

// Specifies the input fields to manipulate a discount code.
type PriceRuleDiscountCodeInput struct {
	// The code to use the discount.
	Code *string `json:"code,omitempty"`
}

// Return type for `priceRuleDiscountCodeUpdate` mutation.
type PriceRuleDiscountCodeUpdatePayload struct {
	// The updated price rule.
	PriceRule *PriceRule `json:"priceRule"`
	// The updated discount code.
	PriceRuleDiscountCode *PriceRuleDiscountCode `json:"priceRuleDiscountCode"`
	// List of errors that occurred executing the mutation.
	PriceRuleUserErrors []*PriceRuleUserError `json:"priceRuleUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type PriceRuleEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of PriceRuleEdge.
	Node *PriceRule `json:"node"`
}

// Quantity of prerequisite items required for the price rule to be applicable, compared to quantity of entitled items.
type PriceRuleEntitlementToPrerequisiteQuantityRatio struct {
	// The quantity of entitlements in the ratio.
	EntitlementQuantity int64 `json:"entitlementQuantity"`
	// The quantity of prerequisites in the ratio.
	PrerequisiteQuantity int64 `json:"prerequisiteQuantity"`
}

// Specifies the quantity of prerequisite items required for the price rule to be applicable, compared to quantity of entitled items.
type PriceRuleEntitlementToPrerequisiteQuantityRatioInput struct {
	// The quantity of entitlements in the ratio.
	EntitlementQuantity *int64 `json:"entitlementQuantity,omitempty"`
	// The quantity of prerequisites in the ratio.
	PrerequisiteQuantity *int64 `json:"prerequisiteQuantity,omitempty"`
}

// The value of a fixed amount price rule.
type PriceRuleFixedAmountValue struct {
	// The monetary value of the price rule.
	Amount string `json:"amount"`
}

func (PriceRuleFixedAmountValue) IsPriceRuleValue() {}

// Specifies the input fields to manipulate a price rule.
type PriceRuleInput struct {
	// PriceRuleValidityPeriod for the price rule.
	ValidityPeriod *PriceRuleValidityPeriodInput `json:"validityPeriod,omitempty"`
	// Whether the price rule can be applied only once per customer.
	OncePerCustomer *bool `json:"oncePerCustomer,omitempty"`
	// The customers that can use this price rule.
	CustomerSelection *PriceRuleCustomerSelectionInput `json:"customerSelection,omitempty"`
	// The maximum number of times that the price rule can be used in total.
	UsageLimit *int64 `json:"usageLimit,omitempty"`
	// Title of the price rule.
	Title *string `json:"title,omitempty"`
	// The maximum number of times that the price rule can be allocated onto an order.
	AllocationLimit *int64 `json:"allocationLimit,omitempty"`
	// The method by which the price rule's value is allocated to its entitled items.
	AllocationMethod *PriceRuleAllocationMethod `json:"allocationMethod,omitempty"`
	// The value of the price rule.
	Value *PriceRuleValueInput `json:"value,omitempty"`
	// The type of lines (line_item or shipping_line) to which the price rule applies.
	Target *PriceRuleTarget `json:"target,omitempty"`
	// The sum of the entitled items subtotal prices must fall within this range for the price rule to be applicable.
	PrerequisiteSubtotalRange *PriceRuleMoneyRangeInput `json:"prerequisiteSubtotalRange,omitempty"`
	// The number of the entitled items must fall within this range for the price rule to be applicable.
	PrerequisiteQuantityRange *PriceRuleQuantityRangeInput `json:"prerequisiteQuantityRange,omitempty"`
	// The shipping cost must fall within this range for the price rule to be applicable.
	PrerequisiteShippingPriceRange *PriceRuleMoneyRangeInput `json:"prerequisiteShippingPriceRange,omitempty"`
	// The items to which the price rule applies.
	ItemEntitlements *PriceRuleItemEntitlementsInput `json:"itemEntitlements,omitempty"`
	// The items required for the price rule to be applicable.
	ItemPrerequisites *PriceRuleItemPrerequisitesInput `json:"itemPrerequisites,omitempty"`
	// The shipping lines to which the price rule applies.
	ShippingEntitlements *PriceRuleShippingEntitlementsInput `json:"shippingEntitlements,omitempty"`
	// Quantity of prerequisite items required for the price rule to be applicable, compared to quantity of entitled items. This argument is deprecated: Use `prerequisiteToEntitlementQuantityRatio` instead.
	EntitlementToPrerequisiteQuantityRatio *PriceRuleEntitlementToPrerequisiteQuantityRatioInput `json:"entitlementToPrerequisiteQuantityRatio,omitempty"`
	// Quantity of prerequisite items required for the price rule to be applicable, compared to quantity of entitled items.
	PrerequisiteToEntitlementQuantityRatio *PriceRulePrerequisiteToEntitlementQuantityRatioInput `json:"prerequisiteToEntitlementQuantityRatio,omitempty"`
}

// The items to which this price rule applies. This may be multiple products, product variants, collections or combinations of the aforementioned.
type PriceRuleItemEntitlements struct {
	// The collections to which the price rule applies.
	Collections *CollectionConnection `json:"collections"`
	// The product variants to which the price rule applies.
	ProductVariants *ProductVariantConnection `json:"productVariants"`
	// The products to which the price rule applies.
	Products *ProductConnection `json:"products"`
	// Whether the price rule applies to all line items.
	TargetAllLineItems bool `json:"targetAllLineItems"`
}

// Specifies the input fields to update a price rule line item entitlement.
type PriceRuleItemEntitlementsInput struct {
	// Whether the price rule applies to all items.
	TargetAllLineItems *bool `json:"targetAllLineItems,omitempty"`
	// The products to which the price rule applies.
	ProductIds []string `json:"productIds,omitempty"`
	// The product variants to which the price rule applies.
	ProductVariantIds []string `json:"productVariantIds,omitempty"`
	// The collections to which the price rule applies.
	CollectionIds []string `json:"collectionIds,omitempty"`
}

// Specifies the input fields to update a price rule's item prerequisites.
type PriceRuleItemPrerequisitesInput struct {
	// The products needed for the price rule to be applied.
	ProductIds []string `json:"productIds,omitempty"`
	// The product variants needed for the price rule to be applied.
	ProductVariantIds []string `json:"productVariantIds,omitempty"`
	// The collections needed for the price rule to be applied.
	CollectionIds []string `json:"collectionIds,omitempty"`
}

// Single or multiple line item products, product variants or collections required for the price rule to be applicable, can also be provided in combination.
type PriceRuleLineItemPrerequisites struct {
	// The collections required for the price rule to be applicable.
	Collections *CollectionConnection `json:"collections"`
	// The product variants required for the price rule to be applicable.
	ProductVariants *ProductVariantConnection `json:"productVariants"`
	// The products required for the price rule to be applicable.
	Products *ProductConnection `json:"products"`
}

// A money range within which the price rule is applicable.
type PriceRuleMoneyRange struct {
	// The lower bound of the money range.
	GreaterThan *string `json:"greaterThan"`
	// The lower bound or equal of the money range.
	GreaterThanOrEqualTo *string `json:"greaterThanOrEqualTo"`
	// The upper bound of the money range.
	LessThan *string `json:"lessThan"`
	// The upper bound or equal of the money range.
	LessThanOrEqualTo *string `json:"lessThanOrEqualTo"`
}

// Specifies the input fields to update the money range within which the price rule is applicable.
//
type PriceRuleMoneyRangeInput struct {
	// The upper bound of the money range.
	LessThan *string `json:"lessThan,omitempty"`
	// The upper or equal bound of the money range.
	LessThanOrEqualTo *string `json:"lessThanOrEqualTo,omitempty"`
	// The lower bound of the money range.
	GreaterThan *string `json:"greaterThan,omitempty"`
	// The lower or equal bound of the money range.
	GreaterThanOrEqualTo *string `json:"greaterThanOrEqualTo,omitempty"`
}

// The value of a percent price rule.
type PriceRulePercentValue struct {
	// The percent value of the price rule.
	Percentage float64 `json:"percentage"`
}

func (PriceRulePercentValue) IsPriceRuleValue() {}

// Quantity of prerequisite items required for the price rule to be applicable, compared to quantity of entitled items.
type PriceRulePrerequisiteToEntitlementQuantityRatio struct {
	// The quantity of entitlements in the ratio.
	EntitlementQuantity int64 `json:"entitlementQuantity"`
	// The quantity of prerequisites in the ratio.
	PrerequisiteQuantity int64 `json:"prerequisiteQuantity"`
}

// Specifies the quantity of prerequisite items required for the price rule to be applicable, compared to quantity of entitled items.
type PriceRulePrerequisiteToEntitlementQuantityRatioInput struct {
	// The quantity of entitlements in the ratio.
	EntitlementQuantity *int64 `json:"entitlementQuantity,omitempty"`
	// The quantity of prerequisites in the ratio.
	PrerequisiteQuantity *int64 `json:"prerequisiteQuantity,omitempty"`
}

// A quantity range within which the price rule is applicable.
type PriceRuleQuantityRange struct {
	// The lower bound of the quantity range.
	GreaterThan *int64 `json:"greaterThan"`
	// The lower bound or equal of the quantity range.
	GreaterThanOrEqualTo *int64 `json:"greaterThanOrEqualTo"`
	// The upper bound of the quantity range.
	LessThan *int64 `json:"lessThan"`
	// The upper bound or equal of the quantity range.
	LessThanOrEqualTo *int64 `json:"lessThanOrEqualTo"`
}

// Specifies the input fields to update the quantity range within which the price rule is applicable.
//
type PriceRuleQuantityRangeInput struct {
	// The upper bound of the quantity range.
	LessThan *int64 `json:"lessThan,omitempty"`
	// The upper or equal bound of the quantity range.
	LessThanOrEqualTo *int64 `json:"lessThanOrEqualTo,omitempty"`
	// The lower bound of the quantity range.
	GreaterThan *int64 `json:"greaterThan,omitempty"`
	// The lower or equal bound of the quantity range.
	GreaterThanOrEqualTo *int64 `json:"greaterThanOrEqualTo,omitempty"`
}

// Shareable URL for the discount code associated with the price rule.
type PriceRuleShareableURL struct {
	// The image URL of the item (product or collection) to which the discount applies.
	TargetItemImage *Image `json:"targetItemImage"`
	// The type of page that's associated with the URL.
	TargetType PriceRuleShareableURLTargetType `json:"targetType"`
	// The title of the page that's associated with the URL.
	Title string `json:"title"`
	// The URL for the discount code.
	URL string `json:"url"`
}

// Specifies the input fields to update a price rule shipping entitlement.
type PriceRuleShippingEntitlementsInput struct {
	// Whether the price rule applies to all shipping lines.
	TargetAllShippingLines *bool `json:"targetAllShippingLines,omitempty"`
	// The codes for the countries to which the price rule applies to.
	CountryCodes []CountryCode `json:"countryCodes,omitempty"`
	// Whether the price rule is applicable to countries that have not been defined in the shop's shipping zones.
	IncludeRestOfWorld *bool `json:"includeRestOfWorld,omitempty"`
}

// The shipping lines to which the price rule applies to.
type PriceRuleShippingLineEntitlements struct {
	// The codes for the countries to which the price rule applies to.
	CountryCodes []CountryCode `json:"countryCodes"`
	// Whether the price rule is applicable to countries that have not been defined in the shop's shipping zones.
	IncludeRestOfWorld bool `json:"includeRestOfWorld"`
	// Whether the price rule applies to all shipping lines.
	TargetAllShippingLines bool `json:"targetAllShippingLines"`
}

// Return type for `priceRuleUpdate` mutation.
type PriceRuleUpdatePayload struct {
	// The updated price rule.
	PriceRule *PriceRule `json:"priceRule"`
	// The updated discount code.
	PriceRuleDiscountCode *PriceRuleDiscountCode `json:"priceRuleDiscountCode"`
	// List of errors that occurred executing the mutation.
	PriceRuleUserErrors []*PriceRuleUserError `json:"priceRuleUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents an error that happens during execution of a price rule mutation.
type PriceRuleUserError struct {
	// Error code to uniquely identify the error.
	Code *PriceRuleErrorCode `json:"code"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (PriceRuleUserError) IsDisplayableError() {}

// A time period during which a price rule is applicable.
type PriceRuleValidityPeriod struct {
	// The time after which the price rule becomes invalid.
	End *string `json:"end"`
	// The time after which the price rule is valid.
	Start string `json:"start"`
}

// Specifies the input fields to update the validity period of a price rule.
type PriceRuleValidityPeriodInput struct {
	// The time after which the price rule is valid.
	Start string `json:"start,omitempty"`
	// The time after which the price rule becomes invalid.
	End *string `json:"end,omitempty"`
}

// Specifies the input fields to update a price rule.
type PriceRuleValueInput struct {
	// The percentage value of the price rule.
	PercentageValue *float64 `json:"percentageValue,omitempty"`
	// The fixed amount value of the price rule.
	FixedAmountValue *string `json:"fixedAmountValue,omitempty"`
}

// The value of the percentage pricing object.
type PricingPercentageValue struct {
	// The percentage value of the object.
	Percentage float64 `json:"percentage"`
}

func (PricingPercentageValue) IsPricingValue() {}

// Private metafields represent custom metadata that is attached to a resource.
// Private metafields are private to the application that creates them on a shop's resources.
//
type PrivateMetafield struct {
	// The date and time when the private metafield was created.
	CreatedAt string `json:"createdAt"`
	// The id of the private metafield.
	ID string `json:"id"`
	// The key name for a private metafield.
	Key string `json:"key"`
	// The namespace for a private metafield.
	Namespace string `json:"namespace"`
	// The date and time when the private metafield was updated.
	UpdatedAt string `json:"updatedAt"`
	// The value of a private metafield.
	Value string `json:"value"`
	// Represents the private metafield value type.
	ValueType PrivateMetafieldValueType `json:"valueType"`
}

func (PrivateMetafield) IsNode() {}

type PrivateMetafieldConnection struct {
	// A list of edges.
	Edges []*PrivateMetafieldEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Specifies the input fields for a PrivateMetafield.
//
type PrivateMetafieldDeleteInput struct {
	// The ID of the owning resource.
	Owner *string `json:"owner,omitempty"`
	// The namespace for the private metafield.
	Namespace string `json:"namespace,omitempty"`
	// The key for the private metafield.
	Key string `json:"key,omitempty"`
}

// Return type for `privateMetafieldDelete` mutation.
type PrivateMetafieldDeletePayload struct {
	// The ID of private metafield that was deleted.
	DeletedPrivateMetafieldID *string `json:"deletedPrivateMetafieldId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type PrivateMetafieldEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of PrivateMetafieldEdge.
	Node *PrivateMetafield `json:"node"`
}

// Specifies the input fields for a PrivateMetafield.
//
type PrivateMetafieldInput struct {
	// The owning resource.
	Owner *string `json:"owner,omitempty"`
	// The namespace for the private metafield.
	Namespace string `json:"namespace,omitempty"`
	// The key for the private metafield.
	Key string `json:"key,omitempty"`
	// The value and value type of the metafield, wrapped in a ValueInput object.
	ValueInput *PrivateMetafieldValueInput `json:"valueInput,omitempty"`
}

// Return type for `privateMetafieldUpsert` mutation.
type PrivateMetafieldUpsertPayload struct {
	// The private metafield that was created or updated.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Value Input wraps two fields of Private Metafields into one. Those fields are value and value_type.
//
type PrivateMetafieldValueInput struct {
	// The value of a private metafield.
	Value string `json:"value,omitempty"`
	// Represents the private metafield value type.
	ValueType PrivateMetafieldValueType `json:"valueType,omitempty"`
}

// Represents a product, including information about related collections and product variants.
type Product struct {
	// The number of publications a resource is published to without feedback errors.
	AvailablePublicationCount int64 `json:"availablePublicationCount"`
	// The description of the product, complete with HTML formatting.
	BodyHTML *string `json:"bodyHtml"`
	// A list of the collections that include the product.
	Collections *CollectionConnection `json:"collections"`
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) when the product was created.
	//
	CreatedAt string `json:"createdAt"`
	// A default cursor for use in pagination.
	DefaultCursor string `json:"defaultCursor"`
	// A stripped description of the product, single line with HTML tags removed.
	Description string `json:"description"`
	// The description of the product, complete with HTML formatting.
	DescriptionHTML string `json:"descriptionHtml"`
	// Stripped description of the product, single line with HTML tags removed.
	// Truncated to 60 characters.
	//
	DescriptionPlainSummary string `json:"descriptionPlainSummary"`
	// The featured image for the product.
	FeaturedImage *Image `json:"featuredImage"`
	// The featured media for the product.
	FeaturedMedia Media `json:"featuredMedia"`
	// Information about the product that's provided through resource feedback.
	Feedback *ResourceFeedback `json:"feedback"`
	// The theme template used when viewing the gift card in a store.
	GiftCardTemplateSuffix *string `json:"giftCardTemplateSuffix"`
	// A unique human-friendly string of the product's title.
	Handle string `json:"handle"`
	// Whether the product has only a single variant with the default option and value.
	HasOnlyDefaultVariant bool `json:"hasOnlyDefaultVariant"`
	// Whether the product has out of stock variants.
	HasOutOfStockVariants bool `json:"hasOutOfStockVariants"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The images associated with the product.
	Images *ImageConnection `json:"images"`
	// Whether the product is in a given collection.
	InCollection bool `json:"inCollection"`
	// Whether the product is a gift card.
	IsGiftCard bool `json:"isGiftCard"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The media associated with the product.
	Media *MediaConnection `json:"media"`
	// Total count of media belonging to a product.
	MediaCount int64 `json:"mediaCount"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// The online store preview URL.
	OnlineStorePreviewURL *string `json:"onlineStorePreviewUrl"`
	// The online store URL for the product.
	// A value of `null` indicates that the product is not published to the Online Store sales channel.
	//
	OnlineStoreURL *string `json:"onlineStoreUrl"`
	// A list of custom product options (maximum of 3 per product).
	Options []*ProductOption `json:"options"`
	// The price range of the product.
	PriceRange *ProductPriceRange `json:"priceRange"`
	// The price range of the product with prices formatted as decimals.
	PriceRangeV2 *ProductPriceRangeV2 `json:"priceRangeV2"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// A list of the channels where the product is published.
	ProductPublications *ProductPublicationConnection `json:"productPublications"`
	// The product type specified by the merchant.
	ProductType string `json:"productType"`
	// The number of publications a resource is published on.
	PublicationCount int64 `json:"publicationCount"`
	// A list of the channels where the product is published.
	Publications *ProductPublicationConnection `json:"publications"`
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) when the product was published to the Online Store.
	//
	PublishedAt *string `json:"publishedAt"`
	// Check to see whether the resource is published to a given channel.
	PublishedOnChannel bool `json:"publishedOnChannel"`
	// Check to see whether the resource is published to the calling app's channel.
	PublishedOnCurrentChannel bool `json:"publishedOnCurrentChannel"`
	// Check to see whether the resource is published to the calling app's publication.
	PublishedOnCurrentPublication bool `json:"publishedOnCurrentPublication"`
	// Check to see whether the resource is published to a given publication.
	PublishedOnPublication bool `json:"publishedOnPublication"`
	// The list of resources that are published to a publication.
	ResourcePublications *ResourcePublicationConnection `json:"resourcePublications"`
	// The list of resources that are either published or staged to be published to a publication.
	ResourcePublicationsV2 *ResourcePublicationV2Connection `json:"resourcePublicationsV2"`
	// SEO information of the product.
	Seo *Seo `json:"seo"`
	// The product status. Product statuses aren't currently available to stores on the Shopify Plus plan.
	Status ProductStatus `json:"status"`
	// The storefront ID of the product.
	StorefrontID string `json:"storefrontId"`
	// A comma separated list of tags that have been added to the product.
	Tags []string `json:"tags"`
	// The theme template used when viewing the product in a store.
	TemplateSuffix *string `json:"templateSuffix"`
	// The title of the product.
	Title string `json:"title"`
	// The quantity of inventory in stock.
	TotalInventory int64 `json:"totalInventory"`
	// The number of variants that are associated with the product.
	TotalVariants int64 `json:"totalVariants"`
	// Whether inventory tracking has been enabled for the product.
	TracksInventory bool `json:"tracksInventory"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
	// The list of channels that the resource is not published to.
	UnpublishedChannels *ChannelConnection `json:"unpublishedChannels"`
	// The list of publications that the resource is not published to.
	UnpublishedPublications *PublicationConnection `json:"unpublishedPublications"`
	// The date and time ([ISO 8601 format](http://en.wikipedia.org/wiki/ISO_8601)) when the product was last modified.
	//
	UpdatedAt string `json:"updatedAt"`
	// A list of variants associated with the product.
	Variants *ProductVariantConnection `json:"variants"`
	// The name of the product's vendor.
	Vendor string `json:"vendor"`
}

func (Product) IsNode()                     {}
func (Product) IsNavigable()                {}
func (Product) IsHasMetafields()            {}
func (Product) IsHasPublishedTranslations() {}
func (Product) IsPublishable()              {}
func (Product) IsOnlineStorePreviewable()   {}
func (Product) IsLegacyInteroperability()   {}
func (Product) IsCommentEventEmbed()        {}

// Specifies product images to append.
type ProductAppendImagesInput struct {
	// The ID of the product.
	ID string `json:"id,omitempty"`
	// The images to be appended to the product.
	Images []*ImageInput `json:"images,omitempty"`
}

// Return type for `productAppendImages` mutation.
type ProductAppendImagesPayload struct {
	// List of new images appended to the product.
	NewImages []*Image `json:"newImages"`
	// The product object.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productChangeStatus` mutation.
type ProductChangeStatusPayload struct {
	// The product object.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*ProductChangeStatusUserError `json:"userErrors"`
}

// An error that occurs during the execution of ProductChangeStatus.
type ProductChangeStatusUserError struct {
	// Error code to uniquely identify the error.
	Code *ProductChangeStatusUserErrorCode `json:"code"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (ProductChangeStatusUserError) IsDisplayableError() {}

type ProductConnection struct {
	// A list of edges.
	Edges []*ProductEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `productCreateMedia` mutation.
type ProductCreateMediaPayload struct {
	// The newly created media.
	Media []Media `json:"media"`
	// List of errors that occurred executing the mutation.
	MediaUserErrors []*MediaUserError `json:"mediaUserErrors"`
	// The product associated with the media.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productCreate` mutation.
type ProductCreatePayload struct {
	// The product object.
	Product *Product `json:"product"`
	// The shop associated with the product.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productDeleteImages` mutation.
type ProductDeleteImagesPayload struct {
	// This is an array of IDs of images to delete.
	DeletedImageIds []string `json:"deletedImageIds"`
	// This is the product object.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the product to delete.
type ProductDeleteInput struct {
	// The ID of the product.
	ID string `json:"id,omitempty"`
}

// Return type for `productDeleteMedia` mutation.
type ProductDeleteMediaPayload struct {
	// List of media IDs which were deleted.
	DeletedMediaIds []string `json:"deletedMediaIds"`
	// List of product image IDs which were deleted.
	DeletedProductImageIds []string `json:"deletedProductImageIds"`
	// List of errors that occurred executing the mutation.
	MediaUserErrors []*MediaUserError `json:"mediaUserErrors"`
	// The product which media was deleted from.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productDelete` mutation.
type ProductDeletePayload struct {
	// The ID of the deleted product.
	DeletedProductID *string `json:"deletedProductId"`
	// The shop associated with the product.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productDuplicate` mutation.
type ProductDuplicatePayload struct {
	// The asynchronous job duplicating the product images.
	ImageJob *Job `json:"imageJob"`
	// The duplicated product.
	NewProduct *Product `json:"newProduct"`
	// The user's shop.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type ProductEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductEdge.
	Node *Product `json:"node"`
}

// Return type for `productImageUpdate` mutation.
type ProductImageUpdatePayload struct {
	// Image updated.
	Image *Image `json:"image"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the input fields required to create a product.
type ProductInput struct {
	// The description of the product, complete with HTML formatting.
	DescriptionHTML *string `json:"descriptionHtml,omitempty"`
	// A unique human-friendly string for the product. Automatically generated from the product's title.
	//
	Handle *string `json:"handle,omitempty"`
	// Whether a redirect is required after a new handle has been provided.
	// If true, then the old handle is redirected to the new one automatically.
	//
	RedirectNewHandle *bool `json:"redirectNewHandle,omitempty"`
	// The SEO information associated with the product.
	Seo *SEOInput `json:"seo,omitempty"`
	// The product type specified by the merchant.
	ProductType *string `json:"productType,omitempty"`
	// A comma separated list tags that have been added to the product.
	Tags []string `json:"tags,omitempty"`
	// The theme template used when viewing the product in a store.
	TemplateSuffix *string `json:"templateSuffix,omitempty"`
	// Whether the product is a gift card.
	GiftCard *bool `json:"giftCard,omitempty"`
	// The theme template used when viewing the gift card in a store.
	GiftCardTemplateSuffix *string `json:"giftCardTemplateSuffix,omitempty"`
	// The title of the product.
	Title *string `json:"title,omitempty"`
	// The name of the product's vendor.
	Vendor *string `json:"vendor,omitempty"`
	// A description of the product. Supports HTML formatting. This argument is deprecated: Use `descriptionHtml` instead.
	BodyHTML *string `json:"bodyHtml,omitempty"`
	// The IDs of the collections that this product will be added to.
	CollectionsToJoin []string `json:"collectionsToJoin,omitempty"`
	// The IDs of collections that will no longer include the product.
	CollectionsToLeave []string `json:"collectionsToLeave,omitempty"`
	// Specifies the product to update in productUpdate or creates a new product if absent in productCreate.
	ID *string `json:"id,omitempty"`
	// The images to associate with the product.
	Images []*ImageInput `json:"images,omitempty"`
	// The metafields to associate with this product.
	Metafields []*MetafieldInput `json:"metafields,omitempty"`
	// The private metafields to associated with this product.
	PrivateMetafields []*PrivateMetafieldInput `json:"privateMetafields,omitempty"`
	// List of custom product options (maximum of 3 per product).
	Options []string `json:"options,omitempty"`
	// A list of the channels where the product is published. This argument is deprecated: Use `PublishablePublish` instead.
	ProductPublications []*ProductPublicationInput `json:"productPublications,omitempty"`
	// A list of the channels where the product is published. This argument is deprecated: Use `PublishablePublish` instead.
	Publications []*ProductPublicationInput `json:"publications,omitempty"`
	// Only products with an active status can be published. This argument is deprecated: Use `PublishablePublish` instead.
	PublishDate *string `json:"publishDate,omitempty"`
	// Only products with an active status can be published. This argument is deprecated: Use `PublishablePublish` instead.
	PublishOn *string `json:"publishOn,omitempty"`
	// Only products with an active status can be published. This argument is deprecated: Use `PublishablePublish` instead.
	Published *bool `json:"published,omitempty"`
	// Only products with an active status can be published. This argument is deprecated: Use `PublishablePublish` instead.
	PublishedAt *string `json:"publishedAt,omitempty"`
	// A list of variants associated with the product.
	Variants []*ProductVariantInput `json:"variants,omitempty"`
	// The status of the product.
	Status *ProductStatus `json:"status,omitempty"`
}

// Custom product property names like "Size", "Color", and "Material".
// Products are based on permutations of these options.
// A product may have a maximum of 3 options.
// 255 characters limit each.
//
type ProductOption struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The product option’s name.
	Name string `json:"name"`
	// The product option's position.
	Position int64 `json:"position"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
	// The corresponding value to the product option name.
	Values []string `json:"values"`
}

func (ProductOption) IsNode()                     {}
func (ProductOption) IsHasPublishedTranslations() {}

// The price range of the product.
type ProductPriceRange struct {
	// The highest variant's price.
	MaxVariantPrice *MoneyV2 `json:"maxVariantPrice"`
	// The lowest variant's price.
	MinVariantPrice *MoneyV2 `json:"minVariantPrice"`
}

// The price range of the product.
type ProductPriceRangeV2 struct {
	// The highest variant's price.
	MaxVariantPrice *MoneyV2 `json:"maxVariantPrice"`
	// The lowest variant's price.
	MinVariantPrice *MoneyV2 `json:"minVariantPrice"`
}

// Represents the channels where a product is published.
type ProductPublication struct {
	// The channel where the product was or is published.
	Channel *Channel `json:"channel"`
	// Whether the publication is published or not.
	IsPublished bool `json:"isPublished"`
	// The product that was or is going to be published on the channel.
	Product *Product `json:"product"`
	// The date that the product was or is going to be published on the channel.
	PublishDate *string `json:"publishDate"`
}

type ProductPublicationConnection struct {
	// A list of edges.
	Edges []*ProductPublicationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ProductPublicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductPublicationEdge.
	Node *ProductPublication `json:"node"`
}

// Specifies a publication to which a product will be published.
type ProductPublicationInput struct {
	// ID of the publication.
	PublicationID *string `json:"publicationId,omitempty"`
	// ID of the channel. This argument is deprecated: Use publicationId instead.
	ChannelID *string `json:"channelId,omitempty"`
	// This argument is deprecated: Use publicationId instead.
	ChannelHandle *string `json:"channelHandle,omitempty"`
	// The date and time that the product was (or will be) published.
	PublishDate *string `json:"publishDate,omitempty"`
}

// Specifies a product to publish and the channels to publish it to.
type ProductPublishInput struct {
	// The product to create or update publications for.
	ID string `json:"id,omitempty"`
	// The publication that the product is published to.
	ProductPublications []*ProductPublicationInput `json:"productPublications,omitempty"`
}

// Return type for `productPublish` mutation.
type ProductPublishPayload struct {
	// The product that has been published.
	Product *Product `json:"product"`
	// The channels where the product is published.
	ProductPublications []*ProductPublication `json:"productPublications"`
	// The user's shop.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productReorderImages` mutation.
type ProductReorderImagesPayload struct {
	// The asynchronous job reordering the images.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productReorderMedia` mutation.
type ProductReorderMediaPayload struct {
	// The asynchronous job reordering the media.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	MediaUserErrors []*MediaUserError `json:"mediaUserErrors"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies a product to unpublish from a channel and the sales channels to unpublish it from.
type ProductUnpublishInput struct {
	// The ID of the product to create or update publications for.
	ID string `json:"id,omitempty"`
	// The channels to unpublish the product from.
	ProductPublications []*ProductPublicationInput `json:"productPublications,omitempty"`
}

// Return type for `productUnpublish` mutation.
type ProductUnpublishPayload struct {
	// The product that has been unpublished.
	Product *Product `json:"product"`
	// The user's shop.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productUpdateMedia` mutation.
type ProductUpdateMediaPayload struct {
	// The updated media.
	Media []Media `json:"media"`
	// List of errors that occurred executing the mutation.
	MediaUserErrors []*MediaUserError `json:"mediaUserErrors"`
	// The product which media was updated on.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productUpdate` mutation.
type ProductUpdatePayload struct {
	// The updated product.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents a product variant.
type ProductVariant struct {
	// Whether the product variant is available for sale.
	AvailableForSale bool `json:"availableForSale"`
	// The value of the barcode associated with the product.
	Barcode *string `json:"barcode"`
	// The compare-at price of the variant in the default shop currency.
	CompareAtPrice *string `json:"compareAtPrice"`
	// The date and time when the variant was created.
	CreatedAt string `json:"createdAt"`
	// A default cursor for use in pagination.
	DefaultCursor string `json:"defaultCursor"`
	// The delivery profile for the variant.
	DeliveryProfile *DeliveryProfile `json:"deliveryProfile"`
	// Display name of the variant, based on product's title + variant's title.
	DisplayName string `json:"displayName"`
	// The fulfillment service associated with the product.
	FulfillmentService *FulfillmentService `json:"fulfillmentService"`
	// Whether changes to the fulfillment service for the product variant are allowed.
	FulfillmentServiceEditable *EditableProperty `json:"fulfillmentServiceEditable"`
	// The Harmonized System Code (or HS Tariff Code) for the variant.
	HarmonizedSystemCode *string `json:"harmonizedSystemCode"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The featured image for the variant.
	Image *Image `json:"image"`
	// The inventory item, which is used to query for inventory information.
	InventoryItem *InventoryItem `json:"inventoryItem"`
	// The fulfillment service that tracks the number of items in stock for the product variant.
	InventoryManagement ProductVariantInventoryManagement `json:"inventoryManagement"`
	// Whether customers are allowed to place an order for the product variant when it's out of stock.
	InventoryPolicy ProductVariantInventoryPolicy `json:"inventoryPolicy"`
	// The total sellable quantity of the variant.
	InventoryQuantity *int64 `json:"inventoryQuantity"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The media associated with the product variant.
	Media *MediaConnection `json:"media"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// The order of the product variant in the list of product variants. The first position in the list is 1.
	//
	Position int64 `json:"position"`
	// List of prices and compare-at prices in the presentment currencies for this shop.
	PresentmentPrices *ProductVariantPricePairConnection `json:"presentmentPrices"`
	// The price of the product variant in the default shop currency.
	Price string `json:"price"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// The product that this variant belongs to.
	Product *Product `json:"product"`
	// Whether a customer needs to provide a shipping address when placing an order for the product variant.
	//
	RequiresShipping bool `json:"requiresShipping"`
	// List of product options applied to the variant.
	SelectedOptions []*SelectedOption `json:"selectedOptions"`
	// An identifier for the product variant in the shop. Required in order to connect to a fulfillment service.
	//
	Sku *string `json:"sku"`
	// The storefront ID of the product variant.
	StorefrontID string `json:"storefrontId"`
	// The tax code for the product variant.
	TaxCode *string `json:"taxCode"`
	// Whether a tax is charged when the product variant is sold.
	Taxable bool `json:"taxable"`
	// The title of the product variant.
	Title string `json:"title"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
	// The date and time (ISO 8601 format) when the product variant was last modified.
	//
	UpdatedAt string `json:"updatedAt"`
	// The weight of the product variant in the unit system specified with weight_unit.
	Weight *float64 `json:"weight"`
	// The unit of measurement that applies to the product variant's weight. If you don't specify a value for weight_unit, then the shop's default unit of measurement is applied. Valid values: `g`, `kg`, `oz`, `lb`.
	//
	WeightUnit WeightUnit `json:"weightUnit"`
}

func (ProductVariant) IsCommentEventEmbed()        {}
func (ProductVariant) IsNode()                     {}
func (ProductVariant) IsHasMetafields()            {}
func (ProductVariant) IsHasPublishedTranslations() {}
func (ProductVariant) IsNavigable()                {}
func (ProductVariant) IsLegacyInteroperability()   {}

// Specifies the input fields required to append media to a single variant.
type ProductVariantAppendMediaInput struct {
	// Specifies the variant to which media will be appended.
	VariantID string `json:"variantId,omitempty"`
	// Specifies the media to append to the variant.
	MediaIds []string `json:"mediaIds,omitempty"`
}

// Return type for `productVariantAppendMedia` mutation.
type ProductVariantAppendMediaPayload struct {
	// The product associated with the variants and media.
	Product *Product `json:"product"`
	// The product variants that were updated.
	ProductVariants []*ProductVariant `json:"productVariants"`
	// List of errors that occurred executing the mutation.
	UserErrors []*MediaUserError `json:"userErrors"`
}

type ProductVariantConnection struct {
	// A list of edges.
	Edges []*ProductVariantEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `productVariantCreate` mutation.
type ProductVariantCreatePayload struct {
	// The product associated with the variant.
	Product *Product `json:"product"`
	// The successfully created variant.
	ProductVariant *ProductVariant `json:"productVariant"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `productVariantDelete` mutation.
type ProductVariantDeletePayload struct {
	// ID of the deleted product variant.
	DeletedProductVariantID *string `json:"deletedProductVariantId"`
	// Product of the deleted product variant.
	Product *Product `json:"product"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the input fields required to detach media from a single variant.
type ProductVariantDetachMediaInput struct {
	// Specifies the variant from which media will be detached.
	VariantID string `json:"variantId,omitempty"`
	// Specifies the media to detach from the variant.
	MediaIds []string `json:"mediaIds,omitempty"`
}

// Return type for `productVariantDetachMedia` mutation.
type ProductVariantDetachMediaPayload struct {
	// The product associated with the variants and media.
	Product *Product `json:"product"`
	// The product variants that were updated.
	ProductVariants []*ProductVariant `json:"productVariants"`
	// List of errors that occurred executing the mutation.
	UserErrors []*MediaUserError `json:"userErrors"`
}

type ProductVariantEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductVariantEdge.
	Node *ProductVariant `json:"node"`
}

// Specifies a product variant to create or update.
type ProductVariantInput struct {
	// The value of the barcode associated with the product.
	Barcode *string `json:"barcode,omitempty"`
	// The compare-at price of the variant.
	CompareAtPrice *string `json:"compareAtPrice,omitempty"`
	// The ID of the fulfillment service associated with the variant.
	FulfillmentServiceID *string `json:"fulfillmentServiceId,omitempty"`
	// The Harmonized System Code (or HS Tariff Code) for the variant.
	HarmonizedSystemCode *string `json:"harmonizedSystemCode,omitempty"`
	// Specifies the product variant to update or create a new variant if absent.
	ID *string `json:"id,omitempty"`
	// The ID of the image that's associated with the variant.
	ImageID *string `json:"imageId,omitempty"`
	// The URL of an image to associate with the variant.  This field can only be used through mutations that create product images and must match one of the URLs being created on the product.
	//
	ImageSrc *string `json:"imageSrc,omitempty"`
	// The URL of the media to associate with the variant. This field can only be used in mutations that create media images and must match one of the URLs being created on the product. This field only accepts one value.
	MediaSrc []string `json:"mediaSrc,omitempty"`
	// The fulfillment service that tracks the number of items in stock for the product variant. If you track the inventory yourself using the admin, then set the value to `shopify`. Valid values: `shopify` or the handle of a fulfillment service that has inventory management enabled.
	//  This argument is deprecated: Use tracked attribute on `inventoryItem` instead.
	InventoryManagement *ProductVariantInventoryManagement `json:"inventoryManagement,omitempty"`
	// Whether customers are allowed to place an order for the product variant when it's out of stock.
	InventoryPolicy *ProductVariantInventoryPolicy `json:"inventoryPolicy,omitempty"`
	// Create only field. The inventory quantities at each location where the variant is stocked.
	InventoryQuantities []*InventoryLevelInput `json:"inventoryQuantities,omitempty"`
	// Inventory Item associated with the variant, used for unit cost.
	InventoryItem *InventoryItemInput `json:"inventoryItem,omitempty"`
	// Additional customizable information about the product variant.
	Metafields []*MetafieldInput `json:"metafields,omitempty"`
	// The private metafields to associated with this product.
	PrivateMetafields []*PrivateMetafieldInput `json:"privateMetafields,omitempty"`
	// The custom properties that a shop owner uses to define product variants.
	Options []string `json:"options,omitempty"`
	// The order of the product variant in the list of product variants. The first position in the list is 1.
	//
	Position *int64 `json:"position,omitempty"`
	// The price of the variant.
	Price *string `json:"price,omitempty"`
	// Create only required field. Specifies the product on which to create the variant.
	ProductID *string `json:"productId,omitempty"`
	// Whether the variant requires shipping.
	RequiresShipping *bool `json:"requiresShipping,omitempty"`
	// The SKU for the variant.
	Sku *string `json:"sku,omitempty"`
	// Whether the variant is taxable.
	Taxable *bool `json:"taxable,omitempty"`
	// This argument is deprecated: Variant title is not a writable field; it is generated from the selected variant options.
	Title *string `json:"title,omitempty"`
	// The tax code associated with the variant.
	TaxCode *string `json:"taxCode,omitempty"`
	// The weight of the variant.
	Weight *float64 `json:"weight,omitempty"`
	// The unit of weight that's used to measure the variant.
	WeightUnit *WeightUnit `json:"weightUnit,omitempty"`
}

// The compare-at price and price of a variant sharing a currency.
//
type ProductVariantPricePair struct {
	// The compare-at price of the variant with associated currency.
	CompareAtPrice *MoneyV2 `json:"compareAtPrice"`
	// The price of the variant with associated currency.
	Price *MoneyV2 `json:"price"`
}

type ProductVariantPricePairConnection struct {
	// A list of edges.
	Edges []*ProductVariantPricePairEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ProductVariantPricePairEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ProductVariantPricePairEdge.
	Node *ProductVariantPricePair `json:"node"`
}

// Return type for `productVariantUpdate` mutation.
type ProductVariantUpdatePayload struct {
	// The product associated with the variant.
	Product *Product `json:"product"`
	// The updated variant.
	ProductVariant *ProductVariant `json:"productVariant"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// A publication is a group of products and collections that is published to an app.
//
type Publication struct {
	// The app associated with the publication.
	App *App `json:"app"`
	// The collection publications for the list of collections published to the publication.
	CollectionPublicationsV3 *ResourcePublicationConnection `json:"collectionPublicationsV3"`
	// The list of collections published to the publication.
	Collections *CollectionConnection `json:"collections"`
	// Whether the collection is available to the publication.
	HasCollection bool `json:"hasCollection"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Name of the publication.
	Name string `json:"name"`
	// The product publications for the list of products published to the publication.
	ProductPublicationsV3 *ResourcePublicationConnection `json:"productPublicationsV3"`
	// The list of products published to the publication.
	Products *ProductConnection `json:"products"`
	// Whether or not this publication supports future publishing.
	SupportsFuturePublishing bool `json:"supportsFuturePublishing"`
}

func (Publication) IsNode() {}

type PublicationConnection struct {
	// A list of edges.
	Edges []*PublicationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type PublicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of PublicationEdge.
	Node *Publication `json:"node"`
}

// Specifies the input fields required to publish a resource.
type PublicationInput struct {
	// ID of the channel. This argument is deprecated: Use publicationId instead.
	ChannelID *string `json:"channelId,omitempty"`
	// ID of the publication.
	PublicationID *string `json:"publicationId,omitempty"`
	// The date and time that the resource was published. Setting this to a date in the future will schedule
	// the resource to be published. Only online store channels support future publishing.
	//
	PublishDate *string `json:"publishDate,omitempty"`
}

// Return type for `publishablePublish` mutation.
type PublishablePublishPayload struct {
	// Resource that has been published.
	Publishable Publishable `json:"publishable"`
	// The user's shop.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `publishablePublishToCurrentChannel` mutation.
type PublishablePublishToCurrentChannelPayload struct {
	// Resource that has been published.
	Publishable Publishable `json:"publishable"`
	// The user's shop.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `publishableUnpublish` mutation.
type PublishableUnpublishPayload struct {
	// Resource that has been unpublished.
	Publishable Publishable `json:"publishable"`
	// The user's shop.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `publishableUnpublishToCurrentChannel` mutation.
type PublishableUnpublishToCurrentChannelPayload struct {
	// Resource that has been unpublished.
	Publishable Publishable `json:"publishable"`
	// The user's shop.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Published translation of a field of a resource.
type PublishedTranslation struct {
	// Translation key.
	Key string `json:"key"`
	// Translation locale.
	Locale string `json:"locale"`
	// Translation value.
	Value *string `json:"value"`
}

// Represents a refund of items or transactions in an order.
type Refund struct {
	// When the refund was created.
	CreatedAt *string `json:"createdAt"`
	// List of the order's refunded duties.
	Duties []*RefundDuty `json:"duties"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// Note associated with the refund.
	Note *string `json:"note"`
	// The order associated with the refund.
	Order *Order `json:"order"`
	// The RefundLineItem resources attached to the refund.
	RefundLineItems *RefundLineItemConnection `json:"refundLineItems"`
	// Total amount refunded across all the transactions for this refund.
	TotalRefunded *MoneyV2 `json:"totalRefunded"`
	// Total amount refunded across all the transactions for this refund in shop and presentment currencies.
	TotalRefundedSet *MoneyBag `json:"totalRefundedSet"`
	// Transactions associated with the refund.
	Transactions *OrderTransactionConnection `json:"transactions"`
	// When the refund was last updated.
	UpdatedAt string `json:"updatedAt"`
}

func (Refund) IsNode()                   {}
func (Refund) IsLegacyInteroperability() {}

// Return type for `refundCreate` mutation.
type RefundCreatePayload struct {
	// The order associated with the created refund.
	Order *Order `json:"order"`
	// The created refund.
	Refund *Refund `json:"refund"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents a refunded duty.
type RefundDuty struct {
	// Returns the amount of a refunded duty in shop and presentment currencies.
	AmountSet *MoneyBag `json:"amountSet"`
	// Returns a Duty resource. This represents the Duty in the non-refund context.
	OriginalDuty *Duty `json:"originalDuty"`
}

// Specifies the fields required to return duties on a refund.
type RefundDutyInput struct {
	// The ID of the duty in the refund.
	DutyID string `json:"dutyId,omitempty"`
	// The type of refund for this duty.
	RefundType *RefundDutyRefundType `json:"refundType,omitempty"`
}

// Specifies the fields to create a refund.
type RefundInput struct {
	// The currency (in ISO format) that is used to refund the order. This must be the presentment currency (the currency used by the customer) and is a required field for orders where the currency and presentment currency differ.
	Currency *CurrencyCode `json:"currency,omitempty"`
	// Order ID for which the refund is created.
	OrderID string `json:"orderId,omitempty"`
	// An optional note attached to a refund.
	Note *string `json:"note,omitempty"`
	// Whether to send a refund notification to the customer.
	Notify *bool `json:"notify,omitempty"`
	// Specifies how much of the shipping cost to refund.
	Shipping *ShippingRefundInput `json:"shipping,omitempty"`
	// A list of line items to refund.
	RefundLineItems []*RefundLineItemInput `json:"refundLineItems,omitempty"`
	// A list of duties to refund.
	RefundDuties []*RefundDutyInput `json:"refundDuties,omitempty"`
	// A list of transactions involved in the refund.
	Transactions []*OrderTransactionInput `json:"transactions,omitempty"`
}

// Represents the details about a refunded line item.
type RefundLineItem struct {
	// Returns a LineItem resource. This represents the LineItem in the non-refund context.
	LineItem *LineItem `json:"lineItem"`
	// The inventory restock location.
	Location *Location `json:"location"`
	// Returns the price of a refunded line item.
	Price string `json:"price"`
	// Returns the price of a refunded line item in shop and presentment currencies.
	PriceSet *MoneyBag `json:"priceSet"`
	// Returns the quantity of a refunded line item.
	Quantity int64 `json:"quantity"`
	// Represents the type of restock for the refunded line item.
	RestockType RefundLineItemRestockType `json:"restockType"`
	// Whether the refunded line item was restocked. Not applicable in the context of a SuggestedRefund.
	Restocked bool `json:"restocked"`
	// Returns the subtotal price of a refunded line item.
	Subtotal string `json:"subtotal"`
	// Returns the subtotal price of a refunded line item in shop and presentment currencies.
	SubtotalSet *MoneyBag `json:"subtotalSet"`
	// Returns the total tax charged on a refunded line item.
	TotalTax string `json:"totalTax"`
	// Returns the total tax charged on a refunded line item in shop and presentment currencies.
	TotalTaxSet *MoneyBag `json:"totalTaxSet"`
}

type RefundLineItemConnection struct {
	// A list of edges.
	Edges []*RefundLineItemEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type RefundLineItemEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of RefundLineItemEdge.
	Node *RefundLineItem `json:"node"`
}

// Specifies the fields required to return line items on a refund.
type RefundLineItemInput struct {
	// The ID of the line item in the refund.
	LineItemID string `json:"lineItemId,omitempty"`
	// The quantity of the associated line item that was returned.
	Quantity int64 `json:"quantity,omitempty"`
	// The type of restock for this line item.
	RestockType *RefundLineItemRestockType `json:"restockType,omitempty"`
	// The intended location for restocking if `refundType` is not `NO_RESTOCK`
	LocationID *string `json:"locationId,omitempty"`
}

// Presents information or problems to merchants, with 1 or more actions that they can take.
// They can optionally have a specific icon and be dismissed by merchants.
//
type ResourceAlert struct {
	// Buttons in the alert that link to related information.
	// For example, _View risk assessment_.
	//
	Actions []*ResourceAlertAction `json:"actions"`
	// Details about the alert.
	Content string `json:"content"`
	// Unique identifier that appears when an alert is manually closed by the merchant.
	// Most alerts cannot be manually closed.
	//
	DismissibleHandle *string `json:"dismissibleHandle"`
	// Icon that displays with the alert.
	Icon *ResourceAlertIcon `json:"icon"`
	// Indication of how important the alert is.
	Severity ResourceAlertSeverity `json:"severity"`
	// The name of the alert.
	Title string `json:"title"`
}

// An action associated to a resource alert.
type ResourceAlertAction struct {
	// Whether the action is primary or not.
	Primary bool `json:"primary"`
	// Resource for the action to show.
	Show *string `json:"show"`
	// Action title.
	Title string `json:"title"`
	// Action target URL.
	URL string `json:"url"`
}

// Represents feedback from apps about a resource, and the steps required to set up the apps on the shop.
//
type ResourceFeedback struct {
	// Feedback from an app about the steps a merchant needs to take to set up the app on their store.
	AppFeedback []*AppFeedback `json:"appFeedback"`
	// List of AppFeedback detailing issues regarding a resource.
	Details []*AppFeedback `json:"details"`
	// Summary of resource feedback pertaining to the resource.
	Summary string `json:"summary"`
}

// A resource limit represents the limits that the resource has.
type ResourceLimit struct {
	// Whether or not the resource is available.
	Available bool `json:"available"`
	// Quantity available. If null the quantity available is unlimited.
	QuantityAvailable *int64 `json:"quantityAvailable"`
	// Quantity limit of the resource. If null the quantity is unlimited.
	QuantityLimit *int64 `json:"quantityLimit"`
	// Quantity used of the resource. If null the quantity used cannot be retrieved.
	QuantityUsed *int64 `json:"quantityUsed"`
}

// A resource publication represents that a resource has been published to a publication.
type ResourcePublication struct {
	// The channel the resource publication is published to.
	Channel *Channel `json:"channel"`
	// Whether the resource publication is published. Also returns true if the resource publication is scheduled to be published.
	// If false, then the resource publication is neither published nor scheduled to be published.
	//
	IsPublished bool `json:"isPublished"`
	// The publication the resource publication is published to.
	Publication *Publication `json:"publication"`
	// The date that the resource publication was or is going to be published to the publication.
	PublishDate string `json:"publishDate"`
	// The resource published to the publication.
	Publishable Publishable `json:"publishable"`
}

type ResourcePublicationConnection struct {
	// A list of edges.
	Edges []*ResourcePublicationEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ResourcePublicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ResourcePublicationEdge.
	Node *ResourcePublication `json:"node"`
}

// A resource publication represents that a resource either has been published or will be published to a publication.
//
type ResourcePublicationV2 struct {
	// Whether the resource publication is published. If true, then the resource publication is published to the publication.
	// If false, then the resource publication is staged to be published to the publication.
	//
	IsPublished bool `json:"isPublished"`
	// The publication the resource publication is published to.
	Publication *Publication `json:"publication"`
	// The date that the resource publication was or is going to be published to the publication.
	PublishDate *string `json:"publishDate"`
	// The resource published to the publication.
	Publishable Publishable `json:"publishable"`
}

type ResourcePublicationV2Connection struct {
	// A list of edges.
	Edges []*ResourcePublicationV2Edge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ResourcePublicationV2Edge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ResourcePublicationV2Edge.
	Node *ResourcePublicationV2 `json:"node"`
}

// SEO information.
type Seo struct {
	// SEO Description.
	Description *string `json:"description"`
	// SEO Title.
	Title *string `json:"title"`
}

// SEO information.
type SEOInput struct {
	// SEO title of the product.
	Title *string `json:"title,omitempty"`
	// SEO description of the product.
	Description *string `json:"description,omitempty"`
}

// A saved search is a representation of a search query saved in the admin.
type SavedSearch struct {
	// The filters of a saved search.
	Filters []*SearchFilter `json:"filters"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The name of a saved search.
	Name string `json:"name"`
	// The query string of a saved search. This includes search terms and filters.
	Query string `json:"query"`
	// The type of resource this saved search is searching in.
	ResourceType SearchResultType `json:"resourceType"`
	// The search terms of a saved search.
	SearchTerms string `json:"searchTerms"`
}

func (SavedSearch) IsNode()                   {}
func (SavedSearch) IsLegacyInteroperability() {}

type SavedSearchConnection struct {
	// A list of edges.
	Edges []*SavedSearchEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Specifies the fields required to create a saved search.
type SavedSearchCreateInput struct {
	// The type of resouce this saved search is searching in.
	ResourceType SearchResultType `json:"resourceType,omitempty"`
	// A descriptive name of the saved search.
	Name string `json:"name,omitempty"`
	// The query string of a saved search. This includes search terms and filters.
	Query string `json:"query,omitempty"`
}

// Return type for `savedSearchCreate` mutation.
type SavedSearchCreatePayload struct {
	// The saved search that was created.
	SavedSearch *SavedSearch `json:"savedSearch"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the fields to delete a saved search.
type SavedSearchDeleteInput struct {
	// ID of the saved search to delete.
	ID string `json:"id,omitempty"`
}

// Return type for `savedSearchDelete` mutation.
type SavedSearchDeletePayload struct {
	// The id of the saved search that was deleted.
	DeletedSavedSearchID *string `json:"deletedSavedSearchId"`
	// The shop of the saved search that was deleted.
	Shop *Shop `json:"shop"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type SavedSearchEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of SavedSearchEdge.
	Node *SavedSearch `json:"node"`
}

// Specifies the fields required to update a saved search.
type SavedSearchUpdateInput struct {
	// ID of the saved search to update.
	ID string `json:"id,omitempty"`
	// A descriptive name of the saved search.
	Name *string `json:"name,omitempty"`
	// The query string of a saved search. This included search terms and filters.
	Query *string `json:"query,omitempty"`
}

// Return type for `savedSearchUpdate` mutation.
type SavedSearchUpdatePayload struct {
	// The saved search that was updated.
	SavedSearch *SavedSearch `json:"savedSearch"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Script discount applications capture the intentions of a discount that
// was created by a Shopify Script for an order's line item or shipping line.
//
type ScriptDiscountApplication struct {
	// The method by which the discount's value is allocated to its entitled items.
	AllocationMethod DiscountApplicationAllocationMethod `json:"allocationMethod"`
	// The description of the application as defined by the Script.
	Description string `json:"description"`
	// An ordered index that can be used to identify the discount application and indicate the precedence
	// of the discount application for calculations.
	//
	Index int64 `json:"index"`
	// How the discount amount is distributed on the discounted lines.
	TargetSelection DiscountApplicationTargetSelection `json:"targetSelection"`
	// Whether the discount is applied on line items or shipping lines.
	TargetType DiscountApplicationTargetType `json:"targetType"`
	// The title of the application as defined by the Script.
	Title string `json:"title"`
	// The value of the discount application.
	Value PricingValue `json:"value"`
}

func (ScriptDiscountApplication) IsDiscountApplication() {}

// A script tag represents remote JavaScript code that is loaded into the pages of a shop's storefront or the order status page of checkout.
//
type ScriptTag struct {
	// The date and time when the script tag was created.
	CreatedAt string `json:"createdAt"`
	// The page or pages on the online store that the script should be included.
	DisplayScope ScriptTagDisplayScope `json:"displayScope"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The URL to the remote script.
	Src string `json:"src"`
	// The date and time when the script tag was last updated.
	UpdatedAt string `json:"updatedAt"`
}

func (ScriptTag) IsNode()                   {}
func (ScriptTag) IsLegacyInteroperability() {}

type ScriptTagConnection struct {
	// A list of edges.
	Edges []*ScriptTagEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `scriptTagCreate` mutation.
type ScriptTagCreatePayload struct {
	// The script tag that was created.
	ScriptTag *ScriptTag `json:"scriptTag"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `scriptTagDelete` mutation.
type ScriptTagDeletePayload struct {
	// The ID of the deleted script tag.
	DeletedScriptTagID *string `json:"deletedScriptTagId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type ScriptTagEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ScriptTagEdge.
	Node *ScriptTag `json:"node"`
}

// Specifies the input fields for a script tag.
//
type ScriptTagInput struct {
	// The URL of the remote script.
	Src *string `json:"src,omitempty"`
	// The page or pages on the online store where the script should be included.
	DisplayScope *ScriptTagDisplayScope `json:"displayScope,omitempty"`
}

// Return type for `scriptTagUpdate` mutation.
type ScriptTagUpdatePayload struct {
	// The script tag that was updated.
	ScriptTag *ScriptTag `json:"scriptTag"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// A filter in a search query represented by a key value pair.
type SearchFilter struct {
	// The key of the search filter.
	Key string `json:"key"`
	// The value of the search filter.
	Value string `json:"value"`
}

// A list of search filters along with their specific options in value and label pair for filtering.
type SearchFilterOptions struct {
	// A list of options that can be use to filter product availability.
	ProductAvailability []*FilterOption `json:"productAvailability"`
}

// Represents an individual result returned from a search.
type SearchResult struct {
	// Returns the search result description text.
	Description *string `json:"description"`
	// Returns the Image resource presented to accompany a search result.
	Image *Image `json:"image"`
	// Returns the ID of the resource returned in the search result.
	Reference Node `json:"reference"`
	// Returns the resource title.
	Title string `json:"title"`
	// Returns the absolute URL to the resource in the search result.
	URL string `json:"url"`
}

// The connection type for SearchResult.
type SearchResultConnection struct {
	// A list of edges.
	Edges []*SearchResultEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Information to aid in pagination.
	ResultsAfterCount int64 `json:"resultsAfterCount"`
}

type SearchResultEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of SearchResultEdge.
	Node *SearchResult `json:"node"`
}

// Custom properties that a shop owner can use to define product variants.
// Multiple options can exist. Options are represented as: option1, option2, option3, etc.
//
type SelectedOption struct {
	// The product option’s name.
	Name string `json:"name"`
	// The product option’s value.
	Value string `json:"value"`
}

// Represents the shipping details that the customer chose for their order.
type ShippingLine struct {
	// A reference to the carrier service that provided the rate.
	// Present when the rate was computed by a third-party carrier service.
	//
	CarrierIdentifier *string `json:"carrierIdentifier"`
	// A reference to the shipping method.
	Code *string `json:"code"`
	// Whether the shipping line is custom or not.
	Custom bool `json:"custom"`
	// The general classification of the delivery method.
	DeliveryCategory *string `json:"deliveryCategory"`
	// The discounts that have been allocated to the shipping line.
	//
	DiscountAllocations []*DiscountAllocation `json:"discountAllocations"`
	// The pre-tax shipping price with discounts applied.
	DiscountedPrice *MoneyV2 `json:"discountedPrice"`
	// The pre-tax shipping price with discounts applied.
	DiscountedPriceSet *MoneyBag `json:"discountedPriceSet"`
	// Globally unique identifier.
	ID *string `json:"id"`
	// The pre-tax shipping price without any discounts applied.
	OriginalPrice *MoneyV2 `json:"originalPrice"`
	// The pre-tax shipping price without any discounts applied.
	OriginalPriceSet *MoneyBag `json:"originalPriceSet"`
	// The phone number at the shipping address.
	Phone *string `json:"phone"`
	// Returns the price of the shipping line.
	Price string `json:"price"`
	// The fulfillment service requested for the shipping method.
	// Present if the shipping method requires processing by a third party fulfillment service.
	//
	RequestedFulfillmentService *FulfillmentService `json:"requestedFulfillmentService"`
	// A unique identifier for the shipping rate. The format can change without notice and is not meant to be shown to users.
	ShippingRateHandle *string `json:"shippingRateHandle"`
	// Returns the rate source for the shipping line.
	Source *string `json:"source"`
	// The TaxLine objects connected to this shipping line.
	TaxLines []*TaxLine `json:"taxLines"`
	// Returns the title of the shipping line.
	Title string `json:"title"`
}

type ShippingLineConnection struct {
	// A list of edges.
	Edges []*ShippingLineEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ShippingLineEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ShippingLineEdge.
	Node *ShippingLine `json:"node"`
}

// Specifies the shipping details for the order.
type ShippingLineInput struct {
	// Price of the shipping rate.
	Price *string `json:"price,omitempty"`
	// A unique identifier for the shipping rate.
	ShippingRateHandle *string `json:"shippingRateHandle,omitempty"`
	// Title of the shipping rate.
	Title *string `json:"title,omitempty"`
}

// The shipping method for the delivery.
type ShippingMethod struct {
	// A unique code associated with the rate. For example: `expedited_mail`
	Code string `json:"code"`
	// A description of the rate, which customers will see at checkout.
	// For example: `Includes tracking and insurance`.
	//
	Label string `json:"label"`
}

// Return type for `shippingPackageDelete` mutation.
type ShippingPackageDeletePayload struct {
	// The ID of the deleted shipping package.
	DeletedID *string `json:"deletedId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `shippingPackageMakeDefault` mutation.
type ShippingPackageMakeDefaultPayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `shippingPackageUpdate` mutation.
type ShippingPackageUpdatePayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// A shipping rate to be applied to an order.
type ShippingRate struct {
	// Human-readable unique identifier for this shipping rate.
	Handle string `json:"handle"`
	// Price of this shipping rate.
	Price *MoneyV2 `json:"price"`
	// Title of this shipping rate.
	Title string `json:"title"`
}

// Represents the shipping costs refunded on the Refund.
type ShippingRefund struct {
	// The monetary value of the shipping fees to be returned.
	Amount string `json:"amount"`
	// The monetary value of the shipping fees to be returned in shop and presentment currencies.
	AmountSet *MoneyBag `json:"amountSet"`
	// The maximum amount of shipping fees currently refundable.
	MaximumRefundable string `json:"maximumRefundable"`
	// The maximum amount of shipping fees currently refundable in shop and presentment currencies.
	MaximumRefundableSet *MoneyBag `json:"maximumRefundableSet"`
	// The monetary value of the tax allocated to shipping fees to be returned.
	Tax string `json:"tax"`
	// The monetary value of the tax allocated to shipping fees to be returned in shop and presentment currencies.
	TaxSet *MoneyBag `json:"taxSet"`
}

// Specifies the fields required to return shipping costs on a Refund.
type ShippingRefundInput struct {
	// The monetary value of the shipping fees to be returned.
	Amount *string `json:"amount,omitempty"`
	// Whether a full refund is provided.
	FullRefund *bool `json:"fullRefund,omitempty"`
}

// Represents the shop object.
//
type Shop struct {
	// Alert message that appears in the Shopify admin.
	Alerts []*ShopAlert `json:"alerts"`
	// The token required to query the shop's reports or dashboards.
	AnalyticsToken string `json:"analyticsToken"`
	// Paginated list of fulfillment orders assigned to fulfillment services.
	AssignedFulfillmentOrders *FulfillmentOrderConnection `json:"assignedFulfillmentOrders"`
	// List of sales channels not currently installed on the shop.
	AvailableChannelApps *AppConnection `json:"availableChannelApps"`
	// The shop's billing address information.
	BillingAddress *MailingAddress `json:"billingAddress"`
	// Exposes the number of channels.
	ChannelCount int64 `json:"channelCount"`
	// List of the shop's active sales channels.
	Channels *ChannelConnection `json:"channels"`
	// Specifies whether the shop supports checkouts via Checkout API.
	CheckoutAPISupported bool `json:"checkoutApiSupported"`
	// Return a collection by its handle.
	CollectionByHandle *Collection `json:"collectionByHandle"`
	// List of the shop's collection saved searches.
	CollectionSavedSearches *SavedSearchConnection `json:"collectionSavedSearches"`
	// List of the shop's collections.
	Collections *CollectionConnection `json:"collections"`
	// The public-facing contact email address for the shop.
	// Customers will use this email to communicate with the shop owner.
	//
	ContactEmail string `json:"contactEmail"`
	// Countries that have been defined in shipping zones for the shop.
	CountriesInShippingZones *CountriesInShippingZones `json:"countriesInShippingZones"`
	// The three letter code for the shop's currency.
	CurrencyCode CurrencyCode `json:"currencyCode"`
	// How currencies are displayed on your store.
	CurrencyFormats *CurrencyFormats `json:"currencyFormats"`
	// The currency settings for the shop.
	CurrencySettings *CurrencySettingConnection `json:"currencySettings"`
	// The shop's customer account requirement preference.
	CustomerAccounts ShopCustomerAccountsSetting `json:"customerAccounts"`
	// List of the shop's customer saved searches.
	CustomerSavedSearches *SavedSearchConnection `json:"customerSavedSearches"`
	// A comma separated list of tags that have been added to customer accounts.
	CustomerTags *StringConnection `json:"customerTags"`
	// Customer accounts associated to the shop.
	Customers *CustomerConnection `json:"customers"`
	// The shop's meta description used in search engine results.
	Description *string `json:"description"`
	// The domains configured for the shop.
	Domains []*Domain `json:"domains"`
	// List of the shop's draft order saved searches.
	DraftOrderSavedSearches *SavedSearchConnection `json:"draftOrderSavedSearches"`
	// A comma separated list of tags that have been added to draft orders.
	DraftOrderTags *StringConnection `json:"draftOrderTags"`
	// List of saved draft orders on the shop.
	DraftOrders *DraftOrderConnection `json:"draftOrders"`
	// The shop owner's email address.
	// Shopify will use this email address to communicate with the shop owner.
	//
	Email string `json:"email"`
	// The presentment currencies enabled for the shop.
	EnabledPresentmentCurrencies []CurrencyCode `json:"enabledPresentmentCurrencies"`
	// The shop's features.
	Features *ShopFeatures `json:"features"`
	// Paginated list of merchant-managed and third-party fulfillment orders.
	FulfillmentOrders *FulfillmentOrderConnection `json:"fulfillmentOrders"`
	// List of the shop's installed fulfillment services.
	FulfillmentServices []*FulfillmentService `json:"fulfillmentServices"`
	// The shop's time zone as defined by the IANA.
	IanaTimezone string `json:"ianaTimezone"`
	// Globally unique identifier.
	ID string `json:"id"`
	// List of the shop's inventory items.
	InventoryItems *InventoryItemConnection `json:"inventoryItems"`
	// The number of pendings orders on the shop.
	// Limited to a maximum of 10000.
	//
	LimitedPendingOrderCount *LimitedPendingOrderCount `json:"limitedPendingOrderCount"`
	// List of active locations of the shop.
	Locations *LocationConnection `json:"locations"`
	// List of a shop's marketing events.
	MarketingEvents *MarketingEventConnection `json:"marketingEvents"`
	// The metafield associated with the resource.
	Metafield *Metafield `json:"metafield"`
	// A paginated list of metafields associated with the resource.
	Metafields *MetafieldConnection `json:"metafields"`
	// The shop's .myshopify.com domain name.
	MyshopifyDomain string `json:"myshopifyDomain"`
	// The shop's name.
	Name string `json:"name"`
	// The navigation settings of the shop.
	NavigationSettings []*NavigationItem `json:"navigationSettings"`
	// The prefix that appears before order numbers.
	OrderNumberFormatPrefix string `json:"orderNumberFormatPrefix"`
	// The suffix that appears after order numbers.
	OrderNumberFormatSuffix string `json:"orderNumberFormatSuffix"`
	// List of the shop's order saved searches.
	OrderSavedSearches *SavedSearchConnection `json:"orderSavedSearches"`
	// A comma separated list of tags that have been added to orders.
	OrderTags *StringConnection `json:"orderTags"`
	// List of orders placed on the shop.
	Orders *OrderConnection `json:"orders"`
	// Settings related to payments.
	PaymentSettings *PaymentSettings `json:"paymentSettings"`
	// Number of pending orders on the shop.
	PendingOrderCount int64 `json:"pendingOrderCount"`
	// The shop's plan.
	Plan *ShopPlan `json:"plan"`
	// List of the shop's price rule saved searches.
	PriceRuleSavedSearches *SavedSearchConnection `json:"priceRuleSavedSearches"`
	// List of the shop’s price rules.
	PriceRules *PriceRuleConnection `json:"priceRules"`
	// The shop's primary domain name.
	PrimaryDomain *Domain `json:"primaryDomain"`
	// Returns a private metafield found by namespace and key.
	PrivateMetafield *PrivateMetafield `json:"privateMetafield"`
	// List of private metafields.
	PrivateMetafields *PrivateMetafieldConnection `json:"privateMetafields"`
	// Return a product by its handle.
	ProductByHandle *Product `json:"productByHandle"`
	// All images of all products of the shop.
	ProductImages *ImageConnection `json:"productImages"`
	// List of the shop's product saved searches.
	ProductSavedSearches *SavedSearchConnection `json:"productSavedSearches"`
	// A comma separated list of tags that have been added to products.
	ProductTags *StringConnection `json:"productTags"`
	// Types added to products.
	ProductTypes *StringConnection `json:"productTypes"`
	// List of the shop's product variants.
	ProductVariants *ProductVariantConnection `json:"productVariants"`
	// Vendors added to products.
	ProductVendors *StringConnection `json:"productVendors"`
	// List of the shop's products.
	Products *ProductConnection `json:"products"`
	// Exposes the number of publications.
	PublicationCount int64 `json:"publicationCount"`
	// Resource limits of a shop.
	ResourceLimits *ShopResourceLimits `json:"resourceLimits"`
	// The URL of the rich text editor.
	RichTextEditorURL string `json:"richTextEditorUrl"`
	// Return admin search results.
	Search *SearchResultConnection `json:"search"`
	// List of search filter options.
	SearchFilters *SearchFilterOptions `json:"searchFilters"`
	// Whether the shop has outstanding setup steps.
	SetupRequired bool `json:"setupRequired"`
	// Countries that the shop ships to.
	ShipsToCountries []CountryCode `json:"shipsToCountries"`
	// A list of all policies associated with a shop.
	ShopPolicies []*ShopPolicy `json:"shopPolicies"`
	// Shopify Payments account information, including balances and payouts.
	ShopifyPaymentsAccount *ShopifyPaymentsAccount `json:"shopifyPaymentsAccount"`
	// Storefront access token of a private application. Scoped per-application.
	StorefrontAccessTokens *StorefrontAccessTokenConnection `json:"storefrontAccessTokens"`
	// The URL of the shop's storefront.
	StorefrontURL string `json:"storefrontUrl"`
	// Specifies whether or not taxes are charged for shipping.
	TaxShipping bool `json:"taxShipping"`
	// The setting for whether applicable taxes are included in product prices.
	TaxesIncluded bool `json:"taxesIncluded"`
	// The shop's time zone abbreviation.
	TimezoneAbbreviation string `json:"timezoneAbbreviation"`
	// The shop's time zone offset.
	TimezoneOffset string `json:"timezoneOffset"`
	// The shop's time zone offset expressed in number of minutes.
	TimezoneOffsetMinutes int64 `json:"timezoneOffsetMinutes"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
	// The shop's unit system.
	UnitSystem UnitSystem `json:"unitSystem"`
	// All images uploaded to the shop.
	UploadedImages *ImageConnection `json:"uploadedImages"`
	// Fetch list of images uploaded to shop by ids.
	UploadedImagesByIds []*Image `json:"uploadedImagesByIds"`
	// The URL of the shop's storefront.
	URL string `json:"url"`
	// The shop's primary unit of weight for products and shipping.
	WeightUnit WeightUnit `json:"weightUnit"`
}

func (Shop) IsNode()                     {}
func (Shop) IsHasPublishedTranslations() {}
func (Shop) IsHasMetafields()            {}

// Alert message that appears in the Shopify admin.
type ShopAlert struct {
	// Button in the alert that links to related information.
	Action *ShopAlertAction `json:"action"`
	// Description of the alert.
	Description string `json:"description"`
}

// An action associated to a shop alert.
type ShopAlertAction struct {
	// Action title.
	Title string `json:"title"`
	// Action target URL.
	URL string `json:"url"`
}

// Represents the feature set available to the shop.
//
type ShopFeatures struct {
	// Whether a shop has access to avalara avatax.
	AvalaraAvatax bool `json:"avalaraAvatax"`
	// Branding of the shop.
	Branding ShopBranding `json:"branding"`
	// Whether a shop's storefront can have CAPTCHA protection.
	Captcha bool `json:"captcha"`
	// Whether a shop's storefront can have CAPTCHA protection for domains not managed by Shopify.
	CaptchaExternalDomains bool `json:"captchaExternalDomains"`
	// Whether the delivery profiles functionality is enabled for this shop.
	DeliveryProfiles bool `json:"deliveryProfiles"`
	// Whether a shop has access to the dynamic remarketing feature.
	DynamicRemarketing bool `json:"dynamicRemarketing"`
	// Whether a shop can create gift cards.
	GiftCards bool `json:"giftCards"`
	// Display Harmonized System codes on products.  Used for customs when shipping cross-border.
	HarmonizedSystemCode bool `json:"harmonizedSystemCode"`
	// Whether a shop can enable international domains.
	InternationalDomains bool `json:"internationalDomains"`
	// Whether to show the live view. Live view is hidden from merchants that are on a trial or don't have a storefront.
	LiveView bool `json:"liveView"`
	// Whether the multi-location functionality is enabled for this shop.
	MultiLocation bool `json:"multiLocation"`
	// Whether a shop has access to the onboarding visual.
	OnboardingVisual bool `json:"onboardingVisual"`
	// Whether a shop has access to all reporting features.
	Reports bool `json:"reports"`
	// Whether the shop has a Shopify Plus subscription.
	ShopifyPlus bool `json:"shopifyPlus"`
	// Whether to show metrics. Metrics are hidden for new merchants until they become meaningful.
	ShowMetrics bool `json:"showMetrics"`
	// Whether the shop has an online storefront.
	Storefront bool `json:"storefront"`
}

// Available locale for a shop.
type ShopLocale struct {
	// Locale identifier.
	Locale string `json:"locale"`
	// Locale name.
	Name string `json:"name"`
	// Whether or not this is the default locale for the shop.
	Primary bool `json:"primary"`
	// Whether or not the locale is published.
	Published bool `json:"published"`
}

// Return type for `shopLocaleDisable` mutation.
type ShopLocaleDisablePayload struct {
	// The locale identifier that was disabled.
	Locale *string `json:"locale"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `shopLocaleEnable` mutation.
type ShopLocaleEnablePayload struct {
	// The locale that was enabled.
	ShopLocale *ShopLocale `json:"shopLocale"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the input fields for a shop locale.
//
type ShopLocaleInput struct {
	// Specifies the publication state of the locale.
	Published *bool `json:"published,omitempty"`
}

// Return type for `shopLocaleUpdate` mutation.
type ShopLocaleUpdatePayload struct {
	// The locale that was updated.
	ShopLocale *ShopLocale `json:"shopLocale"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents the billing plan of the shop.
//
type ShopPlan struct {
	// The name of the shop's billing plan.
	DisplayName string `json:"displayName"`
	// Whether the shop is a partner development shop for testing purposes.
	PartnerDevelopment bool `json:"partnerDevelopment"`
	// Whether the shop has a Shopify Plus subscription.
	ShopifyPlus bool `json:"shopifyPlus"`
}

// Policy that a merchant has configured for their store, such as their refund or privacy policy.
type ShopPolicy struct {
	// The text of the policy. The maximum size is 512kb.
	Body string `json:"body"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The translations associated with the resource.
	Translations []*PublishedTranslation `json:"translations"`
	// The shop policy type.
	Type ShopPolicyType `json:"type"`
	// The public URL of the policy.
	URL string `json:"url"`
}

func (ShopPolicy) IsNode()                     {}
func (ShopPolicy) IsHasPublishedTranslations() {}

// Specifies the input fields required to update a policy.
type ShopPolicyInput struct {
	// The shop policy type.
	Type ShopPolicyType `json:"type,omitempty"`
	// Policy text, maximum size of 512kb.
	Body string `json:"body,omitempty"`
}

// Return type for `shopPolicyUpdate` mutation.
type ShopPolicyUpdatePayload struct {
	// The shop policy that has been updated.
	ShopPolicy *ShopPolicy `json:"shopPolicy"`
	// List of errors that occurred executing the mutation.
	UserErrors []*ShopPolicyUserError `json:"userErrors"`
}

// An error that occurs during the execution of a shop policy mutation.
type ShopPolicyUserError struct {
	// Error code to uniquely identify the error.
	Code *ShopPolicyErrorCode `json:"code"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (ShopPolicyUserError) IsDisplayableError() {}

// Resource limits of a shop.
type ShopResourceLimits struct {
	// Maximum number of locations allowed.
	LocationLimit int64 `json:"locationLimit"`
	// Maximum number of product options allowed.
	MaxProductOptions int64 `json:"maxProductOptions"`
	// Maximum number of variants allowed.
	MaxProductVariants int64 `json:"maxProductVariants"`
	// Whether the shop has reached the limit of the number of URL redirects it can make for resources.
	RedirectLimitReached bool `json:"redirectLimitReached"`
	// SKU limits. If the shop has unlimited skus the quantity used cannot be retrieved.
	SkuResourceLimits *ResourceLimit `json:"skuResourceLimits"`
}

// Balance and payout information for a
// [Shopify Payments](https://help.shopify.com/manual/payments/shopify-payments/getting-paid-with-shopify-payments)
// account. Balance includes all balances for the currencies supported by the shop.
// You can also query for a list of payouts, where each payout includes the corresponding currencyCode field.
//
type ShopifyPaymentsAccount struct {
	// Whether the Shopify Payments setup is completed.
	Activated bool `json:"activated"`
	// Current balances in all currencies for the account.
	Balance []*MoneyV2 `json:"balance"`
	// All bank accounts configured for the Shopify Payments account.
	BankAccounts *ShopifyPaymentsBankAccountConnection `json:"bankAccounts"`
	// Statement descriptor used for charges.
	//
	// This is what buyers will see on their credit card or bank statements when making a purchase.
	//
	ChargeStatementDescriptor *string `json:"chargeStatementDescriptor"`
	// Statement descriptors used for charges.
	//
	// This is what buyers will see on their credit card or bank statements when making a purchase.
	//
	ChargeStatementDescriptors ShopifyPaymentsChargeStatementDescriptor `json:"chargeStatementDescriptors"`
	// The Shopify Payments account country.
	Country string `json:"country"`
	// The default payout currency for the Shopify Payments account.
	DefaultCurrency CurrencyCode `json:"defaultCurrency"`
	// All disputes related to the Shopify Payments account.
	Disputes *ShopifyPaymentsDisputeConnection `json:"disputes"`
	// The fraud settings of the Shopify Payments account.
	FraudSettings *ShopifyPaymentsFraudSettings `json:"fraudSettings"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The notifications settings for the account.
	NotificationSettings *ShopifyPaymentsNotificationSettings `json:"notificationSettings"`
	// Whether the Shopify Payments account can be onboarded.
	Onboardable bool `json:"onboardable"`
	// Payout schedule for the account.
	PayoutSchedule *ShopifyPaymentsPayoutSchedule `json:"payoutSchedule"`
	// Descriptor used for payouts.
	//
	// This is what merchants will see on their bank statement when receiving a payout.
	//
	PayoutStatementDescriptor *string `json:"payoutStatementDescriptor"`
	// All current and previous payouts made between the account and the bank account.
	Payouts *ShopifyPaymentsPayoutConnection `json:"payouts"`
	// The permitted documents for identity verification.
	PermittedVerificationDocuments []*ShopifyPaymentsVerificationDocument `json:"permittedVerificationDocuments"`
	// The verifications necessary for this account.
	Verifications []*ShopifyPaymentsVerification `json:"verifications"`
}

func (ShopifyPaymentsAccount) IsNode() {}

// A bank account that can receive payouts.
//
type ShopifyPaymentsBankAccount struct {
	// The account number of the bank account.
	//
	AccountNumber string `json:"accountNumber"`
	// The last digits of the account number (the rest is redacted).
	//
	AccountNumberLastDigits string `json:"accountNumberLastDigits"`
	// The name of the bank.
	//
	BankName *string `json:"bankName"`
	// The country of the bank.
	//
	Country CountryCode `json:"country"`
	// The date that the bank account was created.
	CreatedAt string `json:"createdAt"`
	// The currency of the bank account.
	//
	Currency CurrencyCode `json:"currency"`
	// Globally unique identifier.
	ID string `json:"id"`
	// All current and previous payouts made between the account and the bank account.
	Payouts *ShopifyPaymentsPayoutConnection `json:"payouts"`
	// The routing number of the bank account.
	//
	RoutingNumber string `json:"routingNumber"`
	// The status of the bank account.
	//
	Status ShopifyPaymentsBankAccountStatus `json:"status"`
}

func (ShopifyPaymentsBankAccount) IsNode() {}

type ShopifyPaymentsBankAccountConnection struct {
	// A list of edges.
	Edges []*ShopifyPaymentsBankAccountEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ShopifyPaymentsBankAccountEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ShopifyPaymentsBankAccountEdge.
	Node *ShopifyPaymentsBankAccount `json:"node"`
}

// The charge descriptors for a payments account.
type ShopifyPaymentsDefaultChargeStatementDescriptor struct {
	// The default charge statement descriptor.
	Default *string `json:"default"`
	// The prefix of the statement descriptor.
	Prefix string `json:"prefix"`
}

func (ShopifyPaymentsDefaultChargeStatementDescriptor) IsShopifyPaymentsChargeStatementDescriptor() {}

// A dispute occurs when a buyer questions the legitimacy of a charge with their financial institution.
type ShopifyPaymentsDispute struct {
	// The total amount disputed by the cardholder.
	Amount *MoneyV2 `json:"amount"`
	// The deadline for evidence submission.
	EvidenceDueBy *time.Time `json:"evidenceDueBy"`
	// The date when evidence was sent. Returns null if evidence has not yet been sent.
	EvidenceSentOn *time.Time `json:"evidenceSentOn"`
	// The date when this dispute was resolved. Returns null if the dispute is not yet resolved.
	FinalizedOn *time.Time `json:"finalizedOn"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The date when this dispute was initiated.
	InitiatedAt string `json:"initiatedAt"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The order that contains the charge that is under dispute.
	Order *Order `json:"order"`
	// The reason of the dispute.
	ReasonDetails *ShopifyPaymentsDisputeReasonDetails `json:"reasonDetails"`
	// The current state of the dispute.
	Status DisputeStatus `json:"status"`
	// Indicates if this dispute is still in the inquiry phase or has turned into a chargeback.
	Type DisputeType `json:"type"`
}

func (ShopifyPaymentsDispute) IsLegacyInteroperability() {}
func (ShopifyPaymentsDispute) IsNode()                   {}

type ShopifyPaymentsDisputeConnection struct {
	// A list of edges.
	Edges []*ShopifyPaymentsDisputeEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ShopifyPaymentsDisputeEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ShopifyPaymentsDisputeEdge.
	Node *ShopifyPaymentsDispute `json:"node"`
}

// Details regarding a dispute reason.
type ShopifyPaymentsDisputeReasonDetails struct {
	// The raw code provided by the payment network.
	NetworkReasonCode *string `json:"networkReasonCode"`
	// The reason for the dispute provided by the cardholder's banks.
	Reason ShopifyPaymentsDisputeReason `json:"reason"`
}

// The fraud settings of a payments account.
type ShopifyPaymentsFraudSettings struct {
	// Decline a charge if there is an AVS failure.
	DeclineChargeOnAvsFailure bool `json:"declineChargeOnAvsFailure"`
	// Decline a charge if there is an CVC failure.
	DeclineChargeOnCvcFailure bool `json:"declineChargeOnCvcFailure"`
}

// The charge descriptors for a Japanese payments account.
type ShopifyPaymentsJpChargeStatementDescriptor struct {
	// The default charge statement descriptor.
	Default *string `json:"default"`
	// The charge statement descriptor in kana.
	Kana *string `json:"kana"`
	// The charge statement descriptor in kanji.
	Kanji *string `json:"kanji"`
	// The prefix of the statement descriptor.
	Prefix string `json:"prefix"`
}

func (ShopifyPaymentsJpChargeStatementDescriptor) IsShopifyPaymentsChargeStatementDescriptor() {}

// The notification settings for the account.
type ShopifyPaymentsNotificationSettings struct {
	// Receive email notifications when new payouts are sent or payouts fail.
	Payouts bool `json:"payouts"`
}

// Payouts represent the movement of money between a merchant's Shopify
// Payments balance and their bank account.
//
type ShopifyPaymentsPayout struct {
	// The bank account for the payout.
	BankAccount *ShopifyPaymentsBankAccount `json:"bankAccount"`
	// The total amount and currency of the payout.
	Gross *MoneyV2 `json:"gross"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The exact time when the payout was issued. The payout only contains
	// balance transactions that were available at this time.
	//
	IssuedAt string `json:"issuedAt"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The total amount and currency of the payout.
	Net *MoneyV2 `json:"net"`
	// The transfer status of the payout.
	Status ShopifyPaymentsPayoutStatus `json:"status"`
	// The summary of the payout.
	Summary *ShopifyPaymentsPayoutSummary `json:"summary"`
	// The direction of the payout.
	TransactionType ShopifyPaymentsPayoutTransactionType `json:"transactionType"`
}

func (ShopifyPaymentsPayout) IsLegacyInteroperability() {}
func (ShopifyPaymentsPayout) IsNode()                   {}

type ShopifyPaymentsPayoutConnection struct {
	// A list of edges.
	Edges []*ShopifyPaymentsPayoutEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type ShopifyPaymentsPayoutEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of ShopifyPaymentsPayoutEdge.
	Node *ShopifyPaymentsPayout `json:"node"`
}

// The payment schedule for a payments account.
type ShopifyPaymentsPayoutSchedule struct {
	// The interval at which payouts are sent to the connected bank account.
	Interval ShopifyPaymentsPayoutInterval `json:"interval"`
	// The day of the month funds will be paid out.
	//
	// The value can be any day of the month from the 1st to the 31st.
	// If the payment interval is set to monthly, this value will be used.
	// Payouts scheduled between 29-31st of the month are sent on the last day of shorter months.
	//
	MonthlyAnchor *int64 `json:"monthlyAnchor"`
	// The day of the week funds will be paid out.
	//
	// The value can be any weekday from Monday to Friday.
	// If the payment interval is set to weekly, this value will be used.
	//
	WeeklyAnchor *DayOfTheWeek `json:"weeklyAnchor"`
}

// Breakdown of the total fees and gross of each of the different types of transactions associated
// with the payout.
//
type ShopifyPaymentsPayoutSummary struct {
	// Total fees for all adjustments including disputes.
	AdjustmentsFee *MoneyV2 `json:"adjustmentsFee"`
	// Total gross amount for all adjustments including disputes.
	AdjustmentsGross *MoneyV2 `json:"adjustmentsGross"`
	// Total fees for all charges.
	ChargesFee *MoneyV2 `json:"chargesFee"`
	// Total gross amount for all charges.
	ChargesGross *MoneyV2 `json:"chargesGross"`
	// Total fees for all refunds.
	RefundsFee *MoneyV2 `json:"refundsFee"`
	// Total gross amount for all refunds.
	RefundsFeeGross *MoneyV2 `json:"refundsFeeGross"`
	// Total fees for all reserved funds.
	ReservedFundsFee *MoneyV2 `json:"reservedFundsFee"`
	// Total gross amount for all reserved funds.
	ReservedFundsGross *MoneyV2 `json:"reservedFundsGross"`
	// Total fees for all retried payouts.
	RetriedPayoutsFee *MoneyV2 `json:"retriedPayoutsFee"`
	// Total gross amount for all retried payouts.
	RetriedPayoutsGross *MoneyV2 `json:"retriedPayoutsGross"`
}

// Each subject (individual) of an account has a verification object giving
//  information about the verification state.
//
type ShopifyPaymentsVerification struct {
	// Globally unique identifier.
	ID string `json:"id"`
	// The status of the verification.
	Status ShopifyPaymentsVerificationStatus `json:"status"`
	// The subject/individual who has to be verified.
	Subject *ShopifyPaymentsVerificationSubject `json:"subject"`
}

func (ShopifyPaymentsVerification) IsNode() {}

// A document which can be used to verify an individual.
type ShopifyPaymentsVerificationDocument struct {
	// True if the back side of the document is required.
	BackRequired bool `json:"backRequired"`
	// True if the front side of the document is required.
	FrontRequired bool `json:"frontRequired"`
	// The type of the document which can be used for verification.
	Type ShopifyPaymentsVerificationDocumentType `json:"type"`
}

// The verification subject represents an individual that has to be verified.
type ShopifyPaymentsVerificationSubject struct {
	// The family name of the individual to verify.
	FamilyName string `json:"familyName"`
	// The given name of the individual to verify.
	GivenName string `json:"givenName"`
}

// Image to be uploaded.
type StageImageInput struct {
	// Image resource.
	Resource StagedUploadTargetGenerateUploadResource `json:"resource,omitempty"`
	// Image filename.
	Filename string `json:"filename,omitempty"`
	// Image MIME type.
	MimeType string `json:"mimeType,omitempty"`
	// HTTP method to be used by the Staged Upload.
	HTTPMethod *StagedUploadHTTPMethodType `json:"httpMethod,omitempty"`
}

// Staged media target information.
type StagedMediaUploadTarget struct {
	// Parameters of the media to be uploaded.
	Parameters []*StagedUploadParameter `json:"parameters"`
	// The url to be passed as the original_source for the product create media mutation input.
	ResourceURL *string `json:"resourceUrl"`
	// Media URL.
	URL *string `json:"url"`
}

// Media to be uploaded.
type StagedUploadInput struct {
	// Media resource.
	Resource StagedUploadTargetGenerateUploadResource `json:"resource,omitempty"`
	// Media filename.
	Filename string `json:"filename,omitempty"`
	// Media MIME type.
	MimeType string `json:"mimeType,omitempty"`
	// HTTP method to be used by the Staged Upload.
	HTTPMethod *StagedUploadHTTPMethodType `json:"httpMethod,omitempty"`
	// Size of the file to upload, in bytes. This is required for VIDEO and MODEL_3D resources.
	FileSize *string `json:"fileSize,omitempty"`
}

// Upload parameter of a Media.
type StagedUploadParameter struct {
	// Parameter name.
	Name string `json:"name"`
	// Parameter value.
	Value string `json:"value"`
}

// Staged target information.
type StagedUploadTarget struct {
	// Parameters of an image to be uploaded.
	Parameters []*ImageUploadParameter `json:"parameters"`
	// Image URL.
	URL string `json:"url"`
}

// Specifies the fields required to generate the URL and parameters needed to upload an asset to Shopify.
type StagedUploadTargetGenerateInput struct {
	// The resource type being uploaded.
	Resource StagedUploadTargetGenerateUploadResource `json:"resource,omitempty"`
	// The filename of the asset being uploaded.
	Filename string `json:"filename,omitempty"`
	// The MIME type of the asset being uploaded.
	MimeType string `json:"mimeType,omitempty"`
	// The HTTP method to be used by the staged upload.
	HTTPMethod *StagedUploadHTTPMethodType `json:"httpMethod,omitempty"`
	// The size of the file to upload, in bytes.
	FileSize *string `json:"fileSize,omitempty"`
}

// Return type for `stagedUploadTargetGenerate` mutation.
type StagedUploadTargetGeneratePayload struct {
	// The signed parameters that can be used to upload the asset.
	Parameters []*MutationsStagedUploadTargetGenerateUploadParameter `json:"parameters"`
	// The signed URL where the asset can be uploaded.
	URL string `json:"url"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `stagedUploadTargetsGenerate` mutation.
type StagedUploadTargetsGeneratePayload struct {
	// The staged upload targets that were generated.
	Urls []*StagedUploadTarget `json:"urls"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `stagedUploadsCreate` mutation.
type StagedUploadsCreatePayload struct {
	// The staged upload targets that were generated.
	StagedTargets []*StagedMediaUploadTarget `json:"stagedTargets"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Token used to delegate unauthenticated access scopes to clients that need to access the unautheticated Storefront API.
//
type StorefrontAccessToken struct {
	// List of permissions associated with the token.
	AccessScopes []*AccessScope `json:"accessScopes"`
	// The issued public access token.
	AccessToken string `json:"accessToken"`
	// The date and time when the public access token was created.
	CreatedAt string `json:"createdAt"`
	// Globally unique identifier.
	ID string `json:"id"`
	// An arbitrary title for each token determined by the developer, used for reference         purposes.
	Title string `json:"title"`
	// The date and time when the storefront access token was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (StorefrontAccessToken) IsNode() {}

type StorefrontAccessTokenConnection struct {
	// A list of edges.
	Edges []*StorefrontAccessTokenEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `storefrontAccessTokenCreate` mutation.
type StorefrontAccessTokenCreatePayload struct {
	// The user's shop.
	Shop *Shop `json:"shop"`
	// The storefront access token.
	StorefrontAccessToken *StorefrontAccessToken `json:"storefrontAccessToken"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Specifies the input fields to delete a storefront access token.
type StorefrontAccessTokenDeleteInput struct {
	// The ID of the storefront access token to delete.
	ID string `json:"id,omitempty"`
}

// Return type for `storefrontAccessTokenDelete` mutation.
type StorefrontAccessTokenDeletePayload struct {
	// The ID of the deleted storefront access token.
	DeletedStorefrontAccessTokenID *string `json:"deletedStorefrontAccessTokenId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type StorefrontAccessTokenEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of StorefrontAccessTokenEdge.
	Node *StorefrontAccessToken `json:"node"`
}

// Specifies the input fields for a storefront access token.
type StorefrontAccessTokenInput struct {
	// A title for the storefront access token.
	Title string `json:"title,omitempty"`
}

type StringConnection struct {
	// A list of edges.
	Edges []*StringEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type StringEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of StringEdge.
	Node string `json:"node"`
}

// Represents a suggested transaction.
type SuggestedOrderTransaction struct {
	// The masked account number associated with the payment method.
	AccountNumber *string `json:"accountNumber"`
	// The amount of the transaction.
	Amount string `json:"amount"`
	// The amount on the order transaction in applicable currencies.
	AmountSet *MoneyBag `json:"amountSet"`
	// The human-readable payment gateway name used to process the transaction.
	FormattedGateway *string `json:"formattedGateway"`
	// The payment gateway used to process the transaction.
	Gateway *string `json:"gateway"`
	// Specifies the kind of the suggested order transaction.
	Kind SuggestedOrderTransactionKind `json:"kind"`
	// Specifies the available amount to refund on the gateway. Only available within SuggestedRefund.
	MaximumRefundable *string `json:"maximumRefundable"`
	// Specifies the available amount to refund on the gateway in shop and presentment currencies. Only available within SuggestedRefund.
	MaximumRefundableSet *MoneyBag `json:"maximumRefundableSet"`
	// The associated parent transaction, for example the authorization of a capture.
	ParentTransaction *OrderTransaction `json:"parentTransaction"`
}

// Represents the suggested refund to be submitted based on the items being returned.
type SuggestedRefund struct {
	// The total monetary value to be refunded.
	Amount string `json:"amount"`
	// The total monetary value to be refunded in shop and presentment currencies.
	AmountSet *MoneyBag `json:"amountSet"`
	// The sum of all the discounted prices of the line items being refunded.
	DiscountedSubtotalSet *MoneyBag `json:"discountedSubtotalSet"`
	// The total monetary value available to refund.
	MaximumRefundable string `json:"maximumRefundable"`
	// The total monetary value available to refund in shop and presentment currencies.
	MaximumRefundableSet *MoneyBag `json:"maximumRefundableSet"`
	// An array of duties that will be refunded to the customer.
	RefundDuties []*RefundDuty `json:"refundDuties"`
	// An array of line items that will be returned to the customer.
	RefundLineItems []*RefundLineItem `json:"refundLineItems"`
	// Refund details for shipping costs paid by customer.
	Shipping *ShippingRefund `json:"shipping"`
	// The sum of all the prices of the line items being refunded.
	Subtotal string `json:"subtotal"`
	// The sum of all the prices of the line items being refunded in shop and presentment currencies.
	SubtotalSet *MoneyBag `json:"subtotalSet"`
	// Array of SuggestedOrderTransaction items.
	SuggestedTransactions []*SuggestedOrderTransaction `json:"suggestedTransactions"`
	// The total cart discount amount that was applied to all line items in this refund.
	TotalCartDiscountAmountSet *MoneyBag `json:"totalCartDiscountAmountSet"`
	// The sum of all the duties being refunded from the order (must be positive) in shop and presentment currencies.
	TotalDutiesSet *MoneyBag `json:"totalDutiesSet"`
	// The sum of all the taxes being refunded from the order (must be positive) in shop and presentment currencies.
	TotalTaxSet *MoneyBag `json:"totalTaxSet"`
	// The sum of all the taxes being refunded from the order (must be positive).
	TotalTaxes string `json:"totalTaxes"`
}

// Return type for `tagsAdd` mutation.
type TagsAddPayload struct {
	// The object that was updated.
	Node Node `json:"node"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `tagsRemove` mutation.
type TagsRemovePayload struct {
	// The object that was updated.
	Node Node `json:"node"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Represents the information about the tax charged on the associated line item.
type TaxLine struct {
	// The amount of tax to be charged.
	Price string `json:"price"`
	// The amount of tax to be charged in shop and presentment currencies.
	PriceSet *MoneyBag `json:"priceSet"`
	// The tax rate to be applied.
	Rate *float64 `json:"rate"`
	// The percentage of the price that the tax rate represents.
	RatePercentage *float64 `json:"ratePercentage"`
	// The name of the tax.
	Title string `json:"title"`
}

// A tender transaction represents a transaction which modifies the shop's balance.
type TenderTransaction struct {
	// The amount and currency of the tender transaction.
	Amount *MoneyV2 `json:"amount"`
	// Globally unique identifier.
	ID string `json:"id"`
	// Information about the payment method used for this transaction.
	PaymentMethod *string `json:"paymentMethod"`
	// Date and time when the transaction was processed.
	ProcessedAt *string `json:"processedAt"`
	// The remote gateway reference associated with the tender transaction.
	RemoteReference *string `json:"remoteReference"`
	// Whether the transaction is a test transaction.
	Test bool `json:"test"`
	// Information about the payment instrument used for this transaction.
	TransactionDetails TenderTransactionDetails `json:"transactionDetails"`
}

func (TenderTransaction) IsNode() {}

type TenderTransactionConnection struct {
	// A list of edges.
	Edges []*TenderTransactionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Information about the credit card used for this transaction.
type TenderTransactionCreditCardDetails struct {
	// The name of the company that issued the customer's credit card.
	CreditCardCompany *string `json:"creditCardCompany"`
	// The customer's credit card number, with most of the leading digits redacted.
	CreditCardNumber *string `json:"creditCardNumber"`
}

func (TenderTransactionCreditCardDetails) IsTenderTransactionDetails() {}

type TenderTransactionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of TenderTransactionEdge.
	Node *TenderTransaction `json:"node"`
}

// Specifies the fields for tracking information.
type TrackingInfoInput struct {
	// The tracking number of the fulfillment.
	Number *string `json:"number,omitempty"`
	// The URL to track the fulfillment.
	URL *string `json:"url,omitempty"`
}

// Specifies all possible fields for updating tracking information.
type TrackingInfoUpdateInput struct {
	// Tracking information consisting of one or more tracking URLs and numbers associated with the fulfillment.
	//
	TrackingDetails []*TrackingInfoInput `json:"trackingDetails,omitempty"`
	// The name of the tracking company.
	TrackingCompany *string `json:"trackingCompany,omitempty"`
	// Indicates whether the customer will be notified of this update and future updates for this fulfillment.
	//
	NotifyCustomer *bool `json:"notifyCustomer,omitempty"`
}

// Translatable content of a resource's field.
type TranslatableContent struct {
	// Digest (hash) of the content.
	Digest *string `json:"digest"`
	// Content key.
	Key string `json:"key"`
	// Content locale.
	Locale string `json:"locale"`
	// Content value.
	Value *string `json:"value"`
}

// A resource that has translatable fields.
type TranslatableResource struct {
	// GID of the resource.
	ResourceID string `json:"resourceId"`
	// Translatable content.
	TranslatableContent []*TranslatableContent `json:"translatableContent"`
	// Translatable content translations.
	Translations []*Translation `json:"translations"`
}

type TranslatableResourceConnection struct {
	// A list of edges.
	Edges []*TranslatableResourceEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

type TranslatableResourceEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of TranslatableResourceEdge.
	Node *TranslatableResource `json:"node"`
}

// Translation of a field of a resource.
type Translation struct {
	// Translation key.
	Key string `json:"key"`
	// Translation locale.
	Locale string `json:"locale"`
	// Marked as outdated.
	Outdated bool `json:"outdated"`
	// Translation value.
	Value *string `json:"value"`
}

// Provides the fields and values to use when creating or updating a translation.
type TranslationInput struct {
	// The locale of the translation.
	Locale string `json:"locale,omitempty"`
	// The key of the translation.
	Key string `json:"key,omitempty"`
	// The value of the translation.
	Value string `json:"value,omitempty"`
	// The digest (hash) of the content being translated.
	TranslatableContentDigest string `json:"translatableContentDigest,omitempty"`
}

// Represents an error that happens during the execution of a translation mutation.
type TranslationUserError struct {
	// Error code to uniquely identify the error.
	Code *TranslationErrorCode `json:"code"`
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (TranslationUserError) IsDisplayableError() {}

// Return type for `translationsRegister` mutation.
type TranslationsRegisterPayload struct {
	// The translations that were created or updated.
	Translations []*Translation `json:"translations"`
	// List of errors that occurred executing the mutation.
	UserErrors []*TranslationUserError `json:"userErrors"`
}

// Return type for `translationsRemove` mutation.
type TranslationsRemovePayload struct {
	// The translations that were deleted.
	Translations []*Translation `json:"translations"`
	// List of errors that occurred executing the mutation.
	UserErrors []*TranslationUserError `json:"userErrors"`
}

// Specifies the
// [Urchin Traffic Module (UTM) parameters](https://en.wikipedia.org/wiki/UTM_parameters)
// that are associated with a related marketing campaign.
//
type UTMInput struct {
	// The name of the UTM campaign.
	Campaign string `json:"campaign,omitempty"`
	// The name of the website or application where the referral link exists.
	Source string `json:"source,omitempty"`
	// The UTM campaign medium.
	Medium string `json:"medium,omitempty"`
}

// Represents a set of UTM parameters.
type UTMParameters struct {
	// The name of a marketing campaign.
	Campaign *string `json:"campaign"`
	// Identifies specific content in a marketing campaign. Used to differentiate between similar content or links in a marketing campaign to determine which is the most effective.
	Content *string `json:"content"`
	// The medium of a marketing campaign, such as a banner or email newsletter.
	Medium *string `json:"medium"`
	// The source of traffic to the merchant's store, such as Google or an email newsletter.
	Source *string `json:"source"`
	// Paid search terms used by a marketing campaign.
	Term *string `json:"term"`
}

// Specifies the input fields required to update a media object.
type UpdateMediaInput struct {
	// Specifies the media to update.
	ID string `json:"id,omitempty"`
	// The source from which to update the media preview image. May be an external URL or signed upload URL.
	PreviewImageSource *string `json:"previewImageSource,omitempty"`
	// The alt text associated to the media.
	Alt *string `json:"alt,omitempty"`
}

// Represents an error in the input of a mutation.
type UserError struct {
	// Path to the input field which caused the error.
	Field []string `json:"field"`
	// The error message.
	Message string `json:"message"`
}

func (UserError) IsDisplayableError() {}

// Represents a Shopify hosted video.
//
type Video struct {
	// A word or phrase to share the nature or contents of a media.
	Alt *string `json:"alt"`
	// The filename of the video.
	Filename string `json:"filename"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The media content type.
	MediaContentType MediaContentType `json:"mediaContentType"`
	// Any errors which have occurred on the media.
	MediaErrors []*MediaError `json:"mediaErrors"`
	// The original source for a video.
	OriginalSource *VideoSource `json:"originalSource"`
	// The preview image for the media.
	Preview *MediaPreviewImage `json:"preview"`
	// The sources for a video.
	Sources []*VideoSource `json:"sources"`
	// Current status of the media.
	Status MediaStatus `json:"status"`
}

func (Video) IsNode()  {}
func (Video) IsMedia() {}

// Represents a source for a Shopify hosted video.
//
type VideoSource struct {
	// The format of the video source.
	Format string `json:"format"`
	// The height of the video.
	Height int64 `json:"height"`
	// The video MIME type.
	MimeType string `json:"mimeType"`
	// The URL of the video.
	URL string `json:"url"`
	// The width of the video.
	Width int64 `json:"width"`
}

// Amazon EventBridge event source.
type WebhookEventBridgeEndpoint struct {
	// ARN of this EventBridge event source.
	Arn string `json:"arn"`
}

func (WebhookEventBridgeEndpoint) IsWebhookSubscriptionEndpoint() {}

// HTTP endpoint where POST requests will be made to.
type WebhookHTTPEndpoint struct {
	// URL of webhook endpoint to deliver webhooks to.
	CallbackURL string `json:"callbackUrl"`
}

func (WebhookHTTPEndpoint) IsWebhookSubscriptionEndpoint() {}

// Represents a subscription to a webhook.
//
type WebhookSubscription struct {
	// URL where the webhook subscription should send the POST request when the event occurs.
	CallbackURL string `json:"callbackUrl"`
	// The date and time when the webhook subscription was created.
	CreatedAt string `json:"createdAt"`
	// Endpoint where webhooks will be delivered to.
	Endpoint WebhookSubscriptionEndpoint `json:"endpoint"`
	// The format in which the webhook subscription should send the data.
	Format WebhookSubscriptionFormat `json:"format"`
	// Globally unique identifier.
	ID string `json:"id"`
	// The list of fields to be included in the webhook subscription.
	IncludeFields []string `json:"includeFields"`
	// The ID of the corresponding resource in the REST Admin API.
	LegacyResourceID string `json:"legacyResourceId"`
	// The list of namespaces for any metafields that should be included in the webhook subscription.
	MetafieldNamespaces []string `json:"metafieldNamespaces"`
	// The type of event that triggers the webhook.
	Topic WebhookSubscriptionTopic `json:"topic"`
	// The date and time when the webhook subscription was updated.
	UpdatedAt string `json:"updatedAt"`
}

func (WebhookSubscription) IsNode()                   {}
func (WebhookSubscription) IsLegacyInteroperability() {}

type WebhookSubscriptionConnection struct {
	// A list of edges.
	Edges []*WebhookSubscriptionEdge `json:"edges"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Return type for `webhookSubscriptionCreate` mutation.
type WebhookSubscriptionCreatePayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
	// The webhook subscription that was created.
	WebhookSubscription *WebhookSubscription `json:"webhookSubscription"`
}

// Return type for `webhookSubscriptionDelete` mutation.
type WebhookSubscriptionDeletePayload struct {
	// The ID of the deleted webhook subscription.
	DeletedWebhookSubscriptionID *string `json:"deletedWebhookSubscriptionId"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

type WebhookSubscriptionEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The item at the end of WebhookSubscriptionEdge.
	Node *WebhookSubscription `json:"node"`
}

// Specifies the input fields for a webhook subscription.
//
type WebhookSubscriptionInput struct {
	// URL where the webhook subscription should send the POST request when the event occurs.
	CallbackURL *string `json:"callbackUrl,omitempty"`
	// The format in which the webhook subscription should send the data.
	Format *WebhookSubscriptionFormat `json:"format,omitempty"`
	// The list of fields to be included in the webhook subscription.
	IncludeFields []string `json:"includeFields,omitempty"`
	// The list of namespaces for any metafields that should be included in the webhook subscription.
	MetafieldNamespaces []string `json:"metafieldNamespaces,omitempty"`
}

// Return type for `webhookSubscriptionUpdate` mutation.
type WebhookSubscriptionUpdatePayload struct {
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
	// The webhook subscription that was updated.
	WebhookSubscription *WebhookSubscription `json:"webhookSubscription"`
}

// Represents weight unit and value.
type Weight struct {
	// Unit of measurement for `value`.
	Unit WeightUnit `json:"unit"`
	// The weight using the unit system specified with `unit`.
	Value float64 `json:"value"`
}

func (Weight) IsDeliveryConditionCriteria() {}

// Specifies the weight unit and value inputs.
//
type WeightInput struct {
	// The weight value using the unit system specified with `weight_unit`.
	Value float64 `json:"value,omitempty"`
	// Unit of measurement for `value`.
	Unit WeightUnit `json:"unit,omitempty"`
}

// Return type for `deliveryProfileCreate` mutation.
type DeliveryProfileCreatePayload struct {
	// The delivery profile that was created.
	Profile *DeliveryProfile `json:"profile"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `deliveryProfileRemove` mutation.
type DeliveryProfileRemovePayload struct {
	// The profile deletion job triggered by the mutation.
	Job *Job `json:"job"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Return type for `deliveryProfileUpdate` mutation.
type DeliveryProfileUpdatePayload struct {
	// The delivery profile that was updated.
	Profile *DeliveryProfile `json:"profile"`
	// List of errors that occurred executing the mutation.
	UserErrors []*UserError `json:"userErrors"`
}

// Possible categories of an app installation.
type AppInstallationCategory string

const (
	// Sales channel apps.
	AppInstallationCategoryChannel AppInstallationCategory = "CHANNEL"
	// Apps that can be used in the POS mobile client.
	AppInstallationCategoryPosEmbedded AppInstallationCategory = "POS_EMBEDDED"
)

var AllAppInstallationCategory = []AppInstallationCategory{
	AppInstallationCategoryChannel,
	AppInstallationCategoryPosEmbedded,
}

func (e AppInstallationCategory) IsValid() bool {
	switch e {
	case AppInstallationCategoryChannel, AppInstallationCategoryPosEmbedded:
		return true
	}
	return false
}

func (e AppInstallationCategory) String() string {
	return string(e)
}

func (e *AppInstallationCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppInstallationCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppInstallationCategory", str)
	}
	return nil
}

func (e AppInstallationCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible privacy types of an app installation.
type AppInstallationPrivacy string

const (
	AppInstallationPrivacyPublic  AppInstallationPrivacy = "PUBLIC"
	AppInstallationPrivacyPrivate AppInstallationPrivacy = "PRIVATE"
)

var AllAppInstallationPrivacy = []AppInstallationPrivacy{
	AppInstallationPrivacyPublic,
	AppInstallationPrivacyPrivate,
}

func (e AppInstallationPrivacy) IsValid() bool {
	switch e {
	case AppInstallationPrivacyPublic, AppInstallationPrivacyPrivate:
		return true
	}
	return false
}

func (e AppInstallationPrivacy) String() string {
	return string(e)
}

func (e *AppInstallationPrivacy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppInstallationPrivacy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppInstallationPrivacy", str)
	}
	return nil
}

func (e AppInstallationPrivacy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the AppInstallation query.
type AppInstallationSortKeys string

const (
	// Sort by the `installed_at` value.
	AppInstallationSortKeysInstalledAt AppInstallationSortKeys = "INSTALLED_AT"
	// Sort by the `app_title` value.
	AppInstallationSortKeysAppTitle AppInstallationSortKeys = "APP_TITLE"
	// Sort by the `id` value.
	AppInstallationSortKeysID AppInstallationSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	AppInstallationSortKeysRelevance AppInstallationSortKeys = "RELEVANCE"
)

var AllAppInstallationSortKeys = []AppInstallationSortKeys{
	AppInstallationSortKeysInstalledAt,
	AppInstallationSortKeysAppTitle,
	AppInstallationSortKeysID,
	AppInstallationSortKeysRelevance,
}

func (e AppInstallationSortKeys) IsValid() bool {
	switch e {
	case AppInstallationSortKeysInstalledAt, AppInstallationSortKeysAppTitle, AppInstallationSortKeysID, AppInstallationSortKeysRelevance:
		return true
	}
	return false
}

func (e AppInstallationSortKeys) String() string {
	return string(e)
}

func (e *AppInstallationSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppInstallationSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppInstallationSortKeys", str)
	}
	return nil
}

func (e AppInstallationSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The billing frequency for the app.
type AppPricingInterval string

const (
	// The merchant is billed for this app annually.
	AppPricingIntervalAnnual AppPricingInterval = "ANNUAL"
	// The merchant is billed for this app every 30 days.
	AppPricingIntervalEvery30Days AppPricingInterval = "EVERY_30_DAYS"
)

var AllAppPricingInterval = []AppPricingInterval{
	AppPricingIntervalAnnual,
	AppPricingIntervalEvery30Days,
}

func (e AppPricingInterval) IsValid() bool {
	switch e {
	case AppPricingIntervalAnnual, AppPricingIntervalEvery30Days:
		return true
	}
	return false
}

func (e AppPricingInterval) String() string {
	return string(e)
}

func (e *AppPricingInterval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppPricingInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppPricingInterval", str)
	}
	return nil
}

func (e AppPricingInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the purchase.
type AppPurchaseStatus string

const (
	// The app purchase has been approved by the merchant and is ready to be activated by the app. App purchases created through the GraphQL Admin API are activated upon approval.
	AppPurchaseStatusAccepted AppPurchaseStatus = "ACCEPTED"
	// The app purchase has been activated by the app. Active app purchases are charged to the store and partners receive payouts for active app purchase.
	AppPurchaseStatusActive AppPurchaseStatus = "ACTIVE"
	// The app purchase was declined by the merchant.
	AppPurchaseStatusDeclined AppPurchaseStatus = "DECLINED"
	// The app purchase was not accepted within 2 days of being created.
	AppPurchaseStatusExpired AppPurchaseStatus = "EXPIRED"
	// The app purchase is pending approval by the merchant.
	AppPurchaseStatusPending AppPurchaseStatus = "PENDING"
)

var AllAppPurchaseStatus = []AppPurchaseStatus{
	AppPurchaseStatusAccepted,
	AppPurchaseStatusActive,
	AppPurchaseStatusDeclined,
	AppPurchaseStatusExpired,
	AppPurchaseStatusPending,
}

func (e AppPurchaseStatus) IsValid() bool {
	switch e {
	case AppPurchaseStatusAccepted, AppPurchaseStatusActive, AppPurchaseStatusDeclined, AppPurchaseStatusExpired, AppPurchaseStatusPending:
		return true
	}
	return false
}

func (e AppPurchaseStatus) String() string {
	return string(e)
}

func (e *AppPurchaseStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppPurchaseStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppPurchaseStatus", str)
	}
	return nil
}

func (e AppPurchaseStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the AppSubscription query.
type AppSubscriptionSortKeys string

const (
	// Sort by the `created_at` value.
	AppSubscriptionSortKeysCreatedAt AppSubscriptionSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	AppSubscriptionSortKeysID AppSubscriptionSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	AppSubscriptionSortKeysRelevance AppSubscriptionSortKeys = "RELEVANCE"
)

var AllAppSubscriptionSortKeys = []AppSubscriptionSortKeys{
	AppSubscriptionSortKeysCreatedAt,
	AppSubscriptionSortKeysID,
	AppSubscriptionSortKeysRelevance,
}

func (e AppSubscriptionSortKeys) IsValid() bool {
	switch e {
	case AppSubscriptionSortKeysCreatedAt, AppSubscriptionSortKeysID, AppSubscriptionSortKeysRelevance:
		return true
	}
	return false
}

func (e AppSubscriptionSortKeys) String() string {
	return string(e)
}

func (e *AppSubscriptionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppSubscriptionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppSubscriptionSortKeys", str)
	}
	return nil
}

func (e AppSubscriptionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the app subscription.
type AppSubscriptionStatus string

const (
	// The app subscription is pending approval by the merchant.
	AppSubscriptionStatusPending AppSubscriptionStatus = "PENDING"
	// The app subscription has been approved by the merchant and is ready to be activated by the app. App subscriptions created through the GraphQL Admin API are activated upon approval.
	AppSubscriptionStatusAccepted AppSubscriptionStatus = "ACCEPTED"
	// The app subscription has been activated by the app. Active app subscriptions are charged to the store and partners recieve payouts for active app subscriptions.
	AppSubscriptionStatusActive AppSubscriptionStatus = "ACTIVE"
	// The app subscription was declined by the merchant.
	AppSubscriptionStatusDeclined AppSubscriptionStatus = "DECLINED"
	// The app subscription was not accepted within 2 days of being created.
	AppSubscriptionStatusExpired AppSubscriptionStatus = "EXPIRED"
	// The app subscription is on hold due to a store subscription non-payment. The charge will re-activate once subscription payments resume.
	AppSubscriptionStatusFrozen AppSubscriptionStatus = "FROZEN"
	// The app subscription was cancelled by the app.
	AppSubscriptionStatusCancelled AppSubscriptionStatus = "CANCELLED"
)

var AllAppSubscriptionStatus = []AppSubscriptionStatus{
	AppSubscriptionStatusPending,
	AppSubscriptionStatusAccepted,
	AppSubscriptionStatusActive,
	AppSubscriptionStatusDeclined,
	AppSubscriptionStatusExpired,
	AppSubscriptionStatusFrozen,
	AppSubscriptionStatusCancelled,
}

func (e AppSubscriptionStatus) IsValid() bool {
	switch e {
	case AppSubscriptionStatusPending, AppSubscriptionStatusAccepted, AppSubscriptionStatusActive, AppSubscriptionStatusDeclined, AppSubscriptionStatusExpired, AppSubscriptionStatusFrozen, AppSubscriptionStatusCancelled:
		return true
	}
	return false
}

func (e AppSubscriptionStatus) String() string {
	return string(e)
}

func (e *AppSubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppSubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppSubscriptionStatus", str)
	}
	return nil
}

func (e AppSubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the AppTransaction query.
type AppTransactionSortKeys string

const (
	// Sort by the `created_at` value.
	AppTransactionSortKeysCreatedAt AppTransactionSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	AppTransactionSortKeysID AppTransactionSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	AppTransactionSortKeysRelevance AppTransactionSortKeys = "RELEVANCE"
)

var AllAppTransactionSortKeys = []AppTransactionSortKeys{
	AppTransactionSortKeysCreatedAt,
	AppTransactionSortKeysID,
	AppTransactionSortKeysRelevance,
}

func (e AppTransactionSortKeys) IsValid() bool {
	switch e {
	case AppTransactionSortKeysCreatedAt, AppTransactionSortKeysID, AppTransactionSortKeysRelevance:
		return true
	}
	return false
}

func (e AppTransactionSortKeys) String() string {
	return string(e)
}

func (e *AppTransactionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppTransactionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppTransactionSortKeys", str)
	}
	return nil
}

func (e AppTransactionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the AppUsageRecord query.
type AppUsageRecordSortKeys string

const (
	// Sort by the `created_at` value.
	AppUsageRecordSortKeysCreatedAt AppUsageRecordSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	AppUsageRecordSortKeysID AppUsageRecordSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	AppUsageRecordSortKeysRelevance AppUsageRecordSortKeys = "RELEVANCE"
)

var AllAppUsageRecordSortKeys = []AppUsageRecordSortKeys{
	AppUsageRecordSortKeysCreatedAt,
	AppUsageRecordSortKeysID,
	AppUsageRecordSortKeysRelevance,
}

func (e AppUsageRecordSortKeys) IsValid() bool {
	switch e {
	case AppUsageRecordSortKeysCreatedAt, AppUsageRecordSortKeysID, AppUsageRecordSortKeysRelevance:
		return true
	}
	return false
}

func (e AppUsageRecordSortKeys) String() string {
	return string(e)
}

func (e *AppUsageRecordSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppUsageRecordSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppUsageRecordSortKeys", str)
	}
	return nil
}

func (e AppUsageRecordSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the AutomaticDiscount query.
type AutomaticDiscountSortKeys string

const (
	// Sort by the `created_at` value.
	AutomaticDiscountSortKeysCreatedAt AutomaticDiscountSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	AutomaticDiscountSortKeysID AutomaticDiscountSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	AutomaticDiscountSortKeysRelevance AutomaticDiscountSortKeys = "RELEVANCE"
)

var AllAutomaticDiscountSortKeys = []AutomaticDiscountSortKeys{
	AutomaticDiscountSortKeysCreatedAt,
	AutomaticDiscountSortKeysID,
	AutomaticDiscountSortKeysRelevance,
}

func (e AutomaticDiscountSortKeys) IsValid() bool {
	switch e {
	case AutomaticDiscountSortKeysCreatedAt, AutomaticDiscountSortKeysID, AutomaticDiscountSortKeysRelevance:
		return true
	}
	return false
}

func (e AutomaticDiscountSortKeys) String() string {
	return string(e)
}

func (e *AutomaticDiscountSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AutomaticDiscountSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AutomaticDiscountSortKeys", str)
	}
	return nil
}

func (e AutomaticDiscountSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes for failed bulk operations.
type BulkOperationErrorCode string

const (
	// The provided operation `query` returned access denied due to missing
	// [access scopes](https://help.shopify.com/api/getting-started/authentication/oauth/scopes).
	// Review the requested object permissions and execute the query as a normal non-bulk GraphQL request to see more details.
	//
	BulkOperationErrorCodeAccessDenied BulkOperationErrorCode = "ACCESS_DENIED"
	// Operation resulted in partial or incomplete data due to internal server errors during execution.
	//
	BulkOperationErrorCodeInternalServerError BulkOperationErrorCode = "INTERNAL_SERVER_ERROR"
	// Operation resulted in partial or incomplete data due to query timeouts during execution.
	// In some cases, timeouts can be avoided by modifying your `query` to select fewer fields.
	//
	BulkOperationErrorCodeTimeout BulkOperationErrorCode = "TIMEOUT"
)

var AllBulkOperationErrorCode = []BulkOperationErrorCode{
	BulkOperationErrorCodeAccessDenied,
	BulkOperationErrorCodeInternalServerError,
	BulkOperationErrorCodeTimeout,
}

func (e BulkOperationErrorCode) IsValid() bool {
	switch e {
	case BulkOperationErrorCodeAccessDenied, BulkOperationErrorCodeInternalServerError, BulkOperationErrorCodeTimeout:
		return true
	}
	return false
}

func (e BulkOperationErrorCode) String() string {
	return string(e)
}

func (e *BulkOperationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BulkOperationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BulkOperationErrorCode", str)
	}
	return nil
}

func (e BulkOperationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Statuses of a bulk operation.
type BulkOperationStatus string

const (
	// Operation created.
	BulkOperationStatusCreated BulkOperationStatus = "CREATED"
	// Operation running.
	BulkOperationStatusRunning BulkOperationStatus = "RUNNING"
	// Operation completed.
	BulkOperationStatusCompleted BulkOperationStatus = "COMPLETED"
	// Operation canceling.
	BulkOperationStatusCanceling BulkOperationStatus = "CANCELING"
	// Operation canceled.
	BulkOperationStatusCanceled BulkOperationStatus = "CANCELED"
	// Operation failed.
	BulkOperationStatusFailed BulkOperationStatus = "FAILED"
	// Operation URL has expired.
	BulkOperationStatusExpired BulkOperationStatus = "EXPIRED"
)

var AllBulkOperationStatus = []BulkOperationStatus{
	BulkOperationStatusCreated,
	BulkOperationStatusRunning,
	BulkOperationStatusCompleted,
	BulkOperationStatusCanceling,
	BulkOperationStatusCanceled,
	BulkOperationStatusFailed,
	BulkOperationStatusExpired,
}

func (e BulkOperationStatus) IsValid() bool {
	switch e {
	case BulkOperationStatusCreated, BulkOperationStatusRunning, BulkOperationStatusCompleted, BulkOperationStatusCanceling, BulkOperationStatusCanceled, BulkOperationStatusFailed, BulkOperationStatusExpired:
		return true
	}
	return false
}

func (e BulkOperationStatus) String() string {
	return string(e)
}

func (e *BulkOperationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BulkOperationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BulkOperationStatus", str)
	}
	return nil
}

func (e BulkOperationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the CodeDiscount query.
type CodeDiscountSortKeys string

const (
	// Sort by the `starts_at` value.
	CodeDiscountSortKeysStartsAt CodeDiscountSortKeys = "STARTS_AT"
	// Sort by the `ends_at` value.
	CodeDiscountSortKeysEndsAt CodeDiscountSortKeys = "ENDS_AT"
	// Sort by the `title` value.
	CodeDiscountSortKeysTitle CodeDiscountSortKeys = "TITLE"
	// Sort by the `created_at` value.
	CodeDiscountSortKeysCreatedAt CodeDiscountSortKeys = "CREATED_AT"
	// Sort by the `updated_at` value.
	CodeDiscountSortKeysUpdatedAt CodeDiscountSortKeys = "UPDATED_AT"
	// Sort by the `id` value.
	CodeDiscountSortKeysID CodeDiscountSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	CodeDiscountSortKeysRelevance CodeDiscountSortKeys = "RELEVANCE"
)

var AllCodeDiscountSortKeys = []CodeDiscountSortKeys{
	CodeDiscountSortKeysStartsAt,
	CodeDiscountSortKeysEndsAt,
	CodeDiscountSortKeysTitle,
	CodeDiscountSortKeysCreatedAt,
	CodeDiscountSortKeysUpdatedAt,
	CodeDiscountSortKeysID,
	CodeDiscountSortKeysRelevance,
}

func (e CodeDiscountSortKeys) IsValid() bool {
	switch e {
	case CodeDiscountSortKeysStartsAt, CodeDiscountSortKeysEndsAt, CodeDiscountSortKeysTitle, CodeDiscountSortKeysCreatedAt, CodeDiscountSortKeysUpdatedAt, CodeDiscountSortKeysID, CodeDiscountSortKeysRelevance:
		return true
	}
	return false
}

func (e CodeDiscountSortKeys) String() string {
	return string(e)
}

func (e *CodeDiscountSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CodeDiscountSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CodeDiscountSortKeys", str)
	}
	return nil
}

func (e CodeDiscountSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the property of a product being used to populate the smart collection.
type CollectionRuleColumn string

const (
	// The `tag` attribute.
	CollectionRuleColumnTag CollectionRuleColumn = "TAG"
	// The `title` attribute.
	CollectionRuleColumnTitle CollectionRuleColumn = "TITLE"
	// The `type` attribute.
	CollectionRuleColumnType CollectionRuleColumn = "TYPE"
	// The `vendor` attribute.
	CollectionRuleColumnVendor CollectionRuleColumn = "VENDOR"
	// The `variant_price` attribute.
	CollectionRuleColumnVariantPrice CollectionRuleColumn = "VARIANT_PRICE"
	// The `is_price_reduced` attribute.
	CollectionRuleColumnIsPriceReduced CollectionRuleColumn = "IS_PRICE_REDUCED"
	// The `variant_compare_at_price` attribute.
	CollectionRuleColumnVariantCompareAtPrice CollectionRuleColumn = "VARIANT_COMPARE_AT_PRICE"
	// The `variant_weight` attribute.
	CollectionRuleColumnVariantWeight CollectionRuleColumn = "VARIANT_WEIGHT"
	// The `variant_inventory` attribute.
	CollectionRuleColumnVariantInventory CollectionRuleColumn = "VARIANT_INVENTORY"
	// The `variant_title` attribute.
	CollectionRuleColumnVariantTitle CollectionRuleColumn = "VARIANT_TITLE"
)

var AllCollectionRuleColumn = []CollectionRuleColumn{
	CollectionRuleColumnTag,
	CollectionRuleColumnTitle,
	CollectionRuleColumnType,
	CollectionRuleColumnVendor,
	CollectionRuleColumnVariantPrice,
	CollectionRuleColumnIsPriceReduced,
	CollectionRuleColumnVariantCompareAtPrice,
	CollectionRuleColumnVariantWeight,
	CollectionRuleColumnVariantInventory,
	CollectionRuleColumnVariantTitle,
}

func (e CollectionRuleColumn) IsValid() bool {
	switch e {
	case CollectionRuleColumnTag, CollectionRuleColumnTitle, CollectionRuleColumnType, CollectionRuleColumnVendor, CollectionRuleColumnVariantPrice, CollectionRuleColumnIsPriceReduced, CollectionRuleColumnVariantCompareAtPrice, CollectionRuleColumnVariantWeight, CollectionRuleColumnVariantInventory, CollectionRuleColumnVariantTitle:
		return true
	}
	return false
}

func (e CollectionRuleColumn) String() string {
	return string(e)
}

func (e *CollectionRuleColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionRuleColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionRuleColumn", str)
	}
	return nil
}

func (e CollectionRuleColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the relationship between the `column` and the condition.
type CollectionRuleRelation string

const (
	// The attribute contains the condition.
	CollectionRuleRelationContains CollectionRuleRelation = "CONTAINS"
	// The attribute ends with the condition.
	CollectionRuleRelationEndsWith CollectionRuleRelation = "ENDS_WITH"
	// The attribute is equal to the condition.
	CollectionRuleRelationEquals CollectionRuleRelation = "EQUALS"
	// The attribute is greater than the condition.
	CollectionRuleRelationGreaterThan CollectionRuleRelation = "GREATER_THAN"
	// The attribute is not set.
	CollectionRuleRelationIsNotSet CollectionRuleRelation = "IS_NOT_SET"
	// The attribute is set.
	CollectionRuleRelationIsSet CollectionRuleRelation = "IS_SET"
	// The attribute is less than the condition.
	CollectionRuleRelationLessThan CollectionRuleRelation = "LESS_THAN"
	// The attribute does not contain the condition.
	CollectionRuleRelationNotContains CollectionRuleRelation = "NOT_CONTAINS"
	// The attribute does not equal the condition.
	CollectionRuleRelationNotEquals CollectionRuleRelation = "NOT_EQUALS"
	// The attribute starts with the condition.
	CollectionRuleRelationStartsWith CollectionRuleRelation = "STARTS_WITH"
)

var AllCollectionRuleRelation = []CollectionRuleRelation{
	CollectionRuleRelationContains,
	CollectionRuleRelationEndsWith,
	CollectionRuleRelationEquals,
	CollectionRuleRelationGreaterThan,
	CollectionRuleRelationIsNotSet,
	CollectionRuleRelationIsSet,
	CollectionRuleRelationLessThan,
	CollectionRuleRelationNotContains,
	CollectionRuleRelationNotEquals,
	CollectionRuleRelationStartsWith,
}

func (e CollectionRuleRelation) IsValid() bool {
	switch e {
	case CollectionRuleRelationContains, CollectionRuleRelationEndsWith, CollectionRuleRelationEquals, CollectionRuleRelationGreaterThan, CollectionRuleRelationIsNotSet, CollectionRuleRelationIsSet, CollectionRuleRelationLessThan, CollectionRuleRelationNotContains, CollectionRuleRelationNotEquals, CollectionRuleRelationStartsWith:
		return true
	}
	return false
}

func (e CollectionRuleRelation) String() string {
	return string(e)
}

func (e *CollectionRuleRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionRuleRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionRuleRelation", str)
	}
	return nil
}

func (e CollectionRuleRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Collection query.
type CollectionSortKeys string

const (
	// Sort by the `title` value.
	CollectionSortKeysTitle CollectionSortKeys = "TITLE"
	// Sort by the `updated_at` value.
	CollectionSortKeysUpdatedAt CollectionSortKeys = "UPDATED_AT"
	// Sort by the `id` value.
	CollectionSortKeysID CollectionSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	CollectionSortKeysRelevance CollectionSortKeys = "RELEVANCE"
)

var AllCollectionSortKeys = []CollectionSortKeys{
	CollectionSortKeysTitle,
	CollectionSortKeysUpdatedAt,
	CollectionSortKeysID,
	CollectionSortKeysRelevance,
}

func (e CollectionSortKeys) IsValid() bool {
	switch e {
	case CollectionSortKeysTitle, CollectionSortKeysUpdatedAt, CollectionSortKeysID, CollectionSortKeysRelevance:
		return true
	}
	return false
}

func (e CollectionSortKeys) String() string {
	return string(e)
}

func (e *CollectionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionSortKeys", str)
	}
	return nil
}

func (e CollectionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the sort order for the products in the collection.
type CollectionSortOrder string

const (
	// Alphabetically, in ascending order (A - Z).
	CollectionSortOrderAlphaAsc CollectionSortOrder = "ALPHA_ASC"
	// Alphabetically, in descending order (Z - A).
	CollectionSortOrderAlphaDesc CollectionSortOrder = "ALPHA_DESC"
	// By best-selling products.
	CollectionSortOrderBestSelling CollectionSortOrder = "BEST_SELLING"
	// By date created, in ascending order (oldest - newest).
	CollectionSortOrderCreated CollectionSortOrder = "CREATED"
	// By date created, in descending order (newest - oldest).
	CollectionSortOrderCreatedDesc CollectionSortOrder = "CREATED_DESC"
	// In the order set manually by the merchant.
	CollectionSortOrderManual CollectionSortOrder = "MANUAL"
	// By price, in ascending order (lowest - highest).
	CollectionSortOrderPriceAsc CollectionSortOrder = "PRICE_ASC"
	// By price, in descending order (highest - lowest).
	CollectionSortOrderPriceDesc CollectionSortOrder = "PRICE_DESC"
)

var AllCollectionSortOrder = []CollectionSortOrder{
	CollectionSortOrderAlphaAsc,
	CollectionSortOrderAlphaDesc,
	CollectionSortOrderBestSelling,
	CollectionSortOrderCreated,
	CollectionSortOrderCreatedDesc,
	CollectionSortOrderManual,
	CollectionSortOrderPriceAsc,
	CollectionSortOrderPriceDesc,
}

func (e CollectionSortOrder) IsValid() bool {
	switch e {
	case CollectionSortOrderAlphaAsc, CollectionSortOrderAlphaDesc, CollectionSortOrderBestSelling, CollectionSortOrderCreated, CollectionSortOrderCreatedDesc, CollectionSortOrderManual, CollectionSortOrderPriceAsc, CollectionSortOrderPriceDesc:
		return true
	}
	return false
}

func (e CollectionSortOrder) String() string {
	return string(e)
}

func (e *CollectionSortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CollectionSortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CollectionSortOrder", str)
	}
	return nil
}

func (e CollectionSortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ISO 3166-1 alpha-2 country codes with some differences.
type CountryCode string

const (
	// Afghanistan.
	CountryCodeAf CountryCode = "AF"
	// Åland Islands.
	CountryCodeAx CountryCode = "AX"
	// Albania.
	CountryCodeAl CountryCode = "AL"
	// Algeria.
	CountryCodeDz CountryCode = "DZ"
	// Andorra.
	CountryCodeAd CountryCode = "AD"
	// Angola.
	CountryCodeAo CountryCode = "AO"
	// Anguilla.
	CountryCodeAi CountryCode = "AI"
	// Antigua & Barbuda.
	CountryCodeAg CountryCode = "AG"
	// Argentina.
	CountryCodeAr CountryCode = "AR"
	// Armenia.
	CountryCodeAm CountryCode = "AM"
	// Aruba.
	CountryCodeAw CountryCode = "AW"
	// Australia.
	CountryCodeAu CountryCode = "AU"
	// Austria.
	CountryCodeAt CountryCode = "AT"
	// Azerbaijan.
	CountryCodeAz CountryCode = "AZ"
	// Bahamas.
	CountryCodeBs CountryCode = "BS"
	// Bahrain.
	CountryCodeBh CountryCode = "BH"
	// Bangladesh.
	CountryCodeBd CountryCode = "BD"
	// Barbados.
	CountryCodeBb CountryCode = "BB"
	// Belarus.
	CountryCodeBy CountryCode = "BY"
	// Belgium.
	CountryCodeBe CountryCode = "BE"
	// Belize.
	CountryCodeBz CountryCode = "BZ"
	// Benin.
	CountryCodeBj CountryCode = "BJ"
	// Bermuda.
	CountryCodeBm CountryCode = "BM"
	// Bhutan.
	CountryCodeBt CountryCode = "BT"
	// Bolivia.
	CountryCodeBo CountryCode = "BO"
	// Bosnia & Herzegovina.
	CountryCodeBa CountryCode = "BA"
	// Botswana.
	CountryCodeBw CountryCode = "BW"
	// Bouvet Island.
	CountryCodeBv CountryCode = "BV"
	// Brazil.
	CountryCodeBr CountryCode = "BR"
	// British Indian Ocean Territory.
	CountryCodeIo CountryCode = "IO"
	// Brunei.
	CountryCodeBn CountryCode = "BN"
	// Bulgaria.
	CountryCodeBg CountryCode = "BG"
	// Burkina Faso.
	CountryCodeBf CountryCode = "BF"
	// Burundi.
	CountryCodeBi CountryCode = "BI"
	// Cambodia.
	CountryCodeKh CountryCode = "KH"
	// Canada.
	CountryCodeCa CountryCode = "CA"
	// Cape Verde.
	CountryCodeCv CountryCode = "CV"
	// Caribbean Netherlands.
	CountryCodeBq CountryCode = "BQ"
	// Cayman Islands.
	CountryCodeKy CountryCode = "KY"
	// Central African Republic.
	CountryCodeCf CountryCode = "CF"
	// Chad.
	CountryCodeTd CountryCode = "TD"
	// Chile.
	CountryCodeCl CountryCode = "CL"
	// China.
	CountryCodeCn CountryCode = "CN"
	// Christmas Island.
	CountryCodeCx CountryCode = "CX"
	// Cocos (Keeling) Islands.
	CountryCodeCc CountryCode = "CC"
	// Colombia.
	CountryCodeCo CountryCode = "CO"
	// Comoros.
	CountryCodeKm CountryCode = "KM"
	// Congo - Brazzaville.
	CountryCodeCg CountryCode = "CG"
	// Congo - Kinshasa.
	CountryCodeCd CountryCode = "CD"
	// Cook Islands.
	CountryCodeCk CountryCode = "CK"
	// Costa Rica.
	CountryCodeCr CountryCode = "CR"
	// Croatia.
	CountryCodeHr CountryCode = "HR"
	// Cuba.
	CountryCodeCu CountryCode = "CU"
	// Curaçao.
	CountryCodeCw CountryCode = "CW"
	// Cyprus.
	CountryCodeCy CountryCode = "CY"
	// Czechia.
	CountryCodeCz CountryCode = "CZ"
	// Côte d’Ivoire.
	CountryCodeCi CountryCode = "CI"
	// Denmark.
	CountryCodeDk CountryCode = "DK"
	// Djibouti.
	CountryCodeDj CountryCode = "DJ"
	// Dominica.
	CountryCodeDm CountryCode = "DM"
	// Dominican Republic.
	CountryCodeDo CountryCode = "DO"
	// Ecuador.
	CountryCodeEc CountryCode = "EC"
	// Egypt.
	CountryCodeEg CountryCode = "EG"
	// El Salvador.
	CountryCodeSv CountryCode = "SV"
	// Equatorial Guinea.
	CountryCodeGq CountryCode = "GQ"
	// Eritrea.
	CountryCodeEr CountryCode = "ER"
	// Estonia.
	CountryCodeEe CountryCode = "EE"
	// Eswatini.
	CountryCodeSz CountryCode = "SZ"
	// Ethiopia.
	CountryCodeEt CountryCode = "ET"
	// Falkland Islands.
	CountryCodeFk CountryCode = "FK"
	// Faroe Islands.
	CountryCodeFo CountryCode = "FO"
	// Fiji.
	CountryCodeFj CountryCode = "FJ"
	// Finland.
	CountryCodeFi CountryCode = "FI"
	// France.
	CountryCodeFr CountryCode = "FR"
	// French Guiana.
	CountryCodeGf CountryCode = "GF"
	// French Polynesia.
	CountryCodePf CountryCode = "PF"
	// French Southern Territories.
	CountryCodeTf CountryCode = "TF"
	// Gabon.
	CountryCodeGa CountryCode = "GA"
	// Gambia.
	CountryCodeGm CountryCode = "GM"
	// Georgia.
	CountryCodeGe CountryCode = "GE"
	// Germany.
	CountryCodeDe CountryCode = "DE"
	// Ghana.
	CountryCodeGh CountryCode = "GH"
	// Gibraltar.
	CountryCodeGi CountryCode = "GI"
	// Greece.
	CountryCodeGr CountryCode = "GR"
	// Greenland.
	CountryCodeGl CountryCode = "GL"
	// Grenada.
	CountryCodeGd CountryCode = "GD"
	// Guadeloupe.
	CountryCodeGp CountryCode = "GP"
	// Guatemala.
	CountryCodeGt CountryCode = "GT"
	// Guernsey.
	CountryCodeGg CountryCode = "GG"
	// Guinea.
	CountryCodeGn CountryCode = "GN"
	// Guinea-Bissau.
	CountryCodeGw CountryCode = "GW"
	// Guyana.
	CountryCodeGy CountryCode = "GY"
	// Haiti.
	CountryCodeHt CountryCode = "HT"
	// Heard & McDonald Islands.
	CountryCodeHm CountryCode = "HM"
	// Vatican City.
	CountryCodeVa CountryCode = "VA"
	// Honduras.
	CountryCodeHn CountryCode = "HN"
	// Hong Kong SAR China.
	CountryCodeHk CountryCode = "HK"
	// Hungary.
	CountryCodeHu CountryCode = "HU"
	// Iceland.
	CountryCodeIs CountryCode = "IS"
	// India.
	CountryCodeIn CountryCode = "IN"
	// Indonesia.
	CountryCodeID CountryCode = "ID"
	// Iran.
	CountryCodeIr CountryCode = "IR"
	// Iraq.
	CountryCodeIq CountryCode = "IQ"
	// Ireland.
	CountryCodeIe CountryCode = "IE"
	// Isle of Man.
	CountryCodeIm CountryCode = "IM"
	// Israel.
	CountryCodeIl CountryCode = "IL"
	// Italy.
	CountryCodeIt CountryCode = "IT"
	// Jamaica.
	CountryCodeJm CountryCode = "JM"
	// Japan.
	CountryCodeJp CountryCode = "JP"
	// Jersey.
	CountryCodeJe CountryCode = "JE"
	// Jordan.
	CountryCodeJo CountryCode = "JO"
	// Kazakhstan.
	CountryCodeKz CountryCode = "KZ"
	// Kenya.
	CountryCodeKe CountryCode = "KE"
	// Kiribati.
	CountryCodeKi CountryCode = "KI"
	// North Korea.
	CountryCodeKp CountryCode = "KP"
	// Kosovo.
	CountryCodeXk CountryCode = "XK"
	// Kuwait.
	CountryCodeKw CountryCode = "KW"
	// Kyrgyzstan.
	CountryCodeKg CountryCode = "KG"
	// Laos.
	CountryCodeLa CountryCode = "LA"
	// Latvia.
	CountryCodeLv CountryCode = "LV"
	// Lebanon.
	CountryCodeLb CountryCode = "LB"
	// Lesotho.
	CountryCodeLs CountryCode = "LS"
	// Liberia.
	CountryCodeLr CountryCode = "LR"
	// Libya.
	CountryCodeLy CountryCode = "LY"
	// Liechtenstein.
	CountryCodeLi CountryCode = "LI"
	// Lithuania.
	CountryCodeLt CountryCode = "LT"
	// Luxembourg.
	CountryCodeLu CountryCode = "LU"
	// Macao SAR China.
	CountryCodeMo CountryCode = "MO"
	// Madagascar.
	CountryCodeMg CountryCode = "MG"
	// Malawi.
	CountryCodeMw CountryCode = "MW"
	// Malaysia.
	CountryCodeMy CountryCode = "MY"
	// Maldives.
	CountryCodeMv CountryCode = "MV"
	// Mali.
	CountryCodeMl CountryCode = "ML"
	// Malta.
	CountryCodeMt CountryCode = "MT"
	// Martinique.
	CountryCodeMq CountryCode = "MQ"
	// Mauritania.
	CountryCodeMr CountryCode = "MR"
	// Mauritius.
	CountryCodeMu CountryCode = "MU"
	// Mayotte.
	CountryCodeYt CountryCode = "YT"
	// Mexico.
	CountryCodeMx CountryCode = "MX"
	// Moldova.
	CountryCodeMd CountryCode = "MD"
	// Monaco.
	CountryCodeMc CountryCode = "MC"
	// Mongolia.
	CountryCodeMn CountryCode = "MN"
	// Montenegro.
	CountryCodeMe CountryCode = "ME"
	// Montserrat.
	CountryCodeMs CountryCode = "MS"
	// Morocco.
	CountryCodeMa CountryCode = "MA"
	// Mozambique.
	CountryCodeMz CountryCode = "MZ"
	// Myanmar (Burma).
	CountryCodeMm CountryCode = "MM"
	// Namibia.
	CountryCodeNa CountryCode = "NA"
	// Nauru.
	CountryCodeNr CountryCode = "NR"
	// Nepal.
	CountryCodeNp CountryCode = "NP"
	// Netherlands.
	CountryCodeNl CountryCode = "NL"
	// Netherlands Antilles.
	CountryCodeAn CountryCode = "AN"
	// New Caledonia.
	CountryCodeNc CountryCode = "NC"
	// New Zealand.
	CountryCodeNz CountryCode = "NZ"
	// Nicaragua.
	CountryCodeNi CountryCode = "NI"
	// Niger.
	CountryCodeNe CountryCode = "NE"
	// Nigeria.
	CountryCodeNg CountryCode = "NG"
	// Niue.
	CountryCodeNu CountryCode = "NU"
	// Norfolk Island.
	CountryCodeNf CountryCode = "NF"
	// North Macedonia.
	CountryCodeMk CountryCode = "MK"
	// Norway.
	CountryCodeNo CountryCode = "NO"
	// Oman.
	CountryCodeOm CountryCode = "OM"
	// Pakistan.
	CountryCodePk CountryCode = "PK"
	// Palestinian Territories.
	CountryCodePs CountryCode = "PS"
	// Panama.
	CountryCodePa CountryCode = "PA"
	// Papua New Guinea.
	CountryCodePg CountryCode = "PG"
	// Paraguay.
	CountryCodePy CountryCode = "PY"
	// Peru.
	CountryCodePe CountryCode = "PE"
	// Philippines.
	CountryCodePh CountryCode = "PH"
	// Pitcairn Islands.
	CountryCodePn CountryCode = "PN"
	// Poland.
	CountryCodePl CountryCode = "PL"
	// Portugal.
	CountryCodePt CountryCode = "PT"
	// Qatar.
	CountryCodeQa CountryCode = "QA"
	// Cameroon.
	CountryCodeCm CountryCode = "CM"
	// Réunion.
	CountryCodeRe CountryCode = "RE"
	// Romania.
	CountryCodeRo CountryCode = "RO"
	// Russia.
	CountryCodeRu CountryCode = "RU"
	// Rwanda.
	CountryCodeRw CountryCode = "RW"
	// St. Barthélemy.
	CountryCodeBl CountryCode = "BL"
	// St. Helena.
	CountryCodeSh CountryCode = "SH"
	// St. Kitts & Nevis.
	CountryCodeKn CountryCode = "KN"
	// St. Lucia.
	CountryCodeLc CountryCode = "LC"
	// St. Martin.
	CountryCodeMf CountryCode = "MF"
	// St. Pierre & Miquelon.
	CountryCodePm CountryCode = "PM"
	// Samoa.
	CountryCodeWs CountryCode = "WS"
	// San Marino.
	CountryCodeSm CountryCode = "SM"
	// São Tomé & Príncipe.
	CountryCodeSt CountryCode = "ST"
	// Saudi Arabia.
	CountryCodeSa CountryCode = "SA"
	// Senegal.
	CountryCodeSn CountryCode = "SN"
	// Serbia.
	CountryCodeRs CountryCode = "RS"
	// Seychelles.
	CountryCodeSc CountryCode = "SC"
	// Sierra Leone.
	CountryCodeSl CountryCode = "SL"
	// Singapore.
	CountryCodeSg CountryCode = "SG"
	// Sint Maarten.
	CountryCodeSx CountryCode = "SX"
	// Slovakia.
	CountryCodeSk CountryCode = "SK"
	// Slovenia.
	CountryCodeSi CountryCode = "SI"
	// Solomon Islands.
	CountryCodeSb CountryCode = "SB"
	// Somalia.
	CountryCodeSo CountryCode = "SO"
	// South Africa.
	CountryCodeZa CountryCode = "ZA"
	// South Georgia & South Sandwich Islands.
	CountryCodeGs CountryCode = "GS"
	// South Korea.
	CountryCodeKr CountryCode = "KR"
	// South Sudan.
	CountryCodeSs CountryCode = "SS"
	// Spain.
	CountryCodeEs CountryCode = "ES"
	// Sri Lanka.
	CountryCodeLk CountryCode = "LK"
	// St. Vincent & Grenadines.
	CountryCodeVc CountryCode = "VC"
	// Sudan.
	CountryCodeSd CountryCode = "SD"
	// Suriname.
	CountryCodeSr CountryCode = "SR"
	// Svalbard & Jan Mayen.
	CountryCodeSj CountryCode = "SJ"
	// Sweden.
	CountryCodeSe CountryCode = "SE"
	// Switzerland.
	CountryCodeCh CountryCode = "CH"
	// Syria.
	CountryCodeSy CountryCode = "SY"
	// Taiwan.
	CountryCodeTw CountryCode = "TW"
	// Tajikistan.
	CountryCodeTj CountryCode = "TJ"
	// Tanzania.
	CountryCodeTz CountryCode = "TZ"
	// Thailand.
	CountryCodeTh CountryCode = "TH"
	// Timor-Leste.
	CountryCodeTl CountryCode = "TL"
	// Togo.
	CountryCodeTg CountryCode = "TG"
	// Tokelau.
	CountryCodeTk CountryCode = "TK"
	// Tonga.
	CountryCodeTo CountryCode = "TO"
	// Trinidad & Tobago.
	CountryCodeTt CountryCode = "TT"
	// Tunisia.
	CountryCodeTn CountryCode = "TN"
	// Turkey.
	CountryCodeTr CountryCode = "TR"
	// Turkmenistan.
	CountryCodeTm CountryCode = "TM"
	// Turks & Caicos Islands.
	CountryCodeTc CountryCode = "TC"
	// Tuvalu.
	CountryCodeTv CountryCode = "TV"
	// Uganda.
	CountryCodeUg CountryCode = "UG"
	// Ukraine.
	CountryCodeUa CountryCode = "UA"
	// United Arab Emirates.
	CountryCodeAe CountryCode = "AE"
	// United Kingdom.
	CountryCodeGb CountryCode = "GB"
	// United States.
	CountryCodeUs CountryCode = "US"
	// U.S. Outlying Islands.
	CountryCodeUm CountryCode = "UM"
	// Uruguay.
	CountryCodeUy CountryCode = "UY"
	// Uzbekistan.
	CountryCodeUz CountryCode = "UZ"
	// Vanuatu.
	CountryCodeVu CountryCode = "VU"
	// Venezuela.
	CountryCodeVe CountryCode = "VE"
	// Vietnam.
	CountryCodeVn CountryCode = "VN"
	// British Virgin Islands.
	CountryCodeVg CountryCode = "VG"
	// Wallis & Futuna.
	CountryCodeWf CountryCode = "WF"
	// Western Sahara.
	CountryCodeEh CountryCode = "EH"
	// Yemen.
	CountryCodeYe CountryCode = "YE"
	// Zambia.
	CountryCodeZm CountryCode = "ZM"
	// Zimbabwe.
	CountryCodeZw CountryCode = "ZW"
)

var AllCountryCode = []CountryCode{
	CountryCodeAf,
	CountryCodeAx,
	CountryCodeAl,
	CountryCodeDz,
	CountryCodeAd,
	CountryCodeAo,
	CountryCodeAi,
	CountryCodeAg,
	CountryCodeAr,
	CountryCodeAm,
	CountryCodeAw,
	CountryCodeAu,
	CountryCodeAt,
	CountryCodeAz,
	CountryCodeBs,
	CountryCodeBh,
	CountryCodeBd,
	CountryCodeBb,
	CountryCodeBy,
	CountryCodeBe,
	CountryCodeBz,
	CountryCodeBj,
	CountryCodeBm,
	CountryCodeBt,
	CountryCodeBo,
	CountryCodeBa,
	CountryCodeBw,
	CountryCodeBv,
	CountryCodeBr,
	CountryCodeIo,
	CountryCodeBn,
	CountryCodeBg,
	CountryCodeBf,
	CountryCodeBi,
	CountryCodeKh,
	CountryCodeCa,
	CountryCodeCv,
	CountryCodeBq,
	CountryCodeKy,
	CountryCodeCf,
	CountryCodeTd,
	CountryCodeCl,
	CountryCodeCn,
	CountryCodeCx,
	CountryCodeCc,
	CountryCodeCo,
	CountryCodeKm,
	CountryCodeCg,
	CountryCodeCd,
	CountryCodeCk,
	CountryCodeCr,
	CountryCodeHr,
	CountryCodeCu,
	CountryCodeCw,
	CountryCodeCy,
	CountryCodeCz,
	CountryCodeCi,
	CountryCodeDk,
	CountryCodeDj,
	CountryCodeDm,
	CountryCodeDo,
	CountryCodeEc,
	CountryCodeEg,
	CountryCodeSv,
	CountryCodeGq,
	CountryCodeEr,
	CountryCodeEe,
	CountryCodeSz,
	CountryCodeEt,
	CountryCodeFk,
	CountryCodeFo,
	CountryCodeFj,
	CountryCodeFi,
	CountryCodeFr,
	CountryCodeGf,
	CountryCodePf,
	CountryCodeTf,
	CountryCodeGa,
	CountryCodeGm,
	CountryCodeGe,
	CountryCodeDe,
	CountryCodeGh,
	CountryCodeGi,
	CountryCodeGr,
	CountryCodeGl,
	CountryCodeGd,
	CountryCodeGp,
	CountryCodeGt,
	CountryCodeGg,
	CountryCodeGn,
	CountryCodeGw,
	CountryCodeGy,
	CountryCodeHt,
	CountryCodeHm,
	CountryCodeVa,
	CountryCodeHn,
	CountryCodeHk,
	CountryCodeHu,
	CountryCodeIs,
	CountryCodeIn,
	CountryCodeID,
	CountryCodeIr,
	CountryCodeIq,
	CountryCodeIe,
	CountryCodeIm,
	CountryCodeIl,
	CountryCodeIt,
	CountryCodeJm,
	CountryCodeJp,
	CountryCodeJe,
	CountryCodeJo,
	CountryCodeKz,
	CountryCodeKe,
	CountryCodeKi,
	CountryCodeKp,
	CountryCodeXk,
	CountryCodeKw,
	CountryCodeKg,
	CountryCodeLa,
	CountryCodeLv,
	CountryCodeLb,
	CountryCodeLs,
	CountryCodeLr,
	CountryCodeLy,
	CountryCodeLi,
	CountryCodeLt,
	CountryCodeLu,
	CountryCodeMo,
	CountryCodeMg,
	CountryCodeMw,
	CountryCodeMy,
	CountryCodeMv,
	CountryCodeMl,
	CountryCodeMt,
	CountryCodeMq,
	CountryCodeMr,
	CountryCodeMu,
	CountryCodeYt,
	CountryCodeMx,
	CountryCodeMd,
	CountryCodeMc,
	CountryCodeMn,
	CountryCodeMe,
	CountryCodeMs,
	CountryCodeMa,
	CountryCodeMz,
	CountryCodeMm,
	CountryCodeNa,
	CountryCodeNr,
	CountryCodeNp,
	CountryCodeNl,
	CountryCodeAn,
	CountryCodeNc,
	CountryCodeNz,
	CountryCodeNi,
	CountryCodeNe,
	CountryCodeNg,
	CountryCodeNu,
	CountryCodeNf,
	CountryCodeMk,
	CountryCodeNo,
	CountryCodeOm,
	CountryCodePk,
	CountryCodePs,
	CountryCodePa,
	CountryCodePg,
	CountryCodePy,
	CountryCodePe,
	CountryCodePh,
	CountryCodePn,
	CountryCodePl,
	CountryCodePt,
	CountryCodeQa,
	CountryCodeCm,
	CountryCodeRe,
	CountryCodeRo,
	CountryCodeRu,
	CountryCodeRw,
	CountryCodeBl,
	CountryCodeSh,
	CountryCodeKn,
	CountryCodeLc,
	CountryCodeMf,
	CountryCodePm,
	CountryCodeWs,
	CountryCodeSm,
	CountryCodeSt,
	CountryCodeSa,
	CountryCodeSn,
	CountryCodeRs,
	CountryCodeSc,
	CountryCodeSl,
	CountryCodeSg,
	CountryCodeSx,
	CountryCodeSk,
	CountryCodeSi,
	CountryCodeSb,
	CountryCodeSo,
	CountryCodeZa,
	CountryCodeGs,
	CountryCodeKr,
	CountryCodeSs,
	CountryCodeEs,
	CountryCodeLk,
	CountryCodeVc,
	CountryCodeSd,
	CountryCodeSr,
	CountryCodeSj,
	CountryCodeSe,
	CountryCodeCh,
	CountryCodeSy,
	CountryCodeTw,
	CountryCodeTj,
	CountryCodeTz,
	CountryCodeTh,
	CountryCodeTl,
	CountryCodeTg,
	CountryCodeTk,
	CountryCodeTo,
	CountryCodeTt,
	CountryCodeTn,
	CountryCodeTr,
	CountryCodeTm,
	CountryCodeTc,
	CountryCodeTv,
	CountryCodeUg,
	CountryCodeUa,
	CountryCodeAe,
	CountryCodeGb,
	CountryCodeUs,
	CountryCodeUm,
	CountryCodeUy,
	CountryCodeUz,
	CountryCodeVu,
	CountryCodeVe,
	CountryCodeVn,
	CountryCodeVg,
	CountryCodeWf,
	CountryCodeEh,
	CountryCodeYe,
	CountryCodeZm,
	CountryCodeZw,
}

func (e CountryCode) IsValid() bool {
	switch e {
	case CountryCodeAf, CountryCodeAx, CountryCodeAl, CountryCodeDz, CountryCodeAd, CountryCodeAo, CountryCodeAi, CountryCodeAg, CountryCodeAr, CountryCodeAm, CountryCodeAw, CountryCodeAu, CountryCodeAt, CountryCodeAz, CountryCodeBs, CountryCodeBh, CountryCodeBd, CountryCodeBb, CountryCodeBy, CountryCodeBe, CountryCodeBz, CountryCodeBj, CountryCodeBm, CountryCodeBt, CountryCodeBo, CountryCodeBa, CountryCodeBw, CountryCodeBv, CountryCodeBr, CountryCodeIo, CountryCodeBn, CountryCodeBg, CountryCodeBf, CountryCodeBi, CountryCodeKh, CountryCodeCa, CountryCodeCv, CountryCodeBq, CountryCodeKy, CountryCodeCf, CountryCodeTd, CountryCodeCl, CountryCodeCn, CountryCodeCx, CountryCodeCc, CountryCodeCo, CountryCodeKm, CountryCodeCg, CountryCodeCd, CountryCodeCk, CountryCodeCr, CountryCodeHr, CountryCodeCu, CountryCodeCw, CountryCodeCy, CountryCodeCz, CountryCodeCi, CountryCodeDk, CountryCodeDj, CountryCodeDm, CountryCodeDo, CountryCodeEc, CountryCodeEg, CountryCodeSv, CountryCodeGq, CountryCodeEr, CountryCodeEe, CountryCodeSz, CountryCodeEt, CountryCodeFk, CountryCodeFo, CountryCodeFj, CountryCodeFi, CountryCodeFr, CountryCodeGf, CountryCodePf, CountryCodeTf, CountryCodeGa, CountryCodeGm, CountryCodeGe, CountryCodeDe, CountryCodeGh, CountryCodeGi, CountryCodeGr, CountryCodeGl, CountryCodeGd, CountryCodeGp, CountryCodeGt, CountryCodeGg, CountryCodeGn, CountryCodeGw, CountryCodeGy, CountryCodeHt, CountryCodeHm, CountryCodeVa, CountryCodeHn, CountryCodeHk, CountryCodeHu, CountryCodeIs, CountryCodeIn, CountryCodeID, CountryCodeIr, CountryCodeIq, CountryCodeIe, CountryCodeIm, CountryCodeIl, CountryCodeIt, CountryCodeJm, CountryCodeJp, CountryCodeJe, CountryCodeJo, CountryCodeKz, CountryCodeKe, CountryCodeKi, CountryCodeKp, CountryCodeXk, CountryCodeKw, CountryCodeKg, CountryCodeLa, CountryCodeLv, CountryCodeLb, CountryCodeLs, CountryCodeLr, CountryCodeLy, CountryCodeLi, CountryCodeLt, CountryCodeLu, CountryCodeMo, CountryCodeMg, CountryCodeMw, CountryCodeMy, CountryCodeMv, CountryCodeMl, CountryCodeMt, CountryCodeMq, CountryCodeMr, CountryCodeMu, CountryCodeYt, CountryCodeMx, CountryCodeMd, CountryCodeMc, CountryCodeMn, CountryCodeMe, CountryCodeMs, CountryCodeMa, CountryCodeMz, CountryCodeMm, CountryCodeNa, CountryCodeNr, CountryCodeNp, CountryCodeNl, CountryCodeAn, CountryCodeNc, CountryCodeNz, CountryCodeNi, CountryCodeNe, CountryCodeNg, CountryCodeNu, CountryCodeNf, CountryCodeMk, CountryCodeNo, CountryCodeOm, CountryCodePk, CountryCodePs, CountryCodePa, CountryCodePg, CountryCodePy, CountryCodePe, CountryCodePh, CountryCodePn, CountryCodePl, CountryCodePt, CountryCodeQa, CountryCodeCm, CountryCodeRe, CountryCodeRo, CountryCodeRu, CountryCodeRw, CountryCodeBl, CountryCodeSh, CountryCodeKn, CountryCodeLc, CountryCodeMf, CountryCodePm, CountryCodeWs, CountryCodeSm, CountryCodeSt, CountryCodeSa, CountryCodeSn, CountryCodeRs, CountryCodeSc, CountryCodeSl, CountryCodeSg, CountryCodeSx, CountryCodeSk, CountryCodeSi, CountryCodeSb, CountryCodeSo, CountryCodeZa, CountryCodeGs, CountryCodeKr, CountryCodeSs, CountryCodeEs, CountryCodeLk, CountryCodeVc, CountryCodeSd, CountryCodeSr, CountryCodeSj, CountryCodeSe, CountryCodeCh, CountryCodeSy, CountryCodeTw, CountryCodeTj, CountryCodeTz, CountryCodeTh, CountryCodeTl, CountryCodeTg, CountryCodeTk, CountryCodeTo, CountryCodeTt, CountryCodeTn, CountryCodeTr, CountryCodeTm, CountryCodeTc, CountryCodeTv, CountryCodeUg, CountryCodeUa, CountryCodeAe, CountryCodeGb, CountryCodeUs, CountryCodeUm, CountryCodeUy, CountryCodeUz, CountryCodeVu, CountryCodeVe, CountryCodeVn, CountryCodeVg, CountryCodeWf, CountryCodeEh, CountryCodeYe, CountryCodeZm, CountryCodeZw:
		return true
	}
	return false
}

func (e CountryCode) String() string {
	return string(e)
}

func (e *CountryCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountryCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CountryCode", str)
	}
	return nil
}

func (e CountryCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The part of the image that should remain after cropping.
type CropRegion string

const (
	// Keep the center of the image.
	CropRegionCenter CropRegion = "CENTER"
	// Keep the top of the image.
	CropRegionTop CropRegion = "TOP"
	// Keep the bottom of the image.
	CropRegionBottom CropRegion = "BOTTOM"
	// Keep the left of the image.
	CropRegionLeft CropRegion = "LEFT"
	// Keep the right of the image.
	CropRegionRight CropRegion = "RIGHT"
)

var AllCropRegion = []CropRegion{
	CropRegionCenter,
	CropRegionTop,
	CropRegionBottom,
	CropRegionLeft,
	CropRegionRight,
}

func (e CropRegion) IsValid() bool {
	switch e {
	case CropRegionCenter, CropRegionTop, CropRegionBottom, CropRegionLeft, CropRegionRight:
		return true
	}
	return false
}

func (e CropRegion) String() string {
	return string(e)
}

func (e *CropRegion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CropRegion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CropRegion", str)
	}
	return nil
}

func (e CropRegion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Currency codes.
type CurrencyCode string

const (
	// United States Dollars (USD).
	CurrencyCodeUsd CurrencyCode = "USD"
	// Euro (EUR).
	CurrencyCodeEur CurrencyCode = "EUR"
	// United Kingdom Pounds (GBP).
	CurrencyCodeGbp CurrencyCode = "GBP"
	// Canadian Dollars (CAD).
	CurrencyCodeCad CurrencyCode = "CAD"
	// Afghan Afghani (AFN).
	CurrencyCodeAfn CurrencyCode = "AFN"
	// Albanian Lek (ALL).
	CurrencyCodeAll CurrencyCode = "ALL"
	// Algerian Dinar (DZD).
	CurrencyCodeDzd CurrencyCode = "DZD"
	// Angolan Kwanza (AOA).
	CurrencyCodeAoa CurrencyCode = "AOA"
	// Argentine Pesos (ARS).
	CurrencyCodeArs CurrencyCode = "ARS"
	// Armenian Dram (AMD).
	CurrencyCodeAmd CurrencyCode = "AMD"
	// Aruban Florin (AWG).
	CurrencyCodeAwg CurrencyCode = "AWG"
	// Australian Dollars (AUD).
	CurrencyCodeAud CurrencyCode = "AUD"
	// Barbadian Dollar (BBD).
	CurrencyCodeBbd CurrencyCode = "BBD"
	// Azerbaijani Manat (AZN).
	CurrencyCodeAzn CurrencyCode = "AZN"
	// Bangladesh Taka (BDT).
	CurrencyCodeBdt CurrencyCode = "BDT"
	// Bahamian Dollar (BSD).
	CurrencyCodeBsd CurrencyCode = "BSD"
	// Bahraini Dinar (BHD).
	CurrencyCodeBhd CurrencyCode = "BHD"
	// Burundian Franc (BIF).
	CurrencyCodeBif CurrencyCode = "BIF"
	// Belarusian Ruble (BYR).
	CurrencyCodeByr CurrencyCode = "BYR"
	// Belize Dollar (BZD).
	CurrencyCodeBzd CurrencyCode = "BZD"
	// Bermudian Dollar (BMD).
	CurrencyCodeBmd CurrencyCode = "BMD"
	// Bhutanese Ngultrum (BTN).
	CurrencyCodeBtn CurrencyCode = "BTN"
	// Bosnia and Herzegovina Convertible Mark (BAM).
	CurrencyCodeBam CurrencyCode = "BAM"
	// Brazilian Real (BRL).
	CurrencyCodeBrl CurrencyCode = "BRL"
	// Bolivian Boliviano (BOB).
	CurrencyCodeBob CurrencyCode = "BOB"
	// Botswana Pula (BWP).
	CurrencyCodeBwp CurrencyCode = "BWP"
	// Brunei Dollar (BND).
	CurrencyCodeBnd CurrencyCode = "BND"
	// Bulgarian Lev (BGN).
	CurrencyCodeBgn CurrencyCode = "BGN"
	// Burmese Kyat (MMK).
	CurrencyCodeMmk CurrencyCode = "MMK"
	// Cambodian Riel.
	CurrencyCodeKhr CurrencyCode = "KHR"
	// Cape Verdean escudo (CVE).
	CurrencyCodeCve CurrencyCode = "CVE"
	// Cayman Dollars (KYD).
	CurrencyCodeKyd CurrencyCode = "KYD"
	// Central African CFA Franc (XAF).
	CurrencyCodeXaf CurrencyCode = "XAF"
	// Chilean Peso (CLP).
	CurrencyCodeClp CurrencyCode = "CLP"
	// Chinese Yuan Renminbi (CNY).
	CurrencyCodeCny CurrencyCode = "CNY"
	// Colombian Peso (COP).
	CurrencyCodeCop CurrencyCode = "COP"
	// Comorian Franc (KMF).
	CurrencyCodeKmf CurrencyCode = "KMF"
	// Congolese franc (CDF).
	CurrencyCodeCdf CurrencyCode = "CDF"
	// Costa Rican Colones (CRC).
	CurrencyCodeCrc CurrencyCode = "CRC"
	// Croatian Kuna (HRK).
	CurrencyCodeHrk CurrencyCode = "HRK"
	// Czech Koruny (CZK).
	CurrencyCodeCzk CurrencyCode = "CZK"
	// Danish Kroner (DKK).
	CurrencyCodeDkk CurrencyCode = "DKK"
	// Djiboutian Franc (DJF).
	CurrencyCodeDjf CurrencyCode = "DJF"
	// Dominican Peso (DOP).
	CurrencyCodeDop CurrencyCode = "DOP"
	// East Caribbean Dollar (XCD).
	CurrencyCodeXcd CurrencyCode = "XCD"
	// Egyptian Pound (EGP).
	CurrencyCodeEgp CurrencyCode = "EGP"
	// Eritrean Nakfa (ERN).
	CurrencyCodeErn CurrencyCode = "ERN"
	// Ethiopian Birr (ETB).
	CurrencyCodeEtb CurrencyCode = "ETB"
	// Falkland Islands Pounds (FKP).
	CurrencyCodeFkp CurrencyCode = "FKP"
	// CFP Franc (XPF).
	CurrencyCodeXpf CurrencyCode = "XPF"
	// Fijian Dollars (FJD).
	CurrencyCodeFjd CurrencyCode = "FJD"
	// Gibraltar Pounds (GIP).
	CurrencyCodeGip CurrencyCode = "GIP"
	// Gambian Dalasi (GMD).
	CurrencyCodeGmd CurrencyCode = "GMD"
	// Ghanaian Cedi (GHS).
	CurrencyCodeGhs CurrencyCode = "GHS"
	// Guatemalan Quetzal (GTQ).
	CurrencyCodeGtq CurrencyCode = "GTQ"
	// Guyanese Dollar (GYD).
	CurrencyCodeGyd CurrencyCode = "GYD"
	// Georgian Lari (GEL).
	CurrencyCodeGel CurrencyCode = "GEL"
	// Guinean Franc (GNF).
	CurrencyCodeGnf CurrencyCode = "GNF"
	// Haitian Gourde (HTG).
	CurrencyCodeHtg CurrencyCode = "HTG"
	// Honduran Lempira (HNL).
	CurrencyCodeHnl CurrencyCode = "HNL"
	// Hong Kong Dollars (HKD).
	CurrencyCodeHkd CurrencyCode = "HKD"
	// Hungarian Forint (HUF).
	CurrencyCodeHuf CurrencyCode = "HUF"
	// Icelandic Kronur (ISK).
	CurrencyCodeIsk CurrencyCode = "ISK"
	// Indian Rupees (INR).
	CurrencyCodeInr CurrencyCode = "INR"
	// Indonesian Rupiah (IDR).
	CurrencyCodeIDR CurrencyCode = "IDR"
	// Israeli New Shekel (NIS).
	CurrencyCodeIls CurrencyCode = "ILS"
	// Iranian Rial (IRR).
	CurrencyCodeIrr CurrencyCode = "IRR"
	// Iraqi Dinar (IQD).
	CurrencyCodeIqd CurrencyCode = "IQD"
	// Jamaican Dollars (JMD).
	CurrencyCodeJmd CurrencyCode = "JMD"
	// Japanese Yen (JPY).
	CurrencyCodeJpy CurrencyCode = "JPY"
	// Jersey Pound.
	CurrencyCodeJep CurrencyCode = "JEP"
	// Jordanian Dinar (JOD).
	CurrencyCodeJod CurrencyCode = "JOD"
	// Kazakhstani Tenge (KZT).
	CurrencyCodeKzt CurrencyCode = "KZT"
	// Kenyan Shilling (KES).
	CurrencyCodeKes CurrencyCode = "KES"
	// Kiribati Dollar (KID).
	CurrencyCodeKid CurrencyCode = "KID"
	// Kuwaiti Dinar (KWD).
	CurrencyCodeKwd CurrencyCode = "KWD"
	// Kyrgyzstani Som (KGS).
	CurrencyCodeKgs CurrencyCode = "KGS"
	// Laotian Kip (LAK).
	CurrencyCodeLak CurrencyCode = "LAK"
	// Latvian Lati (LVL).
	CurrencyCodeLvl CurrencyCode = "LVL"
	// Lebanese Pounds (LBP).
	CurrencyCodeLbp CurrencyCode = "LBP"
	// Lesotho Loti (LSL).
	CurrencyCodeLsl CurrencyCode = "LSL"
	// Liberian Dollar (LRD).
	CurrencyCodeLrd CurrencyCode = "LRD"
	// Libyan Dinar (LYD).
	CurrencyCodeLyd CurrencyCode = "LYD"
	// Lithuanian Litai (LTL).
	CurrencyCodeLtl CurrencyCode = "LTL"
	// Malagasy Ariary (MGA).
	CurrencyCodeMga CurrencyCode = "MGA"
	// Macedonia Denar (MKD).
	CurrencyCodeMkd CurrencyCode = "MKD"
	// Macanese Pataca (MOP).
	CurrencyCodeMop CurrencyCode = "MOP"
	// Malawian Kwacha (MWK).
	CurrencyCodeMwk CurrencyCode = "MWK"
	// Maldivian Rufiyaa (MVR).
	CurrencyCodeMvr CurrencyCode = "MVR"
	// Mauritanian Ouguiya (MRU).
	CurrencyCodeMru CurrencyCode = "MRU"
	// Mexican Pesos (MXN).
	CurrencyCodeMxn CurrencyCode = "MXN"
	// Malaysian Ringgits (MYR).
	CurrencyCodeMyr CurrencyCode = "MYR"
	// Mauritian Rupee (MUR).
	CurrencyCodeMur CurrencyCode = "MUR"
	// Moldovan Leu (MDL).
	CurrencyCodeMdl CurrencyCode = "MDL"
	// Moroccan Dirham.
	CurrencyCodeMad CurrencyCode = "MAD"
	// Mongolian Tugrik.
	CurrencyCodeMnt CurrencyCode = "MNT"
	// Mozambican Metical.
	CurrencyCodeMzn CurrencyCode = "MZN"
	// Namibian Dollar.
	CurrencyCodeNad CurrencyCode = "NAD"
	// Nepalese Rupee (NPR).
	CurrencyCodeNpr CurrencyCode = "NPR"
	// Netherlands Antillean Guilder.
	CurrencyCodeAng CurrencyCode = "ANG"
	// New Zealand Dollars (NZD).
	CurrencyCodeNzd CurrencyCode = "NZD"
	// Nicaraguan Córdoba (NIO).
	CurrencyCodeNio CurrencyCode = "NIO"
	// Nigerian Naira (NGN).
	CurrencyCodeNgn CurrencyCode = "NGN"
	// Norwegian Kroner (NOK).
	CurrencyCodeNok CurrencyCode = "NOK"
	// Omani Rial (OMR).
	CurrencyCodeOmr CurrencyCode = "OMR"
	// Panamian Balboa (PAB).
	CurrencyCodePab CurrencyCode = "PAB"
	// Pakistani Rupee (PKR).
	CurrencyCodePkr CurrencyCode = "PKR"
	// Papua New Guinean Kina (PGK).
	CurrencyCodePgk CurrencyCode = "PGK"
	// Paraguayan Guarani (PYG).
	CurrencyCodePyg CurrencyCode = "PYG"
	// Peruvian Nuevo Sol (PEN).
	CurrencyCodePen CurrencyCode = "PEN"
	// Philippine Peso (PHP).
	CurrencyCodePhp CurrencyCode = "PHP"
	// Polish Zlotych (PLN).
	CurrencyCodePln CurrencyCode = "PLN"
	// Qatari Rial (QAR).
	CurrencyCodeQar CurrencyCode = "QAR"
	// Romanian Lei (RON).
	CurrencyCodeRon CurrencyCode = "RON"
	// Russian Rubles (RUB).
	CurrencyCodeRub CurrencyCode = "RUB"
	// Rwandan Franc (RWF).
	CurrencyCodeRwf CurrencyCode = "RWF"
	// Samoan Tala (WST).
	CurrencyCodeWst CurrencyCode = "WST"
	// Saint Helena Pounds (SHP).
	CurrencyCodeShp CurrencyCode = "SHP"
	// Saudi Riyal (SAR).
	CurrencyCodeSar CurrencyCode = "SAR"
	// Sao Tome And Principe Dobra (STD).
	CurrencyCodeStd CurrencyCode = "STD"
	// Serbian dinar (RSD).
	CurrencyCodeRsd CurrencyCode = "RSD"
	// Seychellois Rupee (SCR).
	CurrencyCodeScr CurrencyCode = "SCR"
	// Sierra Leonean Leone (SLL).
	CurrencyCodeSll CurrencyCode = "SLL"
	// Singapore Dollars (SGD).
	CurrencyCodeSgd CurrencyCode = "SGD"
	// Sudanese Pound (SDG).
	CurrencyCodeSdg CurrencyCode = "SDG"
	// Somali Shilling (SOS).
	CurrencyCodeSos CurrencyCode = "SOS"
	// Syrian Pound (SYP).
	CurrencyCodeSyp CurrencyCode = "SYP"
	// South African Rand (ZAR).
	CurrencyCodeZar CurrencyCode = "ZAR"
	// South Korean Won (KRW).
	CurrencyCodeKrw CurrencyCode = "KRW"
	// South Sudanese Pound (SSP).
	CurrencyCodeSsp CurrencyCode = "SSP"
	// Solomon Islands Dollar (SBD).
	CurrencyCodeSbd CurrencyCode = "SBD"
	// Sri Lankan Rupees (LKR).
	CurrencyCodeLkr CurrencyCode = "LKR"
	// Surinamese Dollar (SRD).
	CurrencyCodeSrd CurrencyCode = "SRD"
	// Swazi Lilangeni (SZL).
	CurrencyCodeSzl CurrencyCode = "SZL"
	// Swedish Kronor (SEK).
	CurrencyCodeSek CurrencyCode = "SEK"
	// Swiss Francs (CHF).
	CurrencyCodeChf CurrencyCode = "CHF"
	// Taiwan Dollars (TWD).
	CurrencyCodeTwd CurrencyCode = "TWD"
	// Thai baht (THB).
	CurrencyCodeThb CurrencyCode = "THB"
	// Tajikistani Somoni (TJS).
	CurrencyCodeTjs CurrencyCode = "TJS"
	// Tanzanian Shilling (TZS).
	CurrencyCodeTzs CurrencyCode = "TZS"
	// Tongan Pa'anga (TOP).
	CurrencyCodeTop CurrencyCode = "TOP"
	// Trinidad and Tobago Dollars (TTD).
	CurrencyCodeTtd CurrencyCode = "TTD"
	// Tunisian Dinar (TND).
	CurrencyCodeTnd CurrencyCode = "TND"
	// Turkish Lira (TRY).
	CurrencyCodeTry CurrencyCode = "TRY"
	// Turkmenistani Manat (TMT).
	CurrencyCodeTmt CurrencyCode = "TMT"
	// Ugandan Shilling (UGX).
	CurrencyCodeUgx CurrencyCode = "UGX"
	// Ukrainian Hryvnia (UAH).
	CurrencyCodeUah CurrencyCode = "UAH"
	// United Arab Emirates Dirham (AED).
	CurrencyCodeAed CurrencyCode = "AED"
	// Uruguayan Pesos (UYU).
	CurrencyCodeUyu CurrencyCode = "UYU"
	// Uzbekistan som (UZS).
	CurrencyCodeUzs CurrencyCode = "UZS"
	// Vanuatu Vatu (VUV).
	CurrencyCodeVuv CurrencyCode = "VUV"
	// Venezuelan Bolivares (VEF).
	CurrencyCodeVef CurrencyCode = "VEF"
	// Venezuelan Bolivares (VES).
	CurrencyCodeVes CurrencyCode = "VES"
	// Vietnamese đồng (VND).
	CurrencyCodeVnd CurrencyCode = "VND"
	// West African CFA franc (XOF).
	CurrencyCodeXof CurrencyCode = "XOF"
	// Yemeni Rial (YER).
	CurrencyCodeYer CurrencyCode = "YER"
	// Zambian Kwacha (ZMW).
	CurrencyCodeZmw CurrencyCode = "ZMW"
)

var AllCurrencyCode = []CurrencyCode{
	CurrencyCodeUsd,
	CurrencyCodeEur,
	CurrencyCodeGbp,
	CurrencyCodeCad,
	CurrencyCodeAfn,
	CurrencyCodeAll,
	CurrencyCodeDzd,
	CurrencyCodeAoa,
	CurrencyCodeArs,
	CurrencyCodeAmd,
	CurrencyCodeAwg,
	CurrencyCodeAud,
	CurrencyCodeBbd,
	CurrencyCodeAzn,
	CurrencyCodeBdt,
	CurrencyCodeBsd,
	CurrencyCodeBhd,
	CurrencyCodeBif,
	CurrencyCodeByr,
	CurrencyCodeBzd,
	CurrencyCodeBmd,
	CurrencyCodeBtn,
	CurrencyCodeBam,
	CurrencyCodeBrl,
	CurrencyCodeBob,
	CurrencyCodeBwp,
	CurrencyCodeBnd,
	CurrencyCodeBgn,
	CurrencyCodeMmk,
	CurrencyCodeKhr,
	CurrencyCodeCve,
	CurrencyCodeKyd,
	CurrencyCodeXaf,
	CurrencyCodeClp,
	CurrencyCodeCny,
	CurrencyCodeCop,
	CurrencyCodeKmf,
	CurrencyCodeCdf,
	CurrencyCodeCrc,
	CurrencyCodeHrk,
	CurrencyCodeCzk,
	CurrencyCodeDkk,
	CurrencyCodeDjf,
	CurrencyCodeDop,
	CurrencyCodeXcd,
	CurrencyCodeEgp,
	CurrencyCodeErn,
	CurrencyCodeEtb,
	CurrencyCodeFkp,
	CurrencyCodeXpf,
	CurrencyCodeFjd,
	CurrencyCodeGip,
	CurrencyCodeGmd,
	CurrencyCodeGhs,
	CurrencyCodeGtq,
	CurrencyCodeGyd,
	CurrencyCodeGel,
	CurrencyCodeGnf,
	CurrencyCodeHtg,
	CurrencyCodeHnl,
	CurrencyCodeHkd,
	CurrencyCodeHuf,
	CurrencyCodeIsk,
	CurrencyCodeInr,
	CurrencyCodeIDR,
	CurrencyCodeIls,
	CurrencyCodeIrr,
	CurrencyCodeIqd,
	CurrencyCodeJmd,
	CurrencyCodeJpy,
	CurrencyCodeJep,
	CurrencyCodeJod,
	CurrencyCodeKzt,
	CurrencyCodeKes,
	CurrencyCodeKid,
	CurrencyCodeKwd,
	CurrencyCodeKgs,
	CurrencyCodeLak,
	CurrencyCodeLvl,
	CurrencyCodeLbp,
	CurrencyCodeLsl,
	CurrencyCodeLrd,
	CurrencyCodeLyd,
	CurrencyCodeLtl,
	CurrencyCodeMga,
	CurrencyCodeMkd,
	CurrencyCodeMop,
	CurrencyCodeMwk,
	CurrencyCodeMvr,
	CurrencyCodeMru,
	CurrencyCodeMxn,
	CurrencyCodeMyr,
	CurrencyCodeMur,
	CurrencyCodeMdl,
	CurrencyCodeMad,
	CurrencyCodeMnt,
	CurrencyCodeMzn,
	CurrencyCodeNad,
	CurrencyCodeNpr,
	CurrencyCodeAng,
	CurrencyCodeNzd,
	CurrencyCodeNio,
	CurrencyCodeNgn,
	CurrencyCodeNok,
	CurrencyCodeOmr,
	CurrencyCodePab,
	CurrencyCodePkr,
	CurrencyCodePgk,
	CurrencyCodePyg,
	CurrencyCodePen,
	CurrencyCodePhp,
	CurrencyCodePln,
	CurrencyCodeQar,
	CurrencyCodeRon,
	CurrencyCodeRub,
	CurrencyCodeRwf,
	CurrencyCodeWst,
	CurrencyCodeShp,
	CurrencyCodeSar,
	CurrencyCodeStd,
	CurrencyCodeRsd,
	CurrencyCodeScr,
	CurrencyCodeSll,
	CurrencyCodeSgd,
	CurrencyCodeSdg,
	CurrencyCodeSos,
	CurrencyCodeSyp,
	CurrencyCodeZar,
	CurrencyCodeKrw,
	CurrencyCodeSsp,
	CurrencyCodeSbd,
	CurrencyCodeLkr,
	CurrencyCodeSrd,
	CurrencyCodeSzl,
	CurrencyCodeSek,
	CurrencyCodeChf,
	CurrencyCodeTwd,
	CurrencyCodeThb,
	CurrencyCodeTjs,
	CurrencyCodeTzs,
	CurrencyCodeTop,
	CurrencyCodeTtd,
	CurrencyCodeTnd,
	CurrencyCodeTry,
	CurrencyCodeTmt,
	CurrencyCodeUgx,
	CurrencyCodeUah,
	CurrencyCodeAed,
	CurrencyCodeUyu,
	CurrencyCodeUzs,
	CurrencyCodeVuv,
	CurrencyCodeVef,
	CurrencyCodeVes,
	CurrencyCodeVnd,
	CurrencyCodeXof,
	CurrencyCodeYer,
	CurrencyCodeZmw,
}

func (e CurrencyCode) IsValid() bool {
	switch e {
	case CurrencyCodeUsd, CurrencyCodeEur, CurrencyCodeGbp, CurrencyCodeCad, CurrencyCodeAfn, CurrencyCodeAll, CurrencyCodeDzd, CurrencyCodeAoa, CurrencyCodeArs, CurrencyCodeAmd, CurrencyCodeAwg, CurrencyCodeAud, CurrencyCodeBbd, CurrencyCodeAzn, CurrencyCodeBdt, CurrencyCodeBsd, CurrencyCodeBhd, CurrencyCodeBif, CurrencyCodeByr, CurrencyCodeBzd, CurrencyCodeBmd, CurrencyCodeBtn, CurrencyCodeBam, CurrencyCodeBrl, CurrencyCodeBob, CurrencyCodeBwp, CurrencyCodeBnd, CurrencyCodeBgn, CurrencyCodeMmk, CurrencyCodeKhr, CurrencyCodeCve, CurrencyCodeKyd, CurrencyCodeXaf, CurrencyCodeClp, CurrencyCodeCny, CurrencyCodeCop, CurrencyCodeKmf, CurrencyCodeCdf, CurrencyCodeCrc, CurrencyCodeHrk, CurrencyCodeCzk, CurrencyCodeDkk, CurrencyCodeDjf, CurrencyCodeDop, CurrencyCodeXcd, CurrencyCodeEgp, CurrencyCodeErn, CurrencyCodeEtb, CurrencyCodeFkp, CurrencyCodeXpf, CurrencyCodeFjd, CurrencyCodeGip, CurrencyCodeGmd, CurrencyCodeGhs, CurrencyCodeGtq, CurrencyCodeGyd, CurrencyCodeGel, CurrencyCodeGnf, CurrencyCodeHtg, CurrencyCodeHnl, CurrencyCodeHkd, CurrencyCodeHuf, CurrencyCodeIsk, CurrencyCodeInr, CurrencyCodeIDR, CurrencyCodeIls, CurrencyCodeIrr, CurrencyCodeIqd, CurrencyCodeJmd, CurrencyCodeJpy, CurrencyCodeJep, CurrencyCodeJod, CurrencyCodeKzt, CurrencyCodeKes, CurrencyCodeKid, CurrencyCodeKwd, CurrencyCodeKgs, CurrencyCodeLak, CurrencyCodeLvl, CurrencyCodeLbp, CurrencyCodeLsl, CurrencyCodeLrd, CurrencyCodeLyd, CurrencyCodeLtl, CurrencyCodeMga, CurrencyCodeMkd, CurrencyCodeMop, CurrencyCodeMwk, CurrencyCodeMvr, CurrencyCodeMru, CurrencyCodeMxn, CurrencyCodeMyr, CurrencyCodeMur, CurrencyCodeMdl, CurrencyCodeMad, CurrencyCodeMnt, CurrencyCodeMzn, CurrencyCodeNad, CurrencyCodeNpr, CurrencyCodeAng, CurrencyCodeNzd, CurrencyCodeNio, CurrencyCodeNgn, CurrencyCodeNok, CurrencyCodeOmr, CurrencyCodePab, CurrencyCodePkr, CurrencyCodePgk, CurrencyCodePyg, CurrencyCodePen, CurrencyCodePhp, CurrencyCodePln, CurrencyCodeQar, CurrencyCodeRon, CurrencyCodeRub, CurrencyCodeRwf, CurrencyCodeWst, CurrencyCodeShp, CurrencyCodeSar, CurrencyCodeStd, CurrencyCodeRsd, CurrencyCodeScr, CurrencyCodeSll, CurrencyCodeSgd, CurrencyCodeSdg, CurrencyCodeSos, CurrencyCodeSyp, CurrencyCodeZar, CurrencyCodeKrw, CurrencyCodeSsp, CurrencyCodeSbd, CurrencyCodeLkr, CurrencyCodeSrd, CurrencyCodeSzl, CurrencyCodeSek, CurrencyCodeChf, CurrencyCodeTwd, CurrencyCodeThb, CurrencyCodeTjs, CurrencyCodeTzs, CurrencyCodeTop, CurrencyCodeTtd, CurrencyCodeTnd, CurrencyCodeTry, CurrencyCodeTmt, CurrencyCodeUgx, CurrencyCodeUah, CurrencyCodeAed, CurrencyCodeUyu, CurrencyCodeUzs, CurrencyCodeVuv, CurrencyCodeVef, CurrencyCodeVes, CurrencyCodeVnd, CurrencyCodeXof, CurrencyCodeYer, CurrencyCodeZmw:
		return true
	}
	return false
}

func (e CurrencyCode) String() string {
	return string(e)
}

func (e *CurrencyCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CurrencyCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CurrencyCode", str)
	}
	return nil
}

func (e CurrencyCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The valid values for the marketing subscription opt-in active at the time the customer consented to email
// marketing.
//
// The levels are defined by [the M3AAWG best practices guideline
//   document](https://www.m3aawg.org/sites/maawg/files/news/M3AAWG_Senders_BCP_Ver3-2015-02.pdf).
//
type CustomerMarketingOptInLevel string

const (
	// The customer started receiving marketing email(s) after providing their email address, without any
	// intermediate steps.
	//
	CustomerMarketingOptInLevelSingleOptIn CustomerMarketingOptInLevel = "SINGLE_OPT_IN"
	// After providing their email address, the customer received a confirmation email which required them to
	// perform a prescribed action before receiving marketing emails.
	//
	CustomerMarketingOptInLevelConfirmedOptIn CustomerMarketingOptInLevel = "CONFIRMED_OPT_IN"
	// The customer receives marketing emails, but the original opt-in process is unknown.
	//
	CustomerMarketingOptInLevelUnknown CustomerMarketingOptInLevel = "UNKNOWN"
)

var AllCustomerMarketingOptInLevel = []CustomerMarketingOptInLevel{
	CustomerMarketingOptInLevelSingleOptIn,
	CustomerMarketingOptInLevelConfirmedOptIn,
	CustomerMarketingOptInLevelUnknown,
}

func (e CustomerMarketingOptInLevel) IsValid() bool {
	switch e {
	case CustomerMarketingOptInLevelSingleOptIn, CustomerMarketingOptInLevelConfirmedOptIn, CustomerMarketingOptInLevelUnknown:
		return true
	}
	return false
}

func (e CustomerMarketingOptInLevel) String() string {
	return string(e)
}

func (e *CustomerMarketingOptInLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerMarketingOptInLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerMarketingOptInLevel", str)
	}
	return nil
}

func (e CustomerMarketingOptInLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the CustomerSavedSearch query.
type CustomerSavedSearchSortKeys string

const (
	// Sort by the `name` value.
	CustomerSavedSearchSortKeysName CustomerSavedSearchSortKeys = "NAME"
	// Sort by the `id` value.
	CustomerSavedSearchSortKeysID CustomerSavedSearchSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	CustomerSavedSearchSortKeysRelevance CustomerSavedSearchSortKeys = "RELEVANCE"
)

var AllCustomerSavedSearchSortKeys = []CustomerSavedSearchSortKeys{
	CustomerSavedSearchSortKeysName,
	CustomerSavedSearchSortKeysID,
	CustomerSavedSearchSortKeysRelevance,
}

func (e CustomerSavedSearchSortKeys) IsValid() bool {
	switch e {
	case CustomerSavedSearchSortKeysName, CustomerSavedSearchSortKeysID, CustomerSavedSearchSortKeysRelevance:
		return true
	}
	return false
}

func (e CustomerSavedSearchSortKeys) String() string {
	return string(e)
}

func (e *CustomerSavedSearchSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSavedSearchSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSavedSearchSortKeys", str)
	}
	return nil
}

func (e CustomerSavedSearchSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Customer query.
type CustomerSortKeys string

const (
	// Sort by the `name` value.
	CustomerSortKeysName CustomerSortKeys = "NAME"
	// Sort by the `location` value.
	CustomerSortKeysLocation CustomerSortKeys = "LOCATION"
	// Sort by the `orders_count` value.
	CustomerSortKeysOrdersCount CustomerSortKeys = "ORDERS_COUNT"
	// Sort by the `last_order_date` value.
	CustomerSortKeysLastOrderDate CustomerSortKeys = "LAST_ORDER_DATE"
	// Sort by the `total_spent` value.
	CustomerSortKeysTotalSpent CustomerSortKeys = "TOTAL_SPENT"
	// Sort by the `updated_at` value.
	CustomerSortKeysUpdatedAt CustomerSortKeys = "UPDATED_AT"
	// Sort by the `id` value.
	CustomerSortKeysID CustomerSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	CustomerSortKeysRelevance CustomerSortKeys = "RELEVANCE"
)

var AllCustomerSortKeys = []CustomerSortKeys{
	CustomerSortKeysName,
	CustomerSortKeysLocation,
	CustomerSortKeysOrdersCount,
	CustomerSortKeysLastOrderDate,
	CustomerSortKeysTotalSpent,
	CustomerSortKeysUpdatedAt,
	CustomerSortKeysID,
	CustomerSortKeysRelevance,
}

func (e CustomerSortKeys) IsValid() bool {
	switch e {
	case CustomerSortKeysName, CustomerSortKeysLocation, CustomerSortKeysOrdersCount, CustomerSortKeysLastOrderDate, CustomerSortKeysTotalSpent, CustomerSortKeysUpdatedAt, CustomerSortKeysID, CustomerSortKeysRelevance:
		return true
	}
	return false
}

func (e CustomerSortKeys) String() string {
	return string(e)
}

func (e *CustomerSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerSortKeys", str)
	}
	return nil
}

func (e CustomerSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The valid values for the state of a customer's account with a shop.
type CustomerState string

const (
	// The customer declined the email invite to create an account.
	CustomerStateDeclined CustomerState = "DECLINED"
	// The customer doesn't have an active account. Customer accounts can be disabled from the Shopify admin at any time.
	CustomerStateDisabled CustomerState = "DISABLED"
	// The customer has created an account.
	CustomerStateEnabled CustomerState = "ENABLED"
	// The customer has received an email invite to create an account.
	CustomerStateInvited CustomerState = "INVITED"
)

var AllCustomerState = []CustomerState{
	CustomerStateDeclined,
	CustomerStateDisabled,
	CustomerStateEnabled,
	CustomerStateInvited,
}

func (e CustomerState) IsValid() bool {
	switch e {
	case CustomerStateDeclined, CustomerStateDisabled, CustomerStateEnabled, CustomerStateInvited:
		return true
	}
	return false
}

func (e CustomerState) String() string {
	return string(e)
}

func (e *CustomerState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerState", str)
	}
	return nil
}

func (e CustomerState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Days of the week from Monday to Sunday.
type DayOfTheWeek string

const (
	// Monday.
	DayOfTheWeekMonday DayOfTheWeek = "MONDAY"
	// Tuesday.
	DayOfTheWeekTuesday DayOfTheWeek = "TUESDAY"
	// Wednesday.
	DayOfTheWeekWednesday DayOfTheWeek = "WEDNESDAY"
	// Thursday.
	DayOfTheWeekThursday DayOfTheWeek = "THURSDAY"
	// Friday.
	DayOfTheWeekFriday DayOfTheWeek = "FRIDAY"
	// Saturday.
	DayOfTheWeekSaturday DayOfTheWeek = "SATURDAY"
	// Sunday.
	DayOfTheWeekSunday DayOfTheWeek = "SUNDAY"
)

var AllDayOfTheWeek = []DayOfTheWeek{
	DayOfTheWeekMonday,
	DayOfTheWeekTuesday,
	DayOfTheWeekWednesday,
	DayOfTheWeekThursday,
	DayOfTheWeekFriday,
	DayOfTheWeekSaturday,
	DayOfTheWeekSunday,
}

func (e DayOfTheWeek) IsValid() bool {
	switch e {
	case DayOfTheWeekMonday, DayOfTheWeekTuesday, DayOfTheWeekWednesday, DayOfTheWeekThursday, DayOfTheWeekFriday, DayOfTheWeekSaturday, DayOfTheWeekSunday:
		return true
	}
	return false
}

func (e DayOfTheWeek) String() string {
	return string(e)
}

func (e *DayOfTheWeek) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DayOfTheWeek(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DayOfTheWeek", str)
	}
	return nil
}

func (e DayOfTheWeek) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the DeletionEvent query.
type DeletionEventSortKeys string

const (
	// Sort by the `created_at` value.
	DeletionEventSortKeysCreatedAt DeletionEventSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	DeletionEventSortKeysID DeletionEventSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	DeletionEventSortKeysRelevance DeletionEventSortKeys = "RELEVANCE"
)

var AllDeletionEventSortKeys = []DeletionEventSortKeys{
	DeletionEventSortKeysCreatedAt,
	DeletionEventSortKeysID,
	DeletionEventSortKeysRelevance,
}

func (e DeletionEventSortKeys) IsValid() bool {
	switch e {
	case DeletionEventSortKeysCreatedAt, DeletionEventSortKeysID, DeletionEventSortKeysRelevance:
		return true
	}
	return false
}

func (e DeletionEventSortKeys) String() string {
	return string(e)
}

func (e *DeletionEventSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeletionEventSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeletionEventSortKeys", str)
	}
	return nil
}

func (e DeletionEventSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The supported subject types of deletion events.
type DeletionEventSubjectType string

const (
	DeletionEventSubjectTypeCollection DeletionEventSubjectType = "COLLECTION"
	DeletionEventSubjectTypeProduct    DeletionEventSubjectType = "PRODUCT"
)

var AllDeletionEventSubjectType = []DeletionEventSubjectType{
	DeletionEventSubjectTypeCollection,
	DeletionEventSubjectTypeProduct,
}

func (e DeletionEventSubjectType) IsValid() bool {
	switch e {
	case DeletionEventSubjectTypeCollection, DeletionEventSubjectTypeProduct:
		return true
	}
	return false
}

func (e DeletionEventSubjectType) String() string {
	return string(e)
}

func (e *DeletionEventSubjectType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeletionEventSubjectType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeletionEventSubjectType", str)
	}
	return nil
}

func (e DeletionEventSubjectType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The field type that the condition will be applied to.
type DeliveryConditionField string

const (
	// Condition will check against the total weight of the order.
	DeliveryConditionFieldTotalWeight DeliveryConditionField = "TOTAL_WEIGHT"
	// Condition will check against the total price of the order.
	DeliveryConditionFieldTotalPrice DeliveryConditionField = "TOTAL_PRICE"
)

var AllDeliveryConditionField = []DeliveryConditionField{
	DeliveryConditionFieldTotalWeight,
	DeliveryConditionFieldTotalPrice,
}

func (e DeliveryConditionField) IsValid() bool {
	switch e {
	case DeliveryConditionFieldTotalWeight, DeliveryConditionFieldTotalPrice:
		return true
	}
	return false
}

func (e DeliveryConditionField) String() string {
	return string(e)
}

func (e *DeliveryConditionField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeliveryConditionField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeliveryConditionField", str)
	}
	return nil
}

func (e DeliveryConditionField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The operator to use to determine if the condition passes.
type DeliveryConditionOperator string

const (
	// The condition will check if the field is greater than or equal to the criteria.
	DeliveryConditionOperatorGreaterThanOrEqualTo DeliveryConditionOperator = "GREATER_THAN_OR_EQUAL_TO"
	// The condition will check if the field is less than or equal to the criteria.
	DeliveryConditionOperatorLessThanOrEqualTo DeliveryConditionOperator = "LESS_THAN_OR_EQUAL_TO"
)

var AllDeliveryConditionOperator = []DeliveryConditionOperator{
	DeliveryConditionOperatorGreaterThanOrEqualTo,
	DeliveryConditionOperatorLessThanOrEqualTo,
}

func (e DeliveryConditionOperator) IsValid() bool {
	switch e {
	case DeliveryConditionOperatorGreaterThanOrEqualTo, DeliveryConditionOperatorLessThanOrEqualTo:
		return true
	}
	return false
}

func (e DeliveryConditionOperator) String() string {
	return string(e)
}

func (e *DeliveryConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeliveryConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeliveryConditionOperator", str)
	}
	return nil
}

func (e DeliveryConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reasons the shop is blocked from converting to full multi-location delivery profiles mode.
type DeliveryLegacyModeBlockedReason string

const (
	// Multi-Location is disabled.
	DeliveryLegacyModeBlockedReasonMultiLocationDisabled DeliveryLegacyModeBlockedReason = "MULTI_LOCATION_DISABLED"
	// No locations that can fulfill online orders.
	DeliveryLegacyModeBlockedReasonNoLocationsFulfillingOnlineOrders DeliveryLegacyModeBlockedReason = "NO_LOCATIONS_FULFILLING_ONLINE_ORDERS"
)

var AllDeliveryLegacyModeBlockedReason = []DeliveryLegacyModeBlockedReason{
	DeliveryLegacyModeBlockedReasonMultiLocationDisabled,
	DeliveryLegacyModeBlockedReasonNoLocationsFulfillingOnlineOrders,
}

func (e DeliveryLegacyModeBlockedReason) IsValid() bool {
	switch e {
	case DeliveryLegacyModeBlockedReasonMultiLocationDisabled, DeliveryLegacyModeBlockedReasonNoLocationsFulfillingOnlineOrders:
		return true
	}
	return false
}

func (e DeliveryLegacyModeBlockedReason) String() string {
	return string(e)
}

func (e *DeliveryLegacyModeBlockedReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeliveryLegacyModeBlockedReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeliveryLegacyModeBlockedReason", str)
	}
	return nil
}

func (e DeliveryLegacyModeBlockedReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different types of method definitions to filter by.
type DeliveryMethodDefinitionType string

const (
	// Static mechant-defined rates.
	DeliveryMethodDefinitionTypeMerchant DeliveryMethodDefinitionType = "MERCHANT"
	// Dynamic participant rates.
	DeliveryMethodDefinitionTypeParticipant DeliveryMethodDefinitionType = "PARTICIPANT"
)

var AllDeliveryMethodDefinitionType = []DeliveryMethodDefinitionType{
	DeliveryMethodDefinitionTypeMerchant,
	DeliveryMethodDefinitionTypeParticipant,
}

func (e DeliveryMethodDefinitionType) IsValid() bool {
	switch e {
	case DeliveryMethodDefinitionTypeMerchant, DeliveryMethodDefinitionTypeParticipant:
		return true
	}
	return false
}

func (e DeliveryMethodDefinitionType) String() string {
	return string(e)
}

func (e *DeliveryMethodDefinitionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeliveryMethodDefinitionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeliveryMethodDefinitionType", str)
	}
	return nil
}

func (e DeliveryMethodDefinitionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible method types that a delivery method can have.
type DeliveryMethodType string

const (
	// Shipping delivery method.
	DeliveryMethodTypeShipping DeliveryMethodType = "SHIPPING"
	// Pick-up delivery method.
	DeliveryMethodTypePickUp DeliveryMethodType = "PICK_UP"
	// No delivery method.
	DeliveryMethodTypeNone DeliveryMethodType = "NONE"
	// Retail delivery method represents items delivered immediately in a retail store.
	DeliveryMethodTypeRetail DeliveryMethodType = "RETAIL"
	// Local delivery method.
	DeliveryMethodTypeLocal DeliveryMethodType = "LOCAL"
)

var AllDeliveryMethodType = []DeliveryMethodType{
	DeliveryMethodTypeShipping,
	DeliveryMethodTypePickUp,
	DeliveryMethodTypeNone,
	DeliveryMethodTypeRetail,
	DeliveryMethodTypeLocal,
}

func (e DeliveryMethodType) IsValid() bool {
	switch e {
	case DeliveryMethodTypeShipping, DeliveryMethodTypePickUp, DeliveryMethodTypeNone, DeliveryMethodTypeRetail, DeliveryMethodTypeLocal:
		return true
	}
	return false
}

func (e DeliveryMethodType) String() string {
	return string(e)
}

func (e *DeliveryMethodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeliveryMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeliveryMethodType", str)
	}
	return nil
}

func (e DeliveryMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Digital wallet, such as Apple Pay, which can be used for accelerated checkouts.
type DigitalWallet string

const (
	// Apple Pay.
	DigitalWalletApplePay DigitalWallet = "APPLE_PAY"
	// Android Pay.
	DigitalWalletAndroidPay DigitalWallet = "ANDROID_PAY"
	// Google Pay.
	DigitalWalletGooglePay DigitalWallet = "GOOGLE_PAY"
	// Shopify Pay.
	DigitalWalletShopifyPay DigitalWallet = "SHOPIFY_PAY"
)

var AllDigitalWallet = []DigitalWallet{
	DigitalWalletApplePay,
	DigitalWalletAndroidPay,
	DigitalWalletGooglePay,
	DigitalWalletShopifyPay,
}

func (e DigitalWallet) IsValid() bool {
	switch e {
	case DigitalWalletApplePay, DigitalWalletAndroidPay, DigitalWalletGooglePay, DigitalWalletShopifyPay:
		return true
	}
	return false
}

func (e DigitalWallet) String() string {
	return string(e)
}

func (e *DigitalWallet) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DigitalWallet(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DigitalWallet", str)
	}
	return nil
}

func (e DigitalWallet) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The method by which the discount's value is allocated onto its entitled lines.
type DiscountApplicationAllocationMethod string

const (
	// The value is spread across all entitled lines.
	DiscountApplicationAllocationMethodAcross DiscountApplicationAllocationMethod = "ACROSS"
	// The value is applied onto every entitled line.
	DiscountApplicationAllocationMethodEach DiscountApplicationAllocationMethod = "EACH"
	// The value is specifically applied onto a particular line.
	DiscountApplicationAllocationMethodOne DiscountApplicationAllocationMethod = "ONE"
)

var AllDiscountApplicationAllocationMethod = []DiscountApplicationAllocationMethod{
	DiscountApplicationAllocationMethodAcross,
	DiscountApplicationAllocationMethodEach,
	DiscountApplicationAllocationMethodOne,
}

func (e DiscountApplicationAllocationMethod) IsValid() bool {
	switch e {
	case DiscountApplicationAllocationMethodAcross, DiscountApplicationAllocationMethodEach, DiscountApplicationAllocationMethodOne:
		return true
	}
	return false
}

func (e DiscountApplicationAllocationMethod) String() string {
	return string(e)
}

func (e *DiscountApplicationAllocationMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationAllocationMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationAllocationMethod", str)
	}
	return nil
}

func (e DiscountApplicationAllocationMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The method by which the discount's value is allocated onto its entitled lines.
type DiscountApplicationLevel string

const (
	// The discount was applied at the order level.
	// Order level discounts are not factored into the discountedUnitPriceSet on line items.
	//
	DiscountApplicationLevelOrder DiscountApplicationLevel = "ORDER"
	// The discount was applied at the line level.
	// Line level discounts are factored into the discountedUnitPriceSet on line items.
	//
	DiscountApplicationLevelLine DiscountApplicationLevel = "LINE"
)

var AllDiscountApplicationLevel = []DiscountApplicationLevel{
	DiscountApplicationLevelOrder,
	DiscountApplicationLevelLine,
}

func (e DiscountApplicationLevel) IsValid() bool {
	switch e {
	case DiscountApplicationLevelOrder, DiscountApplicationLevelLine:
		return true
	}
	return false
}

func (e DiscountApplicationLevel) String() string {
	return string(e)
}

func (e *DiscountApplicationLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationLevel", str)
	}
	return nil
}

func (e DiscountApplicationLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Which lines on the order that the discount is allocated over, of the type
// defined by the Discount Application's target_type.
//
type DiscountApplicationTargetSelection string

const (
	// The discount is allocated onto all the lines.
	DiscountApplicationTargetSelectionAll DiscountApplicationTargetSelection = "ALL"
	// The discount is allocated onto only the lines it is entitled for.
	DiscountApplicationTargetSelectionEntitled DiscountApplicationTargetSelection = "ENTITLED"
	// The discount is allocated onto explicitly chosen lines.
	DiscountApplicationTargetSelectionExplicit DiscountApplicationTargetSelection = "EXPLICIT"
)

var AllDiscountApplicationTargetSelection = []DiscountApplicationTargetSelection{
	DiscountApplicationTargetSelectionAll,
	DiscountApplicationTargetSelectionEntitled,
	DiscountApplicationTargetSelectionExplicit,
}

func (e DiscountApplicationTargetSelection) IsValid() bool {
	switch e {
	case DiscountApplicationTargetSelectionAll, DiscountApplicationTargetSelectionEntitled, DiscountApplicationTargetSelectionExplicit:
		return true
	}
	return false
}

func (e DiscountApplicationTargetSelection) String() string {
	return string(e)
}

func (e *DiscountApplicationTargetSelection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationTargetSelection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationTargetSelection", str)
	}
	return nil
}

func (e DiscountApplicationTargetSelection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of line (i.e. line item or shipping line) on an order that the discount is applicable towards.
//
type DiscountApplicationTargetType string

const (
	// The discount applies onto line items.
	DiscountApplicationTargetTypeLineItem DiscountApplicationTargetType = "LINE_ITEM"
	// The discount applies onto shipping lines.
	DiscountApplicationTargetTypeShippingLine DiscountApplicationTargetType = "SHIPPING_LINE"
)

var AllDiscountApplicationTargetType = []DiscountApplicationTargetType{
	DiscountApplicationTargetTypeLineItem,
	DiscountApplicationTargetTypeShippingLine,
}

func (e DiscountApplicationTargetType) IsValid() bool {
	switch e {
	case DiscountApplicationTargetTypeLineItem, DiscountApplicationTargetTypeShippingLine:
		return true
	}
	return false
}

func (e DiscountApplicationTargetType) String() string {
	return string(e)
}

func (e *DiscountApplicationTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountApplicationTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountApplicationTargetType", str)
	}
	return nil
}

func (e DiscountApplicationTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the DiscountCode query.
type DiscountCodeSortKeys string

const (
	// Sort by the `code` value.
	DiscountCodeSortKeysCode DiscountCodeSortKeys = "CODE"
	// Sort by the `created_at` value.
	DiscountCodeSortKeysCreatedAt DiscountCodeSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	DiscountCodeSortKeysID DiscountCodeSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	DiscountCodeSortKeysRelevance DiscountCodeSortKeys = "RELEVANCE"
)

var AllDiscountCodeSortKeys = []DiscountCodeSortKeys{
	DiscountCodeSortKeysCode,
	DiscountCodeSortKeysCreatedAt,
	DiscountCodeSortKeysID,
	DiscountCodeSortKeysRelevance,
}

func (e DiscountCodeSortKeys) IsValid() bool {
	switch e {
	case DiscountCodeSortKeysCode, DiscountCodeSortKeysCreatedAt, DiscountCodeSortKeysID, DiscountCodeSortKeysRelevance:
		return true
	}
	return false
}

func (e DiscountCodeSortKeys) String() string {
	return string(e)
}

func (e *DiscountCodeSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountCodeSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountCodeSortKeys", str)
	}
	return nil
}

func (e DiscountCodeSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by DiscountUserError.
type DiscountErrorCode string

const (
	// Input value is blank.
	DiscountErrorCodeBlank DiscountErrorCode = "BLANK"
	// Input value is not present.
	DiscountErrorCodePresent DiscountErrorCode = "PRESENT"
	// Input value should be equal to allowed value.
	DiscountErrorCodeEqualTo DiscountErrorCode = "EQUAL_TO"
	// Input value should be greater than minimum allowed value.
	DiscountErrorCodeGreaterThan DiscountErrorCode = "GREATER_THAN"
	// Input value should be greater than or equal to minimum allowed value.
	DiscountErrorCodeGreaterThanOrEqualTo DiscountErrorCode = "GREATER_THAN_OR_EQUAL_TO"
	// Input value is invalid.
	DiscountErrorCodeInvalid DiscountErrorCode = "INVALID"
	// Input value should be less or equal to maximum allowed value.
	DiscountErrorCodeLessThanOrEqualTo DiscountErrorCode = "LESS_THAN_OR_EQUAL_TO"
	// Input value should be less than maximum allowed value.
	DiscountErrorCodeLessThan DiscountErrorCode = "LESS_THAN"
	// Input value is already taken.
	DiscountErrorCodeTaken DiscountErrorCode = "TAKEN"
	// Input value is too long.
	DiscountErrorCodeTooLong DiscountErrorCode = "TOO_LONG"
	// Input value is too short.
	DiscountErrorCodeTooShort DiscountErrorCode = "TOO_SHORT"
	// Unexpected internal error happened.
	DiscountErrorCodeInternalError DiscountErrorCode = "INTERNAL_ERROR"
	// Too many arguments provided.
	DiscountErrorCodeTooManyArguments DiscountErrorCode = "TOO_MANY_ARGUMENTS"
	// Missing a required argument.
	DiscountErrorCodeMissingArgument DiscountErrorCode = "MISSING_ARGUMENT"
	// Value is outside allowed range.
	DiscountErrorCodeValueOutsideRange DiscountErrorCode = "VALUE_OUTSIDE_RANGE"
	// Exceeded maximum allowed value.
	DiscountErrorCodeExceededMax DiscountErrorCode = "EXCEEDED_MAX"
	// Cannot have both minimum subtotal and quantity present.
	DiscountErrorCodeMinimumSubtotalAndQuantityRangeBothPresent DiscountErrorCode = "MINIMUM_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT"
	// Active period overlaps with other automatic discounts. At any given time, only one automatic discount can be active.
	DiscountErrorCodeActivePeriodOverlap DiscountErrorCode = "ACTIVE_PERIOD_OVERLAP"
	// Attribute selection contains conflicting settings.
	DiscountErrorCodeConflict DiscountErrorCode = "CONFLICT"
	// Value is already present through another selection.
	DiscountErrorCodeImplicitDuplicate DiscountErrorCode = "IMPLICIT_DUPLICATE"
	// Input value is already present.
	DiscountErrorCodeDuplicate DiscountErrorCode = "DUPLICATE"
	// Input value is not included in the list.
	DiscountErrorCodeInclusion DiscountErrorCode = "INCLUSION"
)

var AllDiscountErrorCode = []DiscountErrorCode{
	DiscountErrorCodeBlank,
	DiscountErrorCodePresent,
	DiscountErrorCodeEqualTo,
	DiscountErrorCodeGreaterThan,
	DiscountErrorCodeGreaterThanOrEqualTo,
	DiscountErrorCodeInvalid,
	DiscountErrorCodeLessThanOrEqualTo,
	DiscountErrorCodeLessThan,
	DiscountErrorCodeTaken,
	DiscountErrorCodeTooLong,
	DiscountErrorCodeTooShort,
	DiscountErrorCodeInternalError,
	DiscountErrorCodeTooManyArguments,
	DiscountErrorCodeMissingArgument,
	DiscountErrorCodeValueOutsideRange,
	DiscountErrorCodeExceededMax,
	DiscountErrorCodeMinimumSubtotalAndQuantityRangeBothPresent,
	DiscountErrorCodeActivePeriodOverlap,
	DiscountErrorCodeConflict,
	DiscountErrorCodeImplicitDuplicate,
	DiscountErrorCodeDuplicate,
	DiscountErrorCodeInclusion,
}

func (e DiscountErrorCode) IsValid() bool {
	switch e {
	case DiscountErrorCodeBlank, DiscountErrorCodePresent, DiscountErrorCodeEqualTo, DiscountErrorCodeGreaterThan, DiscountErrorCodeGreaterThanOrEqualTo, DiscountErrorCodeInvalid, DiscountErrorCodeLessThanOrEqualTo, DiscountErrorCodeLessThan, DiscountErrorCodeTaken, DiscountErrorCodeTooLong, DiscountErrorCodeTooShort, DiscountErrorCodeInternalError, DiscountErrorCodeTooManyArguments, DiscountErrorCodeMissingArgument, DiscountErrorCodeValueOutsideRange, DiscountErrorCodeExceededMax, DiscountErrorCodeMinimumSubtotalAndQuantityRangeBothPresent, DiscountErrorCodeActivePeriodOverlap, DiscountErrorCodeConflict, DiscountErrorCodeImplicitDuplicate, DiscountErrorCodeDuplicate, DiscountErrorCodeInclusion:
		return true
	}
	return false
}

func (e DiscountErrorCode) String() string {
	return string(e)
}

func (e *DiscountErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountErrorCode", str)
	}
	return nil
}

func (e DiscountErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The page type where shareable URL lands.
type DiscountShareableURLTargetType string

const (
	// The home page type.
	DiscountShareableURLTargetTypeHome DiscountShareableURLTargetType = "HOME"
	// The product page type.
	DiscountShareableURLTargetTypeProduct DiscountShareableURLTargetType = "PRODUCT"
	// The collection page type.
	DiscountShareableURLTargetTypeCollection DiscountShareableURLTargetType = "COLLECTION"
)

var AllDiscountShareableURLTargetType = []DiscountShareableURLTargetType{
	DiscountShareableURLTargetTypeHome,
	DiscountShareableURLTargetTypeProduct,
	DiscountShareableURLTargetTypeCollection,
}

func (e DiscountShareableURLTargetType) IsValid() bool {
	switch e {
	case DiscountShareableURLTargetTypeHome, DiscountShareableURLTargetTypeProduct, DiscountShareableURLTargetTypeCollection:
		return true
	}
	return false
}

func (e DiscountShareableURLTargetType) String() string {
	return string(e)
}

func (e *DiscountShareableURLTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountShareableURLTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountShareableUrlTargetType", str)
	}
	return nil
}

func (e DiscountShareableURLTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the discount.
type DiscountStatus string

const (
	// The discount is active.
	DiscountStatusActive DiscountStatus = "ACTIVE"
	// The discount is expired.
	DiscountStatusExpired DiscountStatus = "EXPIRED"
	// The discount is scheduled.
	DiscountStatusScheduled DiscountStatus = "SCHEDULED"
)

var AllDiscountStatus = []DiscountStatus{
	DiscountStatusActive,
	DiscountStatusExpired,
	DiscountStatusScheduled,
}

func (e DiscountStatus) IsValid() bool {
	switch e {
	case DiscountStatusActive, DiscountStatusExpired, DiscountStatusScheduled:
		return true
	}
	return false
}

func (e DiscountStatus) String() string {
	return string(e)
}

func (e *DiscountStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiscountStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiscountStatus", str)
	}
	return nil
}

func (e DiscountStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible statuses of a dispute.
type DisputeStatus string

const (
	DisputeStatusNeedsResponse  DisputeStatus = "NEEDS_RESPONSE"
	DisputeStatusUnderReview    DisputeStatus = "UNDER_REVIEW"
	DisputeStatusChargeRefunded DisputeStatus = "CHARGE_REFUNDED"
	DisputeStatusAccepted       DisputeStatus = "ACCEPTED"
	DisputeStatusWon            DisputeStatus = "WON"
	DisputeStatusLost           DisputeStatus = "LOST"
)

var AllDisputeStatus = []DisputeStatus{
	DisputeStatusNeedsResponse,
	DisputeStatusUnderReview,
	DisputeStatusChargeRefunded,
	DisputeStatusAccepted,
	DisputeStatusWon,
	DisputeStatusLost,
}

func (e DisputeStatus) IsValid() bool {
	switch e {
	case DisputeStatusNeedsResponse, DisputeStatusUnderReview, DisputeStatusChargeRefunded, DisputeStatusAccepted, DisputeStatusWon, DisputeStatusLost:
		return true
	}
	return false
}

func (e DisputeStatus) String() string {
	return string(e)
}

func (e *DisputeStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisputeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisputeStatus", str)
	}
	return nil
}

func (e DisputeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible types for a dispute.
type DisputeType string

const (
	// The dispute has turned into a chargeback.
	DisputeTypeChargeback DisputeType = "CHARGEBACK"
	// The dispute is in the inquiry phase.
	DisputeTypeInquiry DisputeType = "INQUIRY"
)

var AllDisputeType = []DisputeType{
	DisputeTypeChargeback,
	DisputeTypeInquiry,
}

func (e DisputeType) IsValid() bool {
	switch e {
	case DisputeTypeChargeback, DisputeTypeInquiry:
		return true
	}
	return false
}

func (e DisputeType) String() string {
	return string(e)
}

func (e *DisputeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisputeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisputeType", str)
	}
	return nil
}

func (e DisputeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The valid discount types that can be applied to a draft order.
type DraftOrderAppliedDiscountType string

const (
	// A fixed amount in the store's currency.
	DraftOrderAppliedDiscountTypeFixedAmount DraftOrderAppliedDiscountType = "FIXED_AMOUNT"
	// A percentage of the order subtotal.
	DraftOrderAppliedDiscountTypePercentage DraftOrderAppliedDiscountType = "PERCENTAGE"
)

var AllDraftOrderAppliedDiscountType = []DraftOrderAppliedDiscountType{
	DraftOrderAppliedDiscountTypeFixedAmount,
	DraftOrderAppliedDiscountTypePercentage,
}

func (e DraftOrderAppliedDiscountType) IsValid() bool {
	switch e {
	case DraftOrderAppliedDiscountTypeFixedAmount, DraftOrderAppliedDiscountTypePercentage:
		return true
	}
	return false
}

func (e DraftOrderAppliedDiscountType) String() string {
	return string(e)
}

func (e *DraftOrderAppliedDiscountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DraftOrderAppliedDiscountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DraftOrderAppliedDiscountType", str)
	}
	return nil
}

func (e DraftOrderAppliedDiscountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the DraftOrder query.
type DraftOrderSortKeys string

const (
	// Sort by the `number` value.
	DraftOrderSortKeysNumber DraftOrderSortKeys = "NUMBER"
	// Sort by the `updated_at` value.
	DraftOrderSortKeysUpdatedAt DraftOrderSortKeys = "UPDATED_AT"
	// Sort by the `status` value.
	DraftOrderSortKeysStatus DraftOrderSortKeys = "STATUS"
	// Sort by the `total_price` value.
	DraftOrderSortKeysTotalPrice DraftOrderSortKeys = "TOTAL_PRICE"
	// Sort by the `customer_name` value.
	DraftOrderSortKeysCustomerName DraftOrderSortKeys = "CUSTOMER_NAME"
	// Sort by the `id` value.
	DraftOrderSortKeysID DraftOrderSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	DraftOrderSortKeysRelevance DraftOrderSortKeys = "RELEVANCE"
)

var AllDraftOrderSortKeys = []DraftOrderSortKeys{
	DraftOrderSortKeysNumber,
	DraftOrderSortKeysUpdatedAt,
	DraftOrderSortKeysStatus,
	DraftOrderSortKeysTotalPrice,
	DraftOrderSortKeysCustomerName,
	DraftOrderSortKeysID,
	DraftOrderSortKeysRelevance,
}

func (e DraftOrderSortKeys) IsValid() bool {
	switch e {
	case DraftOrderSortKeysNumber, DraftOrderSortKeysUpdatedAt, DraftOrderSortKeysStatus, DraftOrderSortKeysTotalPrice, DraftOrderSortKeysCustomerName, DraftOrderSortKeysID, DraftOrderSortKeysRelevance:
		return true
	}
	return false
}

func (e DraftOrderSortKeys) String() string {
	return string(e)
}

func (e *DraftOrderSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DraftOrderSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DraftOrderSortKeys", str)
	}
	return nil
}

func (e DraftOrderSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The valid statuses for a draft order.
type DraftOrderStatus string

const (
	// The draft order has been paid.
	DraftOrderStatusCompleted DraftOrderStatus = "COMPLETED"
	// An invoice for the draft order has been sent to the customer.
	DraftOrderStatusInvoiceSent DraftOrderStatus = "INVOICE_SENT"
	// The draft order is open. It has not been paid, and an invoice hasn't been sent.
	DraftOrderStatusOpen DraftOrderStatus = "OPEN"
)

var AllDraftOrderStatus = []DraftOrderStatus{
	DraftOrderStatusCompleted,
	DraftOrderStatusInvoiceSent,
	DraftOrderStatusOpen,
}

func (e DraftOrderStatus) IsValid() bool {
	switch e {
	case DraftOrderStatusCompleted, DraftOrderStatusInvoiceSent, DraftOrderStatusOpen:
		return true
	}
	return false
}

func (e DraftOrderStatus) String() string {
	return string(e)
}

func (e *DraftOrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DraftOrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DraftOrderStatus", str)
	}
	return nil
}

func (e DraftOrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Event query.
type EventSortKeys string

const (
	// Sort by the `created_at` value.
	EventSortKeysCreatedAt EventSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	EventSortKeysID EventSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	EventSortKeysRelevance EventSortKeys = "RELEVANCE"
)

var AllEventSortKeys = []EventSortKeys{
	EventSortKeysCreatedAt,
	EventSortKeysID,
	EventSortKeysRelevance,
}

func (e EventSortKeys) IsValid() bool {
	switch e {
	case EventSortKeysCreatedAt, EventSortKeysID, EventSortKeysRelevance:
		return true
	}
	return false
}

func (e EventSortKeys) String() string {
	return string(e)
}

func (e *EventSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventSortKeys", str)
	}
	return nil
}

func (e EventSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The display status of a fulfillment.
type FulfillmentDisplayStatus string

const (
	// Displayed as **Attempted delivery**.
	FulfillmentDisplayStatusAttemptedDelivery FulfillmentDisplayStatus = "ATTEMPTED_DELIVERY"
	// Displayed as **Canceled**.
	FulfillmentDisplayStatusCanceled FulfillmentDisplayStatus = "CANCELED"
	// Displayed as **Confirmed**.
	FulfillmentDisplayStatusConfirmed FulfillmentDisplayStatus = "CONFIRMED"
	// Displayed as **Delivered**.
	FulfillmentDisplayStatusDelivered FulfillmentDisplayStatus = "DELIVERED"
	// Displayed as **Failure**.
	FulfillmentDisplayStatusFailure FulfillmentDisplayStatus = "FAILURE"
	// Displayed as **Fulfilled**.
	FulfillmentDisplayStatusFulfilled FulfillmentDisplayStatus = "FULFILLED"
	// Displayed as **In transit**.
	FulfillmentDisplayStatusInTransit FulfillmentDisplayStatus = "IN_TRANSIT"
	// Displayed as **Label printed**.
	FulfillmentDisplayStatusLabelPrinted FulfillmentDisplayStatus = "LABEL_PRINTED"
	// Displayed as **Label purchased**.
	FulfillmentDisplayStatusLabelPurchased FulfillmentDisplayStatus = "LABEL_PURCHASED"
	// Displayed as **Label voided**.
	FulfillmentDisplayStatusLabelVoided FulfillmentDisplayStatus = "LABEL_VOIDED"
	// Displayed as **Marked as fulfilled**.
	FulfillmentDisplayStatusMarkedAsFulfilled FulfillmentDisplayStatus = "MARKED_AS_FULFILLED"
	// Displayed as **Not delivered**.
	FulfillmentDisplayStatusNotDelivered FulfillmentDisplayStatus = "NOT_DELIVERED"
	// Displayed as **Out for delivery**.
	FulfillmentDisplayStatusOutForDelivery FulfillmentDisplayStatus = "OUT_FOR_DELIVERY"
	// Displayed as **Ready for pickup**.
	FulfillmentDisplayStatusReadyForPickup FulfillmentDisplayStatus = "READY_FOR_PICKUP"
	// Displayed as **Submitted**.
	FulfillmentDisplayStatusSubmitted FulfillmentDisplayStatus = "SUBMITTED"
)

var AllFulfillmentDisplayStatus = []FulfillmentDisplayStatus{
	FulfillmentDisplayStatusAttemptedDelivery,
	FulfillmentDisplayStatusCanceled,
	FulfillmentDisplayStatusConfirmed,
	FulfillmentDisplayStatusDelivered,
	FulfillmentDisplayStatusFailure,
	FulfillmentDisplayStatusFulfilled,
	FulfillmentDisplayStatusInTransit,
	FulfillmentDisplayStatusLabelPrinted,
	FulfillmentDisplayStatusLabelPurchased,
	FulfillmentDisplayStatusLabelVoided,
	FulfillmentDisplayStatusMarkedAsFulfilled,
	FulfillmentDisplayStatusNotDelivered,
	FulfillmentDisplayStatusOutForDelivery,
	FulfillmentDisplayStatusReadyForPickup,
	FulfillmentDisplayStatusSubmitted,
}

func (e FulfillmentDisplayStatus) IsValid() bool {
	switch e {
	case FulfillmentDisplayStatusAttemptedDelivery, FulfillmentDisplayStatusCanceled, FulfillmentDisplayStatusConfirmed, FulfillmentDisplayStatusDelivered, FulfillmentDisplayStatusFailure, FulfillmentDisplayStatusFulfilled, FulfillmentDisplayStatusInTransit, FulfillmentDisplayStatusLabelPrinted, FulfillmentDisplayStatusLabelPurchased, FulfillmentDisplayStatusLabelVoided, FulfillmentDisplayStatusMarkedAsFulfilled, FulfillmentDisplayStatusNotDelivered, FulfillmentDisplayStatusOutForDelivery, FulfillmentDisplayStatusReadyForPickup, FulfillmentDisplayStatusSubmitted:
		return true
	}
	return false
}

func (e FulfillmentDisplayStatus) String() string {
	return string(e)
}

func (e *FulfillmentDisplayStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentDisplayStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentDisplayStatus", str)
	}
	return nil
}

func (e FulfillmentDisplayStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the FulfillmentEvent query.
type FulfillmentEventSortKeys string

const (
	// Sort by the `happened_at` value.
	FulfillmentEventSortKeysHappenedAt FulfillmentEventSortKeys = "HAPPENED_AT"
	// Sort by the `id` value.
	FulfillmentEventSortKeysID FulfillmentEventSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	FulfillmentEventSortKeysRelevance FulfillmentEventSortKeys = "RELEVANCE"
)

var AllFulfillmentEventSortKeys = []FulfillmentEventSortKeys{
	FulfillmentEventSortKeysHappenedAt,
	FulfillmentEventSortKeysID,
	FulfillmentEventSortKeysRelevance,
}

func (e FulfillmentEventSortKeys) IsValid() bool {
	switch e {
	case FulfillmentEventSortKeysHappenedAt, FulfillmentEventSortKeysID, FulfillmentEventSortKeysRelevance:
		return true
	}
	return false
}

func (e FulfillmentEventSortKeys) String() string {
	return string(e)
}

func (e *FulfillmentEventSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentEventSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentEventSortKeys", str)
	}
	return nil
}

func (e FulfillmentEventSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Event status' describe the status of a fulfillment.
type FulfillmentEventStatus string

const (
	// A shipping label has been purchased.
	FulfillmentEventStatusLabelPurchased FulfillmentEventStatus = "LABEL_PURCHASED"
	// A purchased shipping label has been printed.
	FulfillmentEventStatusLabelPrinted FulfillmentEventStatus = "LABEL_PRINTED"
	// The fulfillment is ready to be picked up.
	FulfillmentEventStatusReadyForPickup FulfillmentEventStatus = "READY_FOR_PICKUP"
	// The fulfillment is confirmed.
	FulfillmentEventStatusConfirmed FulfillmentEventStatus = "CONFIRMED"
	// The fulfillment is in transit.
	FulfillmentEventStatusInTransit FulfillmentEventStatus = "IN_TRANSIT"
	// The fulfillment is out for delivery.
	FulfillmentEventStatusOutForDelivery FulfillmentEventStatus = "OUT_FOR_DELIVERY"
	// A delivery was attempted.
	FulfillmentEventStatusAttemptedDelivery FulfillmentEventStatus = "ATTEMPTED_DELIVERY"
	// The fulfillment was successfully delivered.
	FulfillmentEventStatusDelivered FulfillmentEventStatus = "DELIVERED"
	// The fulfillment request failed.
	FulfillmentEventStatusFailure FulfillmentEventStatus = "FAILURE"
)

var AllFulfillmentEventStatus = []FulfillmentEventStatus{
	FulfillmentEventStatusLabelPurchased,
	FulfillmentEventStatusLabelPrinted,
	FulfillmentEventStatusReadyForPickup,
	FulfillmentEventStatusConfirmed,
	FulfillmentEventStatusInTransit,
	FulfillmentEventStatusOutForDelivery,
	FulfillmentEventStatusAttemptedDelivery,
	FulfillmentEventStatusDelivered,
	FulfillmentEventStatusFailure,
}

func (e FulfillmentEventStatus) IsValid() bool {
	switch e {
	case FulfillmentEventStatusLabelPurchased, FulfillmentEventStatusLabelPrinted, FulfillmentEventStatusReadyForPickup, FulfillmentEventStatusConfirmed, FulfillmentEventStatusInTransit, FulfillmentEventStatusOutForDelivery, FulfillmentEventStatusAttemptedDelivery, FulfillmentEventStatusDelivered, FulfillmentEventStatusFailure:
		return true
	}
	return false
}

func (e FulfillmentEventStatus) String() string {
	return string(e)
}

func (e *FulfillmentEventStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentEventStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentEventStatus", str)
	}
	return nil
}

func (e FulfillmentEventStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The actions that can be taken on a fulfillment order.
type FulfillmentOrderAction string

const (
	// Create a fulfillment for selected line items in the fulfillment order. The corresponding mutation for this action is FulfillmentCreateV2.
	FulfillmentOrderActionCreateFulfillment FulfillmentOrderAction = "CREATE_FULFILLMENT"
	// Send a request for fulfilling selected line items in a fulfillment order to a fulfillment service. The corresponding mutation for this action is FulfillmentOrderSubmitFulfillmentRequest.
	FulfillmentOrderActionRequestFulfillment FulfillmentOrderAction = "REQUEST_FULFILLMENT"
	// Cancel a fulfillment order. The corresponding mutation for this action is FulfillmentOrderCancel.
	FulfillmentOrderActionCancelFulfillmentOrder FulfillmentOrderAction = "CANCEL_FULFILLMENT_ORDER"
	// Move a fulfillment order. The corresponding mutation for this action is FulfillmentOrderMove.
	FulfillmentOrderActionMove FulfillmentOrderAction = "MOVE"
	// Send a cancellation request to the fulfillment service of a fulfillment order. The corresponding mutation for this action is FulfillmentOrderSubmitCancellationRequest.
	FulfillmentOrderActionRequestCancellation FulfillmentOrderAction = "REQUEST_CANCELLATION"
	// Open an external URL to initiate the fulfillment process outside Shopify.
	FulfillmentOrderActionExternal FulfillmentOrderAction = "EXTERNAL"
)

var AllFulfillmentOrderAction = []FulfillmentOrderAction{
	FulfillmentOrderActionCreateFulfillment,
	FulfillmentOrderActionRequestFulfillment,
	FulfillmentOrderActionCancelFulfillmentOrder,
	FulfillmentOrderActionMove,
	FulfillmentOrderActionRequestCancellation,
	FulfillmentOrderActionExternal,
}

func (e FulfillmentOrderAction) IsValid() bool {
	switch e {
	case FulfillmentOrderActionCreateFulfillment, FulfillmentOrderActionRequestFulfillment, FulfillmentOrderActionCancelFulfillmentOrder, FulfillmentOrderActionMove, FulfillmentOrderActionRequestCancellation, FulfillmentOrderActionExternal:
		return true
	}
	return false
}

func (e FulfillmentOrderAction) String() string {
	return string(e)
}

func (e *FulfillmentOrderAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentOrderAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentOrderAction", str)
	}
	return nil
}

func (e FulfillmentOrderAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The assigment status to be used to filter fulfillment orders.
type FulfillmentOrderAssignmentStatus string

const (
	// Fulfillment orders for which the merchant has requested cancellation of
	// the previously accepted fulfillment request.
	//
	FulfillmentOrderAssignmentStatusCancellationRequested FulfillmentOrderAssignmentStatus = "CANCELLATION_REQUESTED"
	// Fulfillment orders for which the merchant has requested fulfillment.
	//
	FulfillmentOrderAssignmentStatusFulfillmentRequested FulfillmentOrderAssignmentStatus = "FULFILLMENT_REQUESTED"
	// Fulfillment orders for which the merchant's fulfillment request has been accepted.
	// Any number of fulfillments can be created on these fulfillment orders
	// to completely fulfill the requested items.
	//
	FulfillmentOrderAssignmentStatusFulfillmentAccepted FulfillmentOrderAssignmentStatus = "FULFILLMENT_ACCEPTED"
)

var AllFulfillmentOrderAssignmentStatus = []FulfillmentOrderAssignmentStatus{
	FulfillmentOrderAssignmentStatusCancellationRequested,
	FulfillmentOrderAssignmentStatusFulfillmentRequested,
	FulfillmentOrderAssignmentStatusFulfillmentAccepted,
}

func (e FulfillmentOrderAssignmentStatus) IsValid() bool {
	switch e {
	case FulfillmentOrderAssignmentStatusCancellationRequested, FulfillmentOrderAssignmentStatusFulfillmentRequested, FulfillmentOrderAssignmentStatusFulfillmentAccepted:
		return true
	}
	return false
}

func (e FulfillmentOrderAssignmentStatus) String() string {
	return string(e)
}

func (e *FulfillmentOrderAssignmentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentOrderAssignmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentOrderAssignmentStatus", str)
	}
	return nil
}

func (e FulfillmentOrderAssignmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The kinds of request merchants can make to a fulfillment service.
type FulfillmentOrderMerchantRequestKind string

const (
	// The merchant requested fulfillment for a fulfillment order.
	//
	FulfillmentOrderMerchantRequestKindFulfillmentRequest FulfillmentOrderMerchantRequestKind = "FULFILLMENT_REQUEST"
	// The merchant requested cancellation of an accepted or in-progress fulfillment order.
	//
	FulfillmentOrderMerchantRequestKindCancellationRequest FulfillmentOrderMerchantRequestKind = "CANCELLATION_REQUEST"
)

var AllFulfillmentOrderMerchantRequestKind = []FulfillmentOrderMerchantRequestKind{
	FulfillmentOrderMerchantRequestKindFulfillmentRequest,
	FulfillmentOrderMerchantRequestKindCancellationRequest,
}

func (e FulfillmentOrderMerchantRequestKind) IsValid() bool {
	switch e {
	case FulfillmentOrderMerchantRequestKindFulfillmentRequest, FulfillmentOrderMerchantRequestKindCancellationRequest:
		return true
	}
	return false
}

func (e FulfillmentOrderMerchantRequestKind) String() string {
	return string(e)
}

func (e *FulfillmentOrderMerchantRequestKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentOrderMerchantRequestKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentOrderMerchantRequestKind", str)
	}
	return nil
}

func (e FulfillmentOrderMerchantRequestKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The request status of a fulfillment order.
type FulfillmentOrderRequestStatus string

const (
	// The initial request status for the newly created fulfillment orders. This is the only valid
	// request status for fulfillment orders that aren't assigned to a fulfillment service.
	//
	FulfillmentOrderRequestStatusUnsubmitted FulfillmentOrderRequestStatus = "UNSUBMITTED"
	// The merchant requested fulfillment for this fulfillment order.
	FulfillmentOrderRequestStatusSubmitted FulfillmentOrderRequestStatus = "SUBMITTED"
	// The fulfillment service accepted the merchant's fulfillment request.
	FulfillmentOrderRequestStatusAccepted FulfillmentOrderRequestStatus = "ACCEPTED"
	// The fulfillment service rejected the merchant's fulfillment request.
	FulfillmentOrderRequestStatusRejected FulfillmentOrderRequestStatus = "REJECTED"
	// The merchant requested a cancellation of the fulfillment request for this fulfillment order.
	//
	FulfillmentOrderRequestStatusCancellationRequested FulfillmentOrderRequestStatus = "CANCELLATION_REQUESTED"
	// The fulfillment service accepted the merchant's fulfillment cancellation request.
	//
	FulfillmentOrderRequestStatusCancellationAccepted FulfillmentOrderRequestStatus = "CANCELLATION_ACCEPTED"
	// The fulfillment service rejected the merchant's fulfillment cancellation request.
	//
	FulfillmentOrderRequestStatusCancellationRejected FulfillmentOrderRequestStatus = "CANCELLATION_REJECTED"
	// The fulfillment service closed the fulfillment order without completing it.
	FulfillmentOrderRequestStatusClosed FulfillmentOrderRequestStatus = "CLOSED"
)

var AllFulfillmentOrderRequestStatus = []FulfillmentOrderRequestStatus{
	FulfillmentOrderRequestStatusUnsubmitted,
	FulfillmentOrderRequestStatusSubmitted,
	FulfillmentOrderRequestStatusAccepted,
	FulfillmentOrderRequestStatusRejected,
	FulfillmentOrderRequestStatusCancellationRequested,
	FulfillmentOrderRequestStatusCancellationAccepted,
	FulfillmentOrderRequestStatusCancellationRejected,
	FulfillmentOrderRequestStatusClosed,
}

func (e FulfillmentOrderRequestStatus) IsValid() bool {
	switch e {
	case FulfillmentOrderRequestStatusUnsubmitted, FulfillmentOrderRequestStatusSubmitted, FulfillmentOrderRequestStatusAccepted, FulfillmentOrderRequestStatusRejected, FulfillmentOrderRequestStatusCancellationRequested, FulfillmentOrderRequestStatusCancellationAccepted, FulfillmentOrderRequestStatusCancellationRejected, FulfillmentOrderRequestStatusClosed:
		return true
	}
	return false
}

func (e FulfillmentOrderRequestStatus) String() string {
	return string(e)
}

func (e *FulfillmentOrderRequestStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentOrderRequestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentOrderRequestStatus", str)
	}
	return nil
}

func (e FulfillmentOrderRequestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the FulfillmentOrder query.
type FulfillmentOrderSortKeys string

const (
	// Sort by the `id` value.
	FulfillmentOrderSortKeysID FulfillmentOrderSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	FulfillmentOrderSortKeysRelevance FulfillmentOrderSortKeys = "RELEVANCE"
)

var AllFulfillmentOrderSortKeys = []FulfillmentOrderSortKeys{
	FulfillmentOrderSortKeysID,
	FulfillmentOrderSortKeysRelevance,
}

func (e FulfillmentOrderSortKeys) IsValid() bool {
	switch e {
	case FulfillmentOrderSortKeysID, FulfillmentOrderSortKeysRelevance:
		return true
	}
	return false
}

func (e FulfillmentOrderSortKeys) String() string {
	return string(e)
}

func (e *FulfillmentOrderSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentOrderSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentOrderSortKeys", str)
	}
	return nil
}

func (e FulfillmentOrderSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a fulfillment order.
type FulfillmentOrderStatus string

const (
	// The fulfillment order has been opened.
	FulfillmentOrderStatusOpen FulfillmentOrderStatus = "OPEN"
	// The fulfillment order is being processed.
	FulfillmentOrderStatusInProgress FulfillmentOrderStatus = "IN_PROGRESS"
	// The fulfillment order has been cancelled by the merchant.
	FulfillmentOrderStatusCancelled FulfillmentOrderStatus = "CANCELLED"
	// The fulfillment order cannot be completed as requested.
	FulfillmentOrderStatusIncomplete FulfillmentOrderStatus = "INCOMPLETE"
	// The fulfillment order has been completed and closed.
	FulfillmentOrderStatusClosed FulfillmentOrderStatus = "CLOSED"
)

var AllFulfillmentOrderStatus = []FulfillmentOrderStatus{
	FulfillmentOrderStatusOpen,
	FulfillmentOrderStatusInProgress,
	FulfillmentOrderStatusCancelled,
	FulfillmentOrderStatusIncomplete,
	FulfillmentOrderStatusClosed,
}

func (e FulfillmentOrderStatus) IsValid() bool {
	switch e {
	case FulfillmentOrderStatusOpen, FulfillmentOrderStatusInProgress, FulfillmentOrderStatusCancelled, FulfillmentOrderStatusIncomplete, FulfillmentOrderStatusClosed:
		return true
	}
	return false
}

func (e FulfillmentOrderStatus) String() string {
	return string(e)
}

func (e *FulfillmentOrderStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentOrderStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentOrderStatus", str)
	}
	return nil
}

func (e FulfillmentOrderStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of a fulfillment service.
type FulfillmentServiceType string

const (
	// Fulfillment by gift card.
	FulfillmentServiceTypeGiftCard FulfillmentServiceType = "GIFT_CARD"
	// Manual fulfillment by the merchant.
	FulfillmentServiceTypeManual FulfillmentServiceType = "MANUAL"
	// Fullfillment by a third-party fulfillment service.
	FulfillmentServiceTypeThirdParty FulfillmentServiceType = "THIRD_PARTY"
)

var AllFulfillmentServiceType = []FulfillmentServiceType{
	FulfillmentServiceTypeGiftCard,
	FulfillmentServiceTypeManual,
	FulfillmentServiceTypeThirdParty,
}

func (e FulfillmentServiceType) IsValid() bool {
	switch e {
	case FulfillmentServiceTypeGiftCard, FulfillmentServiceTypeManual, FulfillmentServiceTypeThirdParty:
		return true
	}
	return false
}

func (e FulfillmentServiceType) String() string {
	return string(e)
}

func (e *FulfillmentServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentServiceType", str)
	}
	return nil
}

func (e FulfillmentServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a fulfillment.
type FulfillmentStatus string

const (
	// Shopify has created the fulfillment and is waiting for the third-party fulfillment service to transition it to `open` or `success`.
	//
	FulfillmentStatusPending FulfillmentStatus = "PENDING"
	// The third-party fulfillment service has acknowledged the fulfilment and is processing it.
	//
	FulfillmentStatusOpen FulfillmentStatus = "OPEN"
	// The fulfillment was completed successfully.
	FulfillmentStatusSuccess FulfillmentStatus = "SUCCESS"
	// The fulfillment was canceled.
	FulfillmentStatusCancelled FulfillmentStatus = "CANCELLED"
	// There was an error with the fulfillment request.
	FulfillmentStatusError FulfillmentStatus = "ERROR"
	// The fulfillment request failed.
	FulfillmentStatusFailure FulfillmentStatus = "FAILURE"
)

var AllFulfillmentStatus = []FulfillmentStatus{
	FulfillmentStatusPending,
	FulfillmentStatusOpen,
	FulfillmentStatusSuccess,
	FulfillmentStatusCancelled,
	FulfillmentStatusError,
	FulfillmentStatusFailure,
}

func (e FulfillmentStatus) IsValid() bool {
	switch e {
	case FulfillmentStatusPending, FulfillmentStatusOpen, FulfillmentStatusSuccess, FulfillmentStatusCancelled, FulfillmentStatusError, FulfillmentStatusFailure:
		return true
	}
	return false
}

func (e FulfillmentStatus) String() string {
	return string(e)
}

func (e *FulfillmentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FulfillmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FulfillmentStatus", str)
	}
	return nil
}

func (e FulfillmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// List of supported image content types.
type ImageContentType string

const (
	// A PNG image.
	ImageContentTypePng ImageContentType = "PNG"
	// A JPG image.
	ImageContentTypeJpg ImageContentType = "JPG"
	// A WEBP image.
	ImageContentTypeWebp ImageContentType = "WEBP"
)

var AllImageContentType = []ImageContentType{
	ImageContentTypePng,
	ImageContentTypeJpg,
	ImageContentTypeWebp,
}

func (e ImageContentType) IsValid() bool {
	switch e {
	case ImageContentTypePng, ImageContentTypeJpg, ImageContentTypeWebp:
		return true
	}
	return false
}

func (e ImageContentType) String() string {
	return string(e)
}

func (e *ImageContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageContentType", str)
	}
	return nil
}

func (e ImageContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The locale language allowed for Kit Skill.
type KitSkillLocale string

const (
	// English language.
	KitSkillLocaleEn KitSkillLocale = "EN"
)

var AllKitSkillLocale = []KitSkillLocale{
	KitSkillLocaleEn,
}

func (e KitSkillLocale) IsValid() bool {
	switch e {
	case KitSkillLocaleEn:
		return true
	}
	return false
}

func (e KitSkillLocale) String() string {
	return string(e)
}

func (e *KitSkillLocale) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KitSkillLocale(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KitSkillLocale", str)
	}
	return nil
}

func (e KitSkillLocale) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The purpose of a localization extension.
type LocalizationExtensionPurpose string

const (
	// Extensions that are used for shipping purposes, for example, customs clearance.
	LocalizationExtensionPurposeShipping LocalizationExtensionPurpose = "SHIPPING"
	// Extensions that are used for taxes purposes, for example, invoicing.
	LocalizationExtensionPurposeTax LocalizationExtensionPurpose = "TAX"
)

var AllLocalizationExtensionPurpose = []LocalizationExtensionPurpose{
	LocalizationExtensionPurposeShipping,
	LocalizationExtensionPurposeTax,
}

func (e LocalizationExtensionPurpose) IsValid() bool {
	switch e {
	case LocalizationExtensionPurposeShipping, LocalizationExtensionPurposeTax:
		return true
	}
	return false
}

func (e LocalizationExtensionPurpose) String() string {
	return string(e)
}

func (e *LocalizationExtensionPurpose) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocalizationExtensionPurpose(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocalizationExtensionPurpose", str)
	}
	return nil
}

func (e LocalizationExtensionPurpose) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Location query.
type LocationSortKeys string

const (
	// Sort by the `name` value.
	LocationSortKeysName LocationSortKeys = "NAME"
	// Sort by the `id` value.
	LocationSortKeysID LocationSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	LocationSortKeysRelevance LocationSortKeys = "RELEVANCE"
)

var AllLocationSortKeys = []LocationSortKeys{
	LocationSortKeysName,
	LocationSortKeysID,
	LocationSortKeysRelevance,
}

func (e LocationSortKeys) IsValid() bool {
	switch e {
	case LocationSortKeysName, LocationSortKeysID, LocationSortKeysRelevance:
		return true
	}
	return false
}

func (e LocationSortKeys) String() string {
	return string(e)
}

func (e *LocationSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationSortKeys", str)
	}
	return nil
}

func (e LocationSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The error code resulted from the marketing activity extension integration.
type MarketingActivityExtensionAppErrorCode string

const (
	// The shop/user must be onboarded to use the app.
	MarketingActivityExtensionAppErrorCodeNotOnboardedError MarketingActivityExtensionAppErrorCode = "NOT_ONBOARDED_ERROR"
	// The app has returned validation errors.
	MarketingActivityExtensionAppErrorCodeValidationError MarketingActivityExtensionAppErrorCode = "VALIDATION_ERROR"
	// The app is not responding or returning unexpected data.
	MarketingActivityExtensionAppErrorCodeAPIError MarketingActivityExtensionAppErrorCode = "API_ERROR"
	// The app has returned an error when invoking the platform.
	MarketingActivityExtensionAppErrorCodePlatformError MarketingActivityExtensionAppErrorCode = "PLATFORM_ERROR"
	// The app needs to be installed.
	MarketingActivityExtensionAppErrorCodeInstallRequiredError MarketingActivityExtensionAppErrorCode = "INSTALL_REQUIRED_ERROR"
)

var AllMarketingActivityExtensionAppErrorCode = []MarketingActivityExtensionAppErrorCode{
	MarketingActivityExtensionAppErrorCodeNotOnboardedError,
	MarketingActivityExtensionAppErrorCodeValidationError,
	MarketingActivityExtensionAppErrorCodeAPIError,
	MarketingActivityExtensionAppErrorCodePlatformError,
	MarketingActivityExtensionAppErrorCodeInstallRequiredError,
}

func (e MarketingActivityExtensionAppErrorCode) IsValid() bool {
	switch e {
	case MarketingActivityExtensionAppErrorCodeNotOnboardedError, MarketingActivityExtensionAppErrorCodeValidationError, MarketingActivityExtensionAppErrorCodeAPIError, MarketingActivityExtensionAppErrorCodePlatformError, MarketingActivityExtensionAppErrorCodeInstallRequiredError:
		return true
	}
	return false
}

func (e MarketingActivityExtensionAppErrorCode) String() string {
	return string(e)
}

func (e *MarketingActivityExtensionAppErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingActivityExtensionAppErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingActivityExtensionAppErrorCode", str)
	}
	return nil
}

func (e MarketingActivityExtensionAppErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the MarketingActivity query.
type MarketingActivitySortKeys string

const (
	// Sort by the `title` value.
	MarketingActivitySortKeysTitle MarketingActivitySortKeys = "TITLE"
	// Sort by the `created_at` value.
	MarketingActivitySortKeysCreatedAt MarketingActivitySortKeys = "CREATED_AT"
	// Sort by the `id` value.
	MarketingActivitySortKeysID MarketingActivitySortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	MarketingActivitySortKeysRelevance MarketingActivitySortKeys = "RELEVANCE"
)

var AllMarketingActivitySortKeys = []MarketingActivitySortKeys{
	MarketingActivitySortKeysTitle,
	MarketingActivitySortKeysCreatedAt,
	MarketingActivitySortKeysID,
	MarketingActivitySortKeysRelevance,
}

func (e MarketingActivitySortKeys) IsValid() bool {
	switch e {
	case MarketingActivitySortKeysTitle, MarketingActivitySortKeysCreatedAt, MarketingActivitySortKeysID, MarketingActivitySortKeysRelevance:
		return true
	}
	return false
}

func (e MarketingActivitySortKeys) String() string {
	return string(e)
}

func (e *MarketingActivitySortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingActivitySortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingActivitySortKeys", str)
	}
	return nil
}

func (e MarketingActivitySortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status helps to identify if this marketing activity has been completed, queued, failed etc.
type MarketingActivityStatus string

const (
	// This marketing activity is currently running.
	MarketingActivityStatusActive MarketingActivityStatus = "ACTIVE"
	// This marketing activity is permanently unavailable.
	MarketingActivityStatusDeleted MarketingActivityStatus = "DELETED"
	// This marketing activity was deleted and it was triggered from outside of Shopify.
	MarketingActivityStatusDeletedExternally MarketingActivityStatus = "DELETED_EXTERNALLY"
	// This marketing activity is disconnected and no longer editable.
	MarketingActivityStatusDisconnected MarketingActivityStatus = "DISCONNECTED"
	// This marketing activity is started but not yet created.
	MarketingActivityStatusDraft MarketingActivityStatus = "DRAFT"
	// This marketing activity is unable to run.
	MarketingActivityStatusFailed MarketingActivityStatus = "FAILED"
	// This marketing activity has completed running.
	MarketingActivityStatusInactive MarketingActivityStatus = "INACTIVE"
	// This marketing activity is currently not running.
	MarketingActivityStatusPaused MarketingActivityStatus = "PAUSED"
	// This marketing activity is pending creation on the app's platform.
	MarketingActivityStatusPending MarketingActivityStatus = "PENDING"
	// This marketing activity is scheduled to run.
	MarketingActivityStatusScheduled MarketingActivityStatus = "SCHEDULED"
	// There is no defined status for external marketing activities.
	MarketingActivityStatusUndefined MarketingActivityStatus = "UNDEFINED"
)

var AllMarketingActivityStatus = []MarketingActivityStatus{
	MarketingActivityStatusActive,
	MarketingActivityStatusDeleted,
	MarketingActivityStatusDeletedExternally,
	MarketingActivityStatusDisconnected,
	MarketingActivityStatusDraft,
	MarketingActivityStatusFailed,
	MarketingActivityStatusInactive,
	MarketingActivityStatusPaused,
	MarketingActivityStatusPending,
	MarketingActivityStatusScheduled,
	MarketingActivityStatusUndefined,
}

func (e MarketingActivityStatus) IsValid() bool {
	switch e {
	case MarketingActivityStatusActive, MarketingActivityStatusDeleted, MarketingActivityStatusDeletedExternally, MarketingActivityStatusDisconnected, MarketingActivityStatusDraft, MarketingActivityStatusFailed, MarketingActivityStatusInactive, MarketingActivityStatusPaused, MarketingActivityStatusPending, MarketingActivityStatusScheduled, MarketingActivityStatusUndefined:
		return true
	}
	return false
}

func (e MarketingActivityStatus) String() string {
	return string(e)
}

func (e *MarketingActivityStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingActivityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingActivityStatus", str)
	}
	return nil
}

func (e MarketingActivityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// StatusBadgeType helps to identify the color of the status badge.
type MarketingActivityStatusBadgeType string

const (
	// This status badge has type default.
	MarketingActivityStatusBadgeTypeDefault MarketingActivityStatusBadgeType = "DEFAULT"
	// This status badge has type success.
	MarketingActivityStatusBadgeTypeSuccess MarketingActivityStatusBadgeType = "SUCCESS"
	// This status badge has type attention.
	MarketingActivityStatusBadgeTypeAttention MarketingActivityStatusBadgeType = "ATTENTION"
	// This status badge has type warning.
	MarketingActivityStatusBadgeTypeWarning MarketingActivityStatusBadgeType = "WARNING"
	// This status badge has type info.
	MarketingActivityStatusBadgeTypeInfo MarketingActivityStatusBadgeType = "INFO"
)

var AllMarketingActivityStatusBadgeType = []MarketingActivityStatusBadgeType{
	MarketingActivityStatusBadgeTypeDefault,
	MarketingActivityStatusBadgeTypeSuccess,
	MarketingActivityStatusBadgeTypeAttention,
	MarketingActivityStatusBadgeTypeWarning,
	MarketingActivityStatusBadgeTypeInfo,
}

func (e MarketingActivityStatusBadgeType) IsValid() bool {
	switch e {
	case MarketingActivityStatusBadgeTypeDefault, MarketingActivityStatusBadgeTypeSuccess, MarketingActivityStatusBadgeTypeAttention, MarketingActivityStatusBadgeTypeWarning, MarketingActivityStatusBadgeTypeInfo:
		return true
	}
	return false
}

func (e MarketingActivityStatusBadgeType) String() string {
	return string(e)
}

func (e *MarketingActivityStatusBadgeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingActivityStatusBadgeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingActivityStatusBadgeType", str)
	}
	return nil
}

func (e MarketingActivityStatusBadgeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The budget type for a marketing activity.
type MarketingBudgetBudgetType string

const (
	// A daily budget.
	MarketingBudgetBudgetTypeDaily MarketingBudgetBudgetType = "DAILY"
	// A budget for the lifetime of a marketing activity.
	MarketingBudgetBudgetTypeLifetime MarketingBudgetBudgetType = "LIFETIME"
)

var AllMarketingBudgetBudgetType = []MarketingBudgetBudgetType{
	MarketingBudgetBudgetTypeDaily,
	MarketingBudgetBudgetTypeLifetime,
}

func (e MarketingBudgetBudgetType) IsValid() bool {
	switch e {
	case MarketingBudgetBudgetTypeDaily, MarketingBudgetBudgetTypeLifetime:
		return true
	}
	return false
}

func (e MarketingBudgetBudgetType) String() string {
	return string(e)
}

func (e *MarketingBudgetBudgetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingBudgetBudgetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingBudgetBudgetType", str)
	}
	return nil
}

func (e MarketingBudgetBudgetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The available marketing channels for a marketing activity or event. A marketing channel is broad category of marketing, used for reporting aggregation.
//
type MarketingChannel string

const (
	// Paid search.
	MarketingChannelSearch MarketingChannel = "SEARCH"
	// Displayed ads.
	MarketingChannelDisplay MarketingChannel = "DISPLAY"
	// Social media.
	MarketingChannelSocial MarketingChannel = "SOCIAL"
	// Email.
	MarketingChannelEmail MarketingChannel = "EMAIL"
	// Referral links.
	MarketingChannelReferral MarketingChannel = "REFERRAL"
)

var AllMarketingChannel = []MarketingChannel{
	MarketingChannelSearch,
	MarketingChannelDisplay,
	MarketingChannelSocial,
	MarketingChannelEmail,
	MarketingChannelReferral,
}

func (e MarketingChannel) IsValid() bool {
	switch e {
	case MarketingChannelSearch, MarketingChannelDisplay, MarketingChannelSocial, MarketingChannelEmail, MarketingChannelReferral:
		return true
	}
	return false
}

func (e MarketingChannel) String() string {
	return string(e)
}

func (e *MarketingChannel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingChannel", str)
	}
	return nil
}

func (e MarketingChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the MarketingEvent query.
type MarketingEventSortKeys string

const (
	// Sort by the `started_at` value.
	MarketingEventSortKeysStartedAt MarketingEventSortKeys = "STARTED_AT"
	// Sort by the `id` value.
	MarketingEventSortKeysID MarketingEventSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	MarketingEventSortKeysRelevance MarketingEventSortKeys = "RELEVANCE"
)

var AllMarketingEventSortKeys = []MarketingEventSortKeys{
	MarketingEventSortKeysStartedAt,
	MarketingEventSortKeysID,
	MarketingEventSortKeysRelevance,
}

func (e MarketingEventSortKeys) IsValid() bool {
	switch e {
	case MarketingEventSortKeysStartedAt, MarketingEventSortKeysID, MarketingEventSortKeysRelevance:
		return true
	}
	return false
}

func (e MarketingEventSortKeys) String() string {
	return string(e)
}

func (e *MarketingEventSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingEventSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingEventSortKeys", str)
	}
	return nil
}

func (e MarketingEventSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The available types of marketing event.
type MarketingTactic string

const (
	// An abandoned cart recovery email.
	MarketingTacticAbandonedCart MarketingTactic = "ABANDONED_CART"
	// An ad, such as a Facebook ad.
	MarketingTacticAd MarketingTactic = "AD"
	// An affiliate link.
	MarketingTacticAffiliate MarketingTactic = "AFFILIATE"
	// A link.
	MarketingTacticLink MarketingTactic = "LINK"
	// A loyalty program.
	MarketingTacticLoyalty MarketingTactic = "LOYALTY"
	// A messaging app, such as Facebook Messenger.
	MarketingTacticMessage MarketingTactic = "MESSAGE"
	// A newsletter.
	MarketingTacticNewsletter MarketingTactic = "NEWSLETTER"
	// A notification in the Shopify admin.
	MarketingTacticNotification MarketingTactic = "NOTIFICATION"
	// A blog post.
	MarketingTacticPost MarketingTactic = "POST"
	// A retargeting ad.
	MarketingTacticRetargeting MarketingTactic = "RETARGETING"
	// A transactional email.
	MarketingTacticTransactional MarketingTactic = "TRANSACTIONAL"
	// Search engine optimization.
	MarketingTacticSeo MarketingTactic = "SEO"
	// A direct visit to the online store.
	MarketingTacticDirect MarketingTactic = "DIRECT"
	// Popup on merchant's store.
	MarketingTacticStorefrontApp MarketingTactic = "STOREFRONT_APP"
	// A display ad.
	MarketingTacticDisplay MarketingTactic = "DISPLAY"
	// Paid search.
	MarketingTacticSearch MarketingTactic = "SEARCH"
	// A follow-up email.
	MarketingTacticFollowUp MarketingTactic = "FOLLOW_UP"
	// A promotional receipt.
	MarketingTacticReceipt MarketingTactic = "RECEIPT"
)

var AllMarketingTactic = []MarketingTactic{
	MarketingTacticAbandonedCart,
	MarketingTacticAd,
	MarketingTacticAffiliate,
	MarketingTacticLink,
	MarketingTacticLoyalty,
	MarketingTacticMessage,
	MarketingTacticNewsletter,
	MarketingTacticNotification,
	MarketingTacticPost,
	MarketingTacticRetargeting,
	MarketingTacticTransactional,
	MarketingTacticSeo,
	MarketingTacticDirect,
	MarketingTacticStorefrontApp,
	MarketingTacticDisplay,
	MarketingTacticSearch,
	MarketingTacticFollowUp,
	MarketingTacticReceipt,
}

func (e MarketingTactic) IsValid() bool {
	switch e {
	case MarketingTacticAbandonedCart, MarketingTacticAd, MarketingTacticAffiliate, MarketingTacticLink, MarketingTacticLoyalty, MarketingTacticMessage, MarketingTacticNewsletter, MarketingTacticNotification, MarketingTacticPost, MarketingTacticRetargeting, MarketingTacticTransactional, MarketingTacticSeo, MarketingTacticDirect, MarketingTacticStorefrontApp, MarketingTacticDisplay, MarketingTacticSearch, MarketingTacticFollowUp, MarketingTacticReceipt:
		return true
	}
	return false
}

func (e MarketingTactic) String() string {
	return string(e)
}

func (e *MarketingTactic) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarketingTactic(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarketingTactic", str)
	}
	return nil
}

func (e MarketingTactic) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible content types for a media object.
type MediaContentType string

const (
	// A Shopify hosted video.
	MediaContentTypeVideo MediaContentType = "VIDEO"
	// An externally hosted video.
	MediaContentTypeExternalVideo MediaContentType = "EXTERNAL_VIDEO"
	// A 3d model.
	MediaContentTypeModel3d MediaContentType = "MODEL_3D"
	// A Shopify hosted image.
	MediaContentTypeImage MediaContentType = "IMAGE"
)

var AllMediaContentType = []MediaContentType{
	MediaContentTypeVideo,
	MediaContentTypeExternalVideo,
	MediaContentTypeModel3d,
	MediaContentTypeImage,
}

func (e MediaContentType) IsValid() bool {
	switch e {
	case MediaContentTypeVideo, MediaContentTypeExternalVideo, MediaContentTypeModel3d, MediaContentTypeImage:
		return true
	}
	return false
}

func (e MediaContentType) String() string {
	return string(e)
}

func (e *MediaContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaContentType", str)
	}
	return nil
}

func (e MediaContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error types for media.
type MediaErrorCode string

const (
	// Media error has occured for unknown reason.
	MediaErrorCodeUnknown MediaErrorCode = "UNKNOWN"
	// Media could not be processed because the signed url was invalid.
	MediaErrorCodeInvalidSignedURL MediaErrorCode = "INVALID_SIGNED_URL"
	// Media could not be processed because the image could not be downloaded.
	MediaErrorCodeImageDownloadFailure MediaErrorCode = "IMAGE_DOWNLOAD_FAILURE"
	// Media could not be processed because the image could not be processed.
	MediaErrorCodeImageProcessingFailure MediaErrorCode = "IMAGE_PROCESSING_FAILURE"
	// Media timed out because it is currently being modified by another operation.
	MediaErrorCodeMediaTimeoutError MediaErrorCode = "MEDIA_TIMEOUT_ERROR"
	// Media could not be created because the external video could not be found.
	MediaErrorCodeExternalVideoNotFound MediaErrorCode = "EXTERNAL_VIDEO_NOT_FOUND"
	// Media could not be created because the external video is not listed or is private.
	MediaErrorCodeExternalVideoUnlisted MediaErrorCode = "EXTERNAL_VIDEO_UNLISTED"
	// Media could not be created because the external video has an invalid aspect ratio.
	MediaErrorCodeExternalVideoInvalidAspectRatio MediaErrorCode = "EXTERNAL_VIDEO_INVALID_ASPECT_RATIO"
	// Media could not be created because the metadata could not be read.
	MediaErrorCodeVideoMetadataReadError MediaErrorCode = "VIDEO_METADATA_READ_ERROR"
	// Media could not be created because it has an invalid file type.
	MediaErrorCodeVideoInvalidFiletypeError MediaErrorCode = "VIDEO_INVALID_FILETYPE_ERROR"
	// Media could not be created because it does not meet the minimum width requirement.
	MediaErrorCodeVideoMinWidthError MediaErrorCode = "VIDEO_MIN_WIDTH_ERROR"
	// Media could not be created because it does not meet the maximum width requirement.
	MediaErrorCodeVideoMaxWidthError MediaErrorCode = "VIDEO_MAX_WIDTH_ERROR"
	// Media could not be created because it does not meet the minimum height requirement.
	MediaErrorCodeVideoMinHeightError MediaErrorCode = "VIDEO_MIN_HEIGHT_ERROR"
	// Media could not be created because it does not meet the maximum height requirement.
	MediaErrorCodeVideoMaxHeightError MediaErrorCode = "VIDEO_MAX_HEIGHT_ERROR"
	// Media could not be created because it does not meet the minimum duration requirement.
	MediaErrorCodeVideoMinDurationError MediaErrorCode = "VIDEO_MIN_DURATION_ERROR"
	// Media could not be created because it does not meet the maximum duration requirement.
	MediaErrorCodeVideoMaxDurationError MediaErrorCode = "VIDEO_MAX_DURATION_ERROR"
	// Video failed validation.
	MediaErrorCodeVideoValidationError MediaErrorCode = "VIDEO_VALIDATION_ERROR"
	// Model failed validation.
	MediaErrorCodeModel3dValidationError MediaErrorCode = "MODEL3D_VALIDATION_ERROR"
	// Media could not be created because the model's thumbnail generation failed.
	MediaErrorCodeModel3dThumbnailGenerationError MediaErrorCode = "MODEL3D_THUMBNAIL_GENERATION_ERROR"
	// Media could not be created because the model can't be converted to USDZ format.
	MediaErrorCodeModel3dGlbToUsdzConversionError MediaErrorCode = "MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR"
	// Media could not be created because the model file failed processing.
	MediaErrorCodeModel3dGlbOutputCreationError MediaErrorCode = "MODEL3D_GLB_OUTPUT_CREATION_ERROR"
	// Media could not be created because the image is an unsupported file type.
	MediaErrorCodeUnsupportedImageFileType MediaErrorCode = "UNSUPPORTED_IMAGE_FILE_TYPE"
	// Media could not be created because the image size is too large.
	MediaErrorCodeInvalidImageFileSize MediaErrorCode = "INVALID_IMAGE_FILE_SIZE"
)

var AllMediaErrorCode = []MediaErrorCode{
	MediaErrorCodeUnknown,
	MediaErrorCodeInvalidSignedURL,
	MediaErrorCodeImageDownloadFailure,
	MediaErrorCodeImageProcessingFailure,
	MediaErrorCodeMediaTimeoutError,
	MediaErrorCodeExternalVideoNotFound,
	MediaErrorCodeExternalVideoUnlisted,
	MediaErrorCodeExternalVideoInvalidAspectRatio,
	MediaErrorCodeVideoMetadataReadError,
	MediaErrorCodeVideoInvalidFiletypeError,
	MediaErrorCodeVideoMinWidthError,
	MediaErrorCodeVideoMaxWidthError,
	MediaErrorCodeVideoMinHeightError,
	MediaErrorCodeVideoMaxHeightError,
	MediaErrorCodeVideoMinDurationError,
	MediaErrorCodeVideoMaxDurationError,
	MediaErrorCodeVideoValidationError,
	MediaErrorCodeModel3dValidationError,
	MediaErrorCodeModel3dThumbnailGenerationError,
	MediaErrorCodeModel3dGlbToUsdzConversionError,
	MediaErrorCodeModel3dGlbOutputCreationError,
	MediaErrorCodeUnsupportedImageFileType,
	MediaErrorCodeInvalidImageFileSize,
}

func (e MediaErrorCode) IsValid() bool {
	switch e {
	case MediaErrorCodeUnknown, MediaErrorCodeInvalidSignedURL, MediaErrorCodeImageDownloadFailure, MediaErrorCodeImageProcessingFailure, MediaErrorCodeMediaTimeoutError, MediaErrorCodeExternalVideoNotFound, MediaErrorCodeExternalVideoUnlisted, MediaErrorCodeExternalVideoInvalidAspectRatio, MediaErrorCodeVideoMetadataReadError, MediaErrorCodeVideoInvalidFiletypeError, MediaErrorCodeVideoMinWidthError, MediaErrorCodeVideoMaxWidthError, MediaErrorCodeVideoMinHeightError, MediaErrorCodeVideoMaxHeightError, MediaErrorCodeVideoMinDurationError, MediaErrorCodeVideoMaxDurationError, MediaErrorCodeVideoValidationError, MediaErrorCodeModel3dValidationError, MediaErrorCodeModel3dThumbnailGenerationError, MediaErrorCodeModel3dGlbToUsdzConversionError, MediaErrorCodeModel3dGlbOutputCreationError, MediaErrorCodeUnsupportedImageFileType, MediaErrorCodeInvalidImageFileSize:
		return true
	}
	return false
}

func (e MediaErrorCode) String() string {
	return string(e)
}

func (e *MediaErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaErrorCode", str)
	}
	return nil
}

func (e MediaErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible statuses for a media preview image.
type MediaPreviewImageStatus string

const (
	// Preview image is uploaded but not yet processed.
	MediaPreviewImageStatusUploaded MediaPreviewImageStatus = "UPLOADED"
	// Preview image is being processed.
	MediaPreviewImageStatusProcessing MediaPreviewImageStatus = "PROCESSING"
	// Preview image is ready to be displayed.
	MediaPreviewImageStatusReady MediaPreviewImageStatus = "READY"
	// Preview image processing has failed.
	MediaPreviewImageStatusFailed MediaPreviewImageStatus = "FAILED"
)

var AllMediaPreviewImageStatus = []MediaPreviewImageStatus{
	MediaPreviewImageStatusUploaded,
	MediaPreviewImageStatusProcessing,
	MediaPreviewImageStatusReady,
	MediaPreviewImageStatusFailed,
}

func (e MediaPreviewImageStatus) IsValid() bool {
	switch e {
	case MediaPreviewImageStatusUploaded, MediaPreviewImageStatusProcessing, MediaPreviewImageStatusReady, MediaPreviewImageStatusFailed:
		return true
	}
	return false
}

func (e MediaPreviewImageStatus) String() string {
	return string(e)
}

func (e *MediaPreviewImageStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaPreviewImageStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaPreviewImageStatus", str)
	}
	return nil
}

func (e MediaPreviewImageStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible statuses for a media object.
type MediaStatus string

const (
	// Media has been uploaded but not yet processed.
	MediaStatusUploaded MediaStatus = "UPLOADED"
	// Media is being processed.
	MediaStatusProcessing MediaStatus = "PROCESSING"
	// Media is ready to be displayed.
	MediaStatusReady MediaStatus = "READY"
	// Media processing has failed.
	MediaStatusFailed MediaStatus = "FAILED"
)

var AllMediaStatus = []MediaStatus{
	MediaStatusUploaded,
	MediaStatusProcessing,
	MediaStatusReady,
	MediaStatusFailed,
}

func (e MediaStatus) IsValid() bool {
	switch e {
	case MediaStatusUploaded, MediaStatusProcessing, MediaStatusReady, MediaStatusFailed:
		return true
	}
	return false
}

func (e MediaStatus) String() string {
	return string(e)
}

func (e *MediaStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaStatus", str)
	}
	return nil
}

func (e MediaStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by MediaUserError.
type MediaUserErrorCode string

const (
	// Input value is invalid.
	MediaUserErrorCodeInvalid MediaUserErrorCode = "INVALID"
	// Input value is blank.
	MediaUserErrorCodeBlank MediaUserErrorCode = "BLANK"
	// Video validation failed.
	MediaUserErrorCodeVideoValidationError MediaUserErrorCode = "VIDEO_VALIDATION_ERROR"
	// Model validation failed.
	MediaUserErrorCodeModel3dValidationError MediaUserErrorCode = "MODEL3D_VALIDATION_ERROR"
	// Video creation throttle was exceeded.
	MediaUserErrorCodeVideoThrottleExceeded MediaUserErrorCode = "VIDEO_THROTTLE_EXCEEDED"
	// Model3d creation throttle was exceeded.
	MediaUserErrorCodeModel3dThrottleExceeded MediaUserErrorCode = "MODEL3D_THROTTLE_EXCEEDED"
	// Exceeded the limit of media per product.
	MediaUserErrorCodeProductMediaLimitExceeded MediaUserErrorCode = "PRODUCT_MEDIA_LIMIT_EXCEEDED"
	// Exceeded the limit of media per shop.
	MediaUserErrorCodeShopMediaLimitExceeded MediaUserErrorCode = "SHOP_MEDIA_LIMIT_EXCEEDED"
	// Product does not exist.
	MediaUserErrorCodeProductDoesNotExist MediaUserErrorCode = "PRODUCT_DOES_NOT_EXIST"
	// Media does not exist.
	MediaUserErrorCodeMediaDoesNotExist MediaUserErrorCode = "MEDIA_DOES_NOT_EXIST"
	// Media does not exist on the given product.
	MediaUserErrorCodeMediaDoesNotExistOnProduct MediaUserErrorCode = "MEDIA_DOES_NOT_EXIST_ON_PRODUCT"
	// Only one mediaId is allowed per variant-media input pair.
	MediaUserErrorCodeTooManyMediaPerInputPair MediaUserErrorCode = "TOO_MANY_MEDIA_PER_INPUT_PAIR"
	// Exceeded the maximum number of 100 variant-media pairs per mutation call.
	MediaUserErrorCodeMaximumVariantMediaPairsExceeded MediaUserErrorCode = "MAXIMUM_VARIANT_MEDIA_PAIRS_EXCEEDED"
	// Invalid media type.
	MediaUserErrorCodeInvalidMediaType MediaUserErrorCode = "INVALID_MEDIA_TYPE"
	// Variant specified in more than one pair.
	MediaUserErrorCodeProductVariantSpecifiedMultipleTimes MediaUserErrorCode = "PRODUCT_VARIANT_SPECIFIED_MULTIPLE_TIMES"
	// Variant does not exist on the given product.
	MediaUserErrorCodeProductVariantDoesNotExistOnProduct MediaUserErrorCode = "PRODUCT_VARIANT_DOES_NOT_EXIST_ON_PRODUCT"
	// Non-ready media are not supported.
	MediaUserErrorCodeNonReadyMedia MediaUserErrorCode = "NON_READY_MEDIA"
	// Product variant already has attached media.
	MediaUserErrorCodeProductVariantAlreadyHasMedia MediaUserErrorCode = "PRODUCT_VARIANT_ALREADY_HAS_MEDIA"
	// The specified media is not attached to the specified variant.
	MediaUserErrorCodeMediaIsNotAttachedToVariant MediaUserErrorCode = "MEDIA_IS_NOT_ATTACHED_TO_VARIANT"
	// Media cannot be modified. It is currently being modified by another operation.
	MediaUserErrorCodeMediaCannotBeModified MediaUserErrorCode = "MEDIA_CANNOT_BE_MODIFIED"
)

var AllMediaUserErrorCode = []MediaUserErrorCode{
	MediaUserErrorCodeInvalid,
	MediaUserErrorCodeBlank,
	MediaUserErrorCodeVideoValidationError,
	MediaUserErrorCodeModel3dValidationError,
	MediaUserErrorCodeVideoThrottleExceeded,
	MediaUserErrorCodeModel3dThrottleExceeded,
	MediaUserErrorCodeProductMediaLimitExceeded,
	MediaUserErrorCodeShopMediaLimitExceeded,
	MediaUserErrorCodeProductDoesNotExist,
	MediaUserErrorCodeMediaDoesNotExist,
	MediaUserErrorCodeMediaDoesNotExistOnProduct,
	MediaUserErrorCodeTooManyMediaPerInputPair,
	MediaUserErrorCodeMaximumVariantMediaPairsExceeded,
	MediaUserErrorCodeInvalidMediaType,
	MediaUserErrorCodeProductVariantSpecifiedMultipleTimes,
	MediaUserErrorCodeProductVariantDoesNotExistOnProduct,
	MediaUserErrorCodeNonReadyMedia,
	MediaUserErrorCodeProductVariantAlreadyHasMedia,
	MediaUserErrorCodeMediaIsNotAttachedToVariant,
	MediaUserErrorCodeMediaCannotBeModified,
}

func (e MediaUserErrorCode) IsValid() bool {
	switch e {
	case MediaUserErrorCodeInvalid, MediaUserErrorCodeBlank, MediaUserErrorCodeVideoValidationError, MediaUserErrorCodeModel3dValidationError, MediaUserErrorCodeVideoThrottleExceeded, MediaUserErrorCodeModel3dThrottleExceeded, MediaUserErrorCodeProductMediaLimitExceeded, MediaUserErrorCodeShopMediaLimitExceeded, MediaUserErrorCodeProductDoesNotExist, MediaUserErrorCodeMediaDoesNotExist, MediaUserErrorCodeMediaDoesNotExistOnProduct, MediaUserErrorCodeTooManyMediaPerInputPair, MediaUserErrorCodeMaximumVariantMediaPairsExceeded, MediaUserErrorCodeInvalidMediaType, MediaUserErrorCodeProductVariantSpecifiedMultipleTimes, MediaUserErrorCodeProductVariantDoesNotExistOnProduct, MediaUserErrorCodeNonReadyMedia, MediaUserErrorCodeProductVariantAlreadyHasMedia, MediaUserErrorCodeMediaIsNotAttachedToVariant, MediaUserErrorCodeMediaCannotBeModified:
		return true
	}
	return false
}

func (e MediaUserErrorCode) String() string {
	return string(e)
}

func (e *MediaUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaUserErrorCode", str)
	}
	return nil
}

func (e MediaUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Metafield owner types.
type MetafieldOwnerType string

const (
	// A metafield owner type.
	MetafieldOwnerTypeArticle MetafieldOwnerType = "ARTICLE"
	// A metafield owner type.
	MetafieldOwnerTypeBlog MetafieldOwnerType = "BLOG"
	// A metafield owner type.
	MetafieldOwnerTypeCollection MetafieldOwnerType = "COLLECTION"
	// A metafield owner type.
	MetafieldOwnerTypeCustomer MetafieldOwnerType = "CUSTOMER"
	// A metafield owner type.
	MetafieldOwnerTypeDraftorder MetafieldOwnerType = "DRAFTORDER"
	// A metafield owner type.
	MetafieldOwnerTypeOrder MetafieldOwnerType = "ORDER"
	// A metafield owner type.
	MetafieldOwnerTypePage MetafieldOwnerType = "PAGE"
	// A metafield owner type.
	MetafieldOwnerTypeProduct MetafieldOwnerType = "PRODUCT"
	// A metafield owner type.
	MetafieldOwnerTypeProductimage MetafieldOwnerType = "PRODUCTIMAGE"
	// A metafield owner type.
	MetafieldOwnerTypeProductvariant MetafieldOwnerType = "PRODUCTVARIANT"
	// A metafield owner type.
	MetafieldOwnerTypeShop MetafieldOwnerType = "SHOP"
)

var AllMetafieldOwnerType = []MetafieldOwnerType{
	MetafieldOwnerTypeArticle,
	MetafieldOwnerTypeBlog,
	MetafieldOwnerTypeCollection,
	MetafieldOwnerTypeCustomer,
	MetafieldOwnerTypeDraftorder,
	MetafieldOwnerTypeOrder,
	MetafieldOwnerTypePage,
	MetafieldOwnerTypeProduct,
	MetafieldOwnerTypeProductimage,
	MetafieldOwnerTypeProductvariant,
	MetafieldOwnerTypeShop,
}

func (e MetafieldOwnerType) IsValid() bool {
	switch e {
	case MetafieldOwnerTypeArticle, MetafieldOwnerTypeBlog, MetafieldOwnerTypeCollection, MetafieldOwnerTypeCustomer, MetafieldOwnerTypeDraftorder, MetafieldOwnerTypeOrder, MetafieldOwnerTypePage, MetafieldOwnerTypeProduct, MetafieldOwnerTypeProductimage, MetafieldOwnerTypeProductvariant, MetafieldOwnerTypeShop:
		return true
	}
	return false
}

func (e MetafieldOwnerType) String() string {
	return string(e)
}

func (e *MetafieldOwnerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetafieldOwnerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetafieldOwnerType", str)
	}
	return nil
}

func (e MetafieldOwnerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Metafield value types.
type MetafieldValueType string

const (
	// A string.
	MetafieldValueTypeString MetafieldValueType = "STRING"
	// An integer.
	MetafieldValueTypeInteger MetafieldValueType = "INTEGER"
	// A JSON string.
	MetafieldValueTypeJSONString MetafieldValueType = "JSON_STRING"
)

var AllMetafieldValueType = []MetafieldValueType{
	MetafieldValueTypeString,
	MetafieldValueTypeInteger,
	MetafieldValueTypeJSONString,
}

func (e MetafieldValueType) IsValid() bool {
	switch e {
	case MetafieldValueTypeString, MetafieldValueTypeInteger, MetafieldValueTypeJSONString:
		return true
	}
	return false
}

func (e MetafieldValueType) String() string {
	return string(e)
}

func (e *MetafieldValueType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetafieldValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetafieldValueType", str)
	}
	return nil
}

func (e MetafieldValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the MethodDefinition query.
type MethodDefinitionSortKeys string

const (
	// Sort by the `rate_provider_type` value.
	MethodDefinitionSortKeysRateProviderType MethodDefinitionSortKeys = "RATE_PROVIDER_TYPE"
	// Sort by the `id` value.
	MethodDefinitionSortKeysID MethodDefinitionSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	MethodDefinitionSortKeysRelevance MethodDefinitionSortKeys = "RELEVANCE"
)

var AllMethodDefinitionSortKeys = []MethodDefinitionSortKeys{
	MethodDefinitionSortKeysRateProviderType,
	MethodDefinitionSortKeysID,
	MethodDefinitionSortKeysRelevance,
}

func (e MethodDefinitionSortKeys) IsValid() bool {
	switch e {
	case MethodDefinitionSortKeysRateProviderType, MethodDefinitionSortKeysID, MethodDefinitionSortKeysRelevance:
		return true
	}
	return false
}

func (e MethodDefinitionSortKeys) String() string {
	return string(e)
}

func (e *MethodDefinitionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MethodDefinitionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MethodDefinitionSortKeys", str)
	}
	return nil
}

func (e MethodDefinitionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the reason that the order is being canceled. Valid values are: customer, fraud, inventory, declined, other.
type OrderCancelReason string

const (
	// The customer wanted to cancel the order.
	OrderCancelReasonCustomer OrderCancelReason = "CUSTOMER"
	// The order was fraudulent.
	OrderCancelReasonFraud OrderCancelReason = "FRAUD"
	// There was insufficient inventory.
	OrderCancelReasonInventory OrderCancelReason = "INVENTORY"
	// Payment was declined.
	OrderCancelReasonDeclined OrderCancelReason = "DECLINED"
	// Some other reason not listed.
	OrderCancelReasonOther OrderCancelReason = "OTHER"
)

var AllOrderCancelReason = []OrderCancelReason{
	OrderCancelReasonCustomer,
	OrderCancelReasonFraud,
	OrderCancelReasonInventory,
	OrderCancelReasonDeclined,
	OrderCancelReasonOther,
}

func (e OrderCancelReason) IsValid() bool {
	switch e {
	case OrderCancelReasonCustomer, OrderCancelReasonFraud, OrderCancelReasonInventory, OrderCancelReasonDeclined, OrderCancelReasonOther:
		return true
	}
	return false
}

func (e OrderCancelReason) String() string {
	return string(e)
}

func (e *OrderCancelReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderCancelReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderCancelReason", str)
	}
	return nil
}

func (e OrderCancelReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the order's current financial status.
type OrderDisplayFinancialStatus string

const (
	// Displayed as **Pending**.
	OrderDisplayFinancialStatusPending OrderDisplayFinancialStatus = "PENDING"
	// Displayed as **Authorized**.
	OrderDisplayFinancialStatusAuthorized OrderDisplayFinancialStatus = "AUTHORIZED"
	// Displayed as **Partially paid**.
	OrderDisplayFinancialStatusPartiallyPaid OrderDisplayFinancialStatus = "PARTIALLY_PAID"
	// Displayed as **Partially refunded**.
	OrderDisplayFinancialStatusPartiallyRefunded OrderDisplayFinancialStatus = "PARTIALLY_REFUNDED"
	// Displayed as **Voided**.
	OrderDisplayFinancialStatusVoided OrderDisplayFinancialStatus = "VOIDED"
	// Displayed as **Paid**.
	OrderDisplayFinancialStatusPaid OrderDisplayFinancialStatus = "PAID"
	// Displayed as **Refunded**.
	OrderDisplayFinancialStatusRefunded OrderDisplayFinancialStatus = "REFUNDED"
)

var AllOrderDisplayFinancialStatus = []OrderDisplayFinancialStatus{
	OrderDisplayFinancialStatusPending,
	OrderDisplayFinancialStatusAuthorized,
	OrderDisplayFinancialStatusPartiallyPaid,
	OrderDisplayFinancialStatusPartiallyRefunded,
	OrderDisplayFinancialStatusVoided,
	OrderDisplayFinancialStatusPaid,
	OrderDisplayFinancialStatusRefunded,
}

func (e OrderDisplayFinancialStatus) IsValid() bool {
	switch e {
	case OrderDisplayFinancialStatusPending, OrderDisplayFinancialStatusAuthorized, OrderDisplayFinancialStatusPartiallyPaid, OrderDisplayFinancialStatusPartiallyRefunded, OrderDisplayFinancialStatusVoided, OrderDisplayFinancialStatusPaid, OrderDisplayFinancialStatusRefunded:
		return true
	}
	return false
}

func (e OrderDisplayFinancialStatus) String() string {
	return string(e)
}

func (e *OrderDisplayFinancialStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDisplayFinancialStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDisplayFinancialStatus", str)
	}
	return nil
}

func (e OrderDisplayFinancialStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the order's current fulfillment status. Valid values are: unfulfilled, partial, fulfilled, restocked.
type OrderDisplayFulfillmentStatus string

const (
	// Displayed as **Unfulfilled**.
	OrderDisplayFulfillmentStatusUnfulfilled OrderDisplayFulfillmentStatus = "UNFULFILLED"
	// Displayed as **Partially fulfilled**.
	OrderDisplayFulfillmentStatusPartiallyFulfilled OrderDisplayFulfillmentStatus = "PARTIALLY_FULFILLED"
	// Displayed as **Fulfilled**.
	OrderDisplayFulfillmentStatusFulfilled OrderDisplayFulfillmentStatus = "FULFILLED"
	// Displayed as **Restocked**.
	OrderDisplayFulfillmentStatusRestocked OrderDisplayFulfillmentStatus = "RESTOCKED"
	// Displayed as **Pending fulfillment**.
	OrderDisplayFulfillmentStatusPendingFulfillment OrderDisplayFulfillmentStatus = "PENDING_FULFILLMENT"
	// Displayed as **Open**.
	OrderDisplayFulfillmentStatusOpen OrderDisplayFulfillmentStatus = "OPEN"
	// Displayed as **In progress**.
	OrderDisplayFulfillmentStatusInProgress OrderDisplayFulfillmentStatus = "IN_PROGRESS"
)

var AllOrderDisplayFulfillmentStatus = []OrderDisplayFulfillmentStatus{
	OrderDisplayFulfillmentStatusUnfulfilled,
	OrderDisplayFulfillmentStatusPartiallyFulfilled,
	OrderDisplayFulfillmentStatusFulfilled,
	OrderDisplayFulfillmentStatusRestocked,
	OrderDisplayFulfillmentStatusPendingFulfillment,
	OrderDisplayFulfillmentStatusOpen,
	OrderDisplayFulfillmentStatusInProgress,
}

func (e OrderDisplayFulfillmentStatus) IsValid() bool {
	switch e {
	case OrderDisplayFulfillmentStatusUnfulfilled, OrderDisplayFulfillmentStatusPartiallyFulfilled, OrderDisplayFulfillmentStatusFulfilled, OrderDisplayFulfillmentStatusRestocked, OrderDisplayFulfillmentStatusPendingFulfillment, OrderDisplayFulfillmentStatusOpen, OrderDisplayFulfillmentStatusInProgress:
		return true
	}
	return false
}

func (e OrderDisplayFulfillmentStatus) String() string {
	return string(e)
}

func (e *OrderDisplayFulfillmentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDisplayFulfillmentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDisplayFulfillmentStatus", str)
	}
	return nil
}

func (e OrderDisplayFulfillmentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The likelihood that an order is fraudulent.
type OrderRiskLevel string

const (
	// There is a low level of risk that this order is fraudulent.
	OrderRiskLevelLow OrderRiskLevel = "LOW"
	// There is a medium level of risk that this order is fraudulent.
	OrderRiskLevelMedium OrderRiskLevel = "MEDIUM"
	// There is a high level of risk that this order is fraudulent.
	OrderRiskLevelHigh OrderRiskLevel = "HIGH"
)

var AllOrderRiskLevel = []OrderRiskLevel{
	OrderRiskLevelLow,
	OrderRiskLevelMedium,
	OrderRiskLevelHigh,
}

func (e OrderRiskLevel) IsValid() bool {
	switch e {
	case OrderRiskLevelLow, OrderRiskLevelMedium, OrderRiskLevelHigh:
		return true
	}
	return false
}

func (e OrderRiskLevel) String() string {
	return string(e)
}

func (e *OrderRiskLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderRiskLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderRiskLevel", str)
	}
	return nil
}

func (e OrderRiskLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Order query.
type OrderSortKeys string

const (
	// Sort by the `created_at` value.
	OrderSortKeysCreatedAt OrderSortKeys = "CREATED_AT"
	// Sort by the `customer_name` value.
	OrderSortKeysCustomerName OrderSortKeys = "CUSTOMER_NAME"
	// Sort by the `financial_status` value.
	OrderSortKeysFinancialStatus OrderSortKeys = "FINANCIAL_STATUS"
	// Sort by the `fulfillment_status` value.
	OrderSortKeysFulfillmentStatus OrderSortKeys = "FULFILLMENT_STATUS"
	// Sort by the `order_number` value.
	OrderSortKeysOrderNumber OrderSortKeys = "ORDER_NUMBER"
	// Sort by the `processed_at` value.
	OrderSortKeysProcessedAt OrderSortKeys = "PROCESSED_AT"
	// Sort by the `total_price` value.
	OrderSortKeysTotalPrice OrderSortKeys = "TOTAL_PRICE"
	// Sort by the `updated_at` value.
	OrderSortKeysUpdatedAt OrderSortKeys = "UPDATED_AT"
	// Sort by the `id` value.
	OrderSortKeysID OrderSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	OrderSortKeysRelevance OrderSortKeys = "RELEVANCE"
)

var AllOrderSortKeys = []OrderSortKeys{
	OrderSortKeysCreatedAt,
	OrderSortKeysCustomerName,
	OrderSortKeysFinancialStatus,
	OrderSortKeysFulfillmentStatus,
	OrderSortKeysOrderNumber,
	OrderSortKeysProcessedAt,
	OrderSortKeysTotalPrice,
	OrderSortKeysUpdatedAt,
	OrderSortKeysID,
	OrderSortKeysRelevance,
}

func (e OrderSortKeys) IsValid() bool {
	switch e {
	case OrderSortKeysCreatedAt, OrderSortKeysCustomerName, OrderSortKeysFinancialStatus, OrderSortKeysFulfillmentStatus, OrderSortKeysOrderNumber, OrderSortKeysProcessedAt, OrderSortKeysTotalPrice, OrderSortKeysUpdatedAt, OrderSortKeysID, OrderSortKeysRelevance:
		return true
	}
	return false
}

func (e OrderSortKeys) String() string {
	return string(e)
}

func (e *OrderSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderSortKeys", str)
	}
	return nil
}

func (e OrderSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A standardized error code, independent of the payment provider.
type OrderTransactionErrorCode string

const (
	// The card number is incorrect.
	OrderTransactionErrorCodeIncorrectNumber OrderTransactionErrorCode = "INCORRECT_NUMBER"
	// The format of the card number is incorrect.
	OrderTransactionErrorCodeInvalidNumber OrderTransactionErrorCode = "INVALID_NUMBER"
	// The format of the expiry date is incorrect.
	OrderTransactionErrorCodeInvalidExpiryDate OrderTransactionErrorCode = "INVALID_EXPIRY_DATE"
	// The format of the CVC is incorrect.
	OrderTransactionErrorCodeInvalidCvc OrderTransactionErrorCode = "INVALID_CVC"
	// The card is expired.
	OrderTransactionErrorCodeExpiredCard OrderTransactionErrorCode = "EXPIRED_CARD"
	// The CVC does not match the card number.
	OrderTransactionErrorCodeIncorrectCvc OrderTransactionErrorCode = "INCORRECT_CVC"
	// The ZIP or postal code does not match the card number.
	OrderTransactionErrorCodeIncorrectZip OrderTransactionErrorCode = "INCORRECT_ZIP"
	// The address does not match the card number.
	OrderTransactionErrorCodeIncorrectAddress OrderTransactionErrorCode = "INCORRECT_ADDRESS"
	// The entered PIN is incorrect.
	OrderTransactionErrorCodeIncorrectPin OrderTransactionErrorCode = "INCORRECT_PIN"
	// The card was declined.
	OrderTransactionErrorCodeCardDeclined OrderTransactionErrorCode = "CARD_DECLINED"
	// There was an error while processing the payment.
	OrderTransactionErrorCodeProcessingError OrderTransactionErrorCode = "PROCESSING_ERROR"
	// Call the card issuer.
	OrderTransactionErrorCodeCallIssuer OrderTransactionErrorCode = "CALL_ISSUER"
	// The card has been reported as lost or stolen, and the card issuer has requested that the merchant keep the card and call the number on the back.
	//
	OrderTransactionErrorCodePickUpCard OrderTransactionErrorCode = "PICK_UP_CARD"
	// There is an error in the gateway or merchant configuration.
	OrderTransactionErrorCodeConfigError OrderTransactionErrorCode = "CONFIG_ERROR"
	// A real card was used but the gateway was in test mode.
	OrderTransactionErrorCodeTestModeLiveCard OrderTransactionErrorCode = "TEST_MODE_LIVE_CARD"
	// The gateway or merchant configuration doesn't support a feature, such as network tokenization.
	OrderTransactionErrorCodeUnsupportedFeature OrderTransactionErrorCode = "UNSUPPORTED_FEATURE"
	// There was an unknown error with processing the payment.
	OrderTransactionErrorCodeGenericError OrderTransactionErrorCode = "GENERIC_ERROR"
	// The payment method is not available in the customer's country.
	OrderTransactionErrorCodeInvalidCountry OrderTransactionErrorCode = "INVALID_COUNTRY"
	// The amount is either too high or too low for the provider.
	OrderTransactionErrorCodeInvalidAmount OrderTransactionErrorCode = "INVALID_AMOUNT"
	// The payment method is momentarily unavailable.
	OrderTransactionErrorCodePaymentMethodUnavailable OrderTransactionErrorCode = "PAYMENT_METHOD_UNAVAILABLE"
	// The payment method was invalid.
	OrderTransactionErrorCodeAmazonPaymentsInvalidPaymentMethod OrderTransactionErrorCode = "AMAZON_PAYMENTS_INVALID_PAYMENT_METHOD"
	// The maximum amount has been captured.
	OrderTransactionErrorCodeAmazonPaymentsMaxAmountCharged OrderTransactionErrorCode = "AMAZON_PAYMENTS_MAX_AMOUNT_CHARGED"
	// The maximum amount has been refunded.
	OrderTransactionErrorCodeAmazonPaymentsMaxAmountRefunded OrderTransactionErrorCode = "AMAZON_PAYMENTS_MAX_AMOUNT_REFUNDED"
	// The maximum of 10 authorizations has been captured for an order.
	OrderTransactionErrorCodeAmazonPaymentsMaxAuthorizationsCaptured OrderTransactionErrorCode = "AMAZON_PAYMENTS_MAX_AUTHORIZATIONS_CAPTURED"
	// The maximum of 10 refunds has been processed for an order.
	OrderTransactionErrorCodeAmazonPaymentsMaxRefundsProcessed OrderTransactionErrorCode = "AMAZON_PAYMENTS_MAX_REFUNDS_PROCESSED"
	// The order was canceled, which canceled all open authorizations.
	OrderTransactionErrorCodeAmazonPaymentsOrderReferenceCanceled OrderTransactionErrorCode = "AMAZON_PAYMENTS_ORDER_REFERENCE_CANCELED"
	// The order was not confirmed within three hours.
	OrderTransactionErrorCodeAmazonPaymentsStale OrderTransactionErrorCode = "AMAZON_PAYMENTS_STALE"
)

var AllOrderTransactionErrorCode = []OrderTransactionErrorCode{
	OrderTransactionErrorCodeIncorrectNumber,
	OrderTransactionErrorCodeInvalidNumber,
	OrderTransactionErrorCodeInvalidExpiryDate,
	OrderTransactionErrorCodeInvalidCvc,
	OrderTransactionErrorCodeExpiredCard,
	OrderTransactionErrorCodeIncorrectCvc,
	OrderTransactionErrorCodeIncorrectZip,
	OrderTransactionErrorCodeIncorrectAddress,
	OrderTransactionErrorCodeIncorrectPin,
	OrderTransactionErrorCodeCardDeclined,
	OrderTransactionErrorCodeProcessingError,
	OrderTransactionErrorCodeCallIssuer,
	OrderTransactionErrorCodePickUpCard,
	OrderTransactionErrorCodeConfigError,
	OrderTransactionErrorCodeTestModeLiveCard,
	OrderTransactionErrorCodeUnsupportedFeature,
	OrderTransactionErrorCodeGenericError,
	OrderTransactionErrorCodeInvalidCountry,
	OrderTransactionErrorCodeInvalidAmount,
	OrderTransactionErrorCodePaymentMethodUnavailable,
	OrderTransactionErrorCodeAmazonPaymentsInvalidPaymentMethod,
	OrderTransactionErrorCodeAmazonPaymentsMaxAmountCharged,
	OrderTransactionErrorCodeAmazonPaymentsMaxAmountRefunded,
	OrderTransactionErrorCodeAmazonPaymentsMaxAuthorizationsCaptured,
	OrderTransactionErrorCodeAmazonPaymentsMaxRefundsProcessed,
	OrderTransactionErrorCodeAmazonPaymentsOrderReferenceCanceled,
	OrderTransactionErrorCodeAmazonPaymentsStale,
}

func (e OrderTransactionErrorCode) IsValid() bool {
	switch e {
	case OrderTransactionErrorCodeIncorrectNumber, OrderTransactionErrorCodeInvalidNumber, OrderTransactionErrorCodeInvalidExpiryDate, OrderTransactionErrorCodeInvalidCvc, OrderTransactionErrorCodeExpiredCard, OrderTransactionErrorCodeIncorrectCvc, OrderTransactionErrorCodeIncorrectZip, OrderTransactionErrorCodeIncorrectAddress, OrderTransactionErrorCodeIncorrectPin, OrderTransactionErrorCodeCardDeclined, OrderTransactionErrorCodeProcessingError, OrderTransactionErrorCodeCallIssuer, OrderTransactionErrorCodePickUpCard, OrderTransactionErrorCodeConfigError, OrderTransactionErrorCodeTestModeLiveCard, OrderTransactionErrorCodeUnsupportedFeature, OrderTransactionErrorCodeGenericError, OrderTransactionErrorCodeInvalidCountry, OrderTransactionErrorCodeInvalidAmount, OrderTransactionErrorCodePaymentMethodUnavailable, OrderTransactionErrorCodeAmazonPaymentsInvalidPaymentMethod, OrderTransactionErrorCodeAmazonPaymentsMaxAmountCharged, OrderTransactionErrorCodeAmazonPaymentsMaxAmountRefunded, OrderTransactionErrorCodeAmazonPaymentsMaxAuthorizationsCaptured, OrderTransactionErrorCodeAmazonPaymentsMaxRefundsProcessed, OrderTransactionErrorCodeAmazonPaymentsOrderReferenceCanceled, OrderTransactionErrorCodeAmazonPaymentsStale:
		return true
	}
	return false
}

func (e OrderTransactionErrorCode) String() string {
	return string(e)
}

func (e *OrderTransactionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTransactionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTransactionErrorCode", str)
	}
	return nil
}

func (e OrderTransactionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The different kinds of order transactions.
type OrderTransactionKind string

const (
	// An authorization and capture performed together in a single step.
	OrderTransactionKindSale OrderTransactionKind = "SALE"
	// A transfer of the money that was reserved during the authorization stage.
	OrderTransactionKindCapture OrderTransactionKind = "CAPTURE"
	// An amount reserved against the cardholder's funding source.
	// Money does not change hands until the authorization is captured.
	//
	OrderTransactionKindAuthorization OrderTransactionKind = "AUTHORIZATION"
	// A cancellation of a pending authorization or capture.
	OrderTransactionKindVoid OrderTransactionKind = "VOID"
	// A partial or full return of captured funds to the cardholder.
	// A refund can happen only after a capture is processed.
	//
	OrderTransactionKindRefund OrderTransactionKind = "REFUND"
	// Money returned to the customer when they have paid too much.
	OrderTransactionKindChange OrderTransactionKind = "CHANGE"
	// An authorization for a payment taken with an EMV credit card reader.
	OrderTransactionKindEmvAuthorization OrderTransactionKind = "EMV_AUTHORIZATION"
	// A suggested refund transaction that can be used to create a refund.
	OrderTransactionKindSuggestedRefund OrderTransactionKind = "SUGGESTED_REFUND"
)

var AllOrderTransactionKind = []OrderTransactionKind{
	OrderTransactionKindSale,
	OrderTransactionKindCapture,
	OrderTransactionKindAuthorization,
	OrderTransactionKindVoid,
	OrderTransactionKindRefund,
	OrderTransactionKindChange,
	OrderTransactionKindEmvAuthorization,
	OrderTransactionKindSuggestedRefund,
}

func (e OrderTransactionKind) IsValid() bool {
	switch e {
	case OrderTransactionKindSale, OrderTransactionKindCapture, OrderTransactionKindAuthorization, OrderTransactionKindVoid, OrderTransactionKindRefund, OrderTransactionKindChange, OrderTransactionKindEmvAuthorization, OrderTransactionKindSuggestedRefund:
		return true
	}
	return false
}

func (e OrderTransactionKind) String() string {
	return string(e)
}

func (e *OrderTransactionKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTransactionKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTransactionKind", str)
	}
	return nil
}

func (e OrderTransactionKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Transaction status' describe the status of a transaction.
type OrderTransactionStatus string

const (
	// The transaction succeeded.
	OrderTransactionStatusSuccess OrderTransactionStatus = "SUCCESS"
	// The transaction failed.
	OrderTransactionStatusFailure OrderTransactionStatus = "FAILURE"
	// The transaction is pending.
	OrderTransactionStatusPending OrderTransactionStatus = "PENDING"
	// There was an error while processing the transaction.
	OrderTransactionStatusError OrderTransactionStatus = "ERROR"
	// Awaiting a response.
	OrderTransactionStatusAwaitingResponse OrderTransactionStatus = "AWAITING_RESPONSE"
	// The transaction status is unknown.
	OrderTransactionStatusUnknown OrderTransactionStatus = "UNKNOWN"
)

var AllOrderTransactionStatus = []OrderTransactionStatus{
	OrderTransactionStatusSuccess,
	OrderTransactionStatusFailure,
	OrderTransactionStatusPending,
	OrderTransactionStatusError,
	OrderTransactionStatusAwaitingResponse,
	OrderTransactionStatusUnknown,
}

func (e OrderTransactionStatus) IsValid() bool {
	switch e {
	case OrderTransactionStatusSuccess, OrderTransactionStatusFailure, OrderTransactionStatusPending, OrderTransactionStatusError, OrderTransactionStatusAwaitingResponse, OrderTransactionStatusUnknown:
		return true
	}
	return false
}

func (e OrderTransactionStatus) String() string {
	return string(e)
}

func (e *OrderTransactionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderTransactionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderTransactionStatus", str)
	}
	return nil
}

func (e OrderTransactionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// List of payment methods used in Shopify.
type PaymentMethods string

const (
	PaymentMethodsVisa               PaymentMethods = "VISA"
	PaymentMethodsMastercard         PaymentMethods = "MASTERCARD"
	PaymentMethodsDiscover           PaymentMethods = "DISCOVER"
	PaymentMethodsAmericanExpress    PaymentMethods = "AMERICAN_EXPRESS"
	PaymentMethodsDinersClub         PaymentMethods = "DINERS_CLUB"
	PaymentMethodsJcb                PaymentMethods = "JCB"
	PaymentMethodsDankort            PaymentMethods = "DANKORT"
	PaymentMethodsMaestro            PaymentMethods = "MAESTRO"
	PaymentMethodsForbrugsforeningen PaymentMethods = "FORBRUGSFORENINGEN"
	PaymentMethodsPaypal             PaymentMethods = "PAYPAL"
	PaymentMethodsBogus              PaymentMethods = "BOGUS"
	PaymentMethodsBitcoin            PaymentMethods = "BITCOIN"
	PaymentMethodsLitecoin           PaymentMethods = "LITECOIN"
	PaymentMethodsDogecoin           PaymentMethods = "DOGECOIN"
)

var AllPaymentMethods = []PaymentMethods{
	PaymentMethodsVisa,
	PaymentMethodsMastercard,
	PaymentMethodsDiscover,
	PaymentMethodsAmericanExpress,
	PaymentMethodsDinersClub,
	PaymentMethodsJcb,
	PaymentMethodsDankort,
	PaymentMethodsMaestro,
	PaymentMethodsForbrugsforeningen,
	PaymentMethodsPaypal,
	PaymentMethodsBogus,
	PaymentMethodsBitcoin,
	PaymentMethodsLitecoin,
	PaymentMethodsDogecoin,
}

func (e PaymentMethods) IsValid() bool {
	switch e {
	case PaymentMethodsVisa, PaymentMethodsMastercard, PaymentMethodsDiscover, PaymentMethodsAmericanExpress, PaymentMethodsDinersClub, PaymentMethodsJcb, PaymentMethodsDankort, PaymentMethodsMaestro, PaymentMethodsForbrugsforeningen, PaymentMethodsPaypal, PaymentMethodsBogus, PaymentMethodsBitcoin, PaymentMethodsLitecoin, PaymentMethodsDogecoin:
		return true
	}
	return false
}

func (e PaymentMethods) String() string {
	return string(e)
}

func (e *PaymentMethods) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethods(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentMethods", str)
	}
	return nil
}

func (e PaymentMethods) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The method by which the price rule's value is allocated to its entitled items.
type PriceRuleAllocationMethod string

const (
	// The value will be applied to each of the entitled items.
	PriceRuleAllocationMethodEach PriceRuleAllocationMethod = "EACH"
	// The value will be applied once across the entitled items.
	PriceRuleAllocationMethodAcross PriceRuleAllocationMethod = "ACROSS"
)

var AllPriceRuleAllocationMethod = []PriceRuleAllocationMethod{
	PriceRuleAllocationMethodEach,
	PriceRuleAllocationMethodAcross,
}

func (e PriceRuleAllocationMethod) IsValid() bool {
	switch e {
	case PriceRuleAllocationMethodEach, PriceRuleAllocationMethodAcross:
		return true
	}
	return false
}

func (e PriceRuleAllocationMethod) String() string {
	return string(e)
}

func (e *PriceRuleAllocationMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleAllocationMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleAllocationMethod", str)
	}
	return nil
}

func (e PriceRuleAllocationMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by a price rule mutation.
type PriceRuleErrorCode string

const (
	// Input value is blank.
	PriceRuleErrorCodeBlank PriceRuleErrorCode = "BLANK"
	// Input value should be equal to allowed value.
	PriceRuleErrorCodeEqualTo PriceRuleErrorCode = "EQUAL_TO"
	// Input value should be greater than minimum allowed value.
	PriceRuleErrorCodeGreaterThan PriceRuleErrorCode = "GREATER_THAN"
	// Input value should be greater than or equal to minimum allowed value.
	PriceRuleErrorCodeGreaterThanOrEqualTo PriceRuleErrorCode = "GREATER_THAN_OR_EQUAL_TO"
	// Input value is invalid.
	PriceRuleErrorCodeInvalid PriceRuleErrorCode = "INVALID"
	// Input value should be less than maximum allowed value.
	PriceRuleErrorCodeLessThan PriceRuleErrorCode = "LESS_THAN"
	// Input value should be less or equal to maximum allowed value.
	PriceRuleErrorCodeLessThanOrEqualTo PriceRuleErrorCode = "LESS_THAN_OR_EQUAL_TO"
	// Input value is already taken.
	PriceRuleErrorCodeTaken PriceRuleErrorCode = "TAKEN"
	// Input value is too long.
	PriceRuleErrorCodeTooLong PriceRuleErrorCode = "TOO_LONG"
	// Input value is too short.
	PriceRuleErrorCodeTooShort PriceRuleErrorCode = "TOO_SHORT"
	// Unexpected internal error happened.
	PriceRuleErrorCodeInternalError PriceRuleErrorCode = "INTERNAL_ERROR"
	// Too many arguments provided.
	PriceRuleErrorCodeTooManyArguments PriceRuleErrorCode = "TOO_MANY_ARGUMENTS"
	// Missing a required argument.
	PriceRuleErrorCodeMissingArgument PriceRuleErrorCode = "MISSING_ARGUMENT"
	// Duplicate customer prerequisite id present.
	PriceRuleErrorCodeCustomerPrerequisiteDuplicate                     PriceRuleErrorCode = "CUSTOMER_PREREQUISITE_DUPLICATE"
	PriceRuleErrorCodeCannotEntitleCollectionsWithProductsOrVariants    PriceRuleErrorCode = "CANNOT_ENTITLE_COLLECTIONS_WITH_PRODUCTS_OR_VARIANTS"
	PriceRuleErrorCodeItemEntitlementInvalidType                        PriceRuleErrorCode = "ITEM_ENTITLEMENT_INVALID_TYPE"
	PriceRuleErrorCodeItemEntitlementsDuplicateCollection               PriceRuleErrorCode = "ITEM_ENTITLEMENTS_DUPLICATE_COLLECTION"
	PriceRuleErrorCodeItemEntitlementsDuplicateProduct                  PriceRuleErrorCode = "ITEM_ENTITLEMENTS_DUPLICATE_PRODUCT"
	PriceRuleErrorCodeItemEntitlementsDuplicateVariant                  PriceRuleErrorCode = "ITEM_ENTITLEMENTS_DUPLICATE_VARIANT"
	PriceRuleErrorCodeItemEntitlementsExceededMaxCollection             PriceRuleErrorCode = "ITEM_ENTITLEMENTS_EXCEEDED_MAX_COLLECTION"
	PriceRuleErrorCodeItemEntitlementsExceededMaxProduct                PriceRuleErrorCode = "ITEM_ENTITLEMENTS_EXCEEDED_MAX_PRODUCT"
	PriceRuleErrorCodeItemEntitlementsExceededMaxVariant                PriceRuleErrorCode = "ITEM_ENTITLEMENTS_EXCEEDED_MAX_VARIANT"
	PriceRuleErrorCodeItemEntitlementsInvalidCollection                 PriceRuleErrorCode = "ITEM_ENTITLEMENTS_INVALID_COLLECTION"
	PriceRuleErrorCodeItemEntitlementsInvalidProduct                    PriceRuleErrorCode = "ITEM_ENTITLEMENTS_INVALID_PRODUCT"
	PriceRuleErrorCodeItemEntitlementsInvalidTargetTypeOrSelection      PriceRuleErrorCode = "ITEM_ENTITLEMENTS_INVALID_TARGET_TYPE_OR_SELECTION"
	PriceRuleErrorCodeItemEntitlementsInvalidVariant                    PriceRuleErrorCode = "ITEM_ENTITLEMENTS_INVALID_VARIANT"
	PriceRuleErrorCodeItemEntitlementsMissing                           PriceRuleErrorCode = "ITEM_ENTITLEMENTS_MISSING"
	PriceRuleErrorCodeVariantAlreadyEntitledThroughProduct              PriceRuleErrorCode = "VARIANT_ALREADY_ENTITLED_THROUGH_PRODUCT"
	PriceRuleErrorCodeCannotPrerequisiteCollectionWithProductOrVariants PriceRuleErrorCode = "CANNOT_PREREQUISITE_COLLECTION_WITH_PRODUCT_OR_VARIANTS"
	PriceRuleErrorCodeItemPrerequisitesDuplicateCollection              PriceRuleErrorCode = "ITEM_PREREQUISITES_DUPLICATE_COLLECTION"
	PriceRuleErrorCodeItemPrerequisitesDuplicateProduct                 PriceRuleErrorCode = "ITEM_PREREQUISITES_DUPLICATE_PRODUCT"
	PriceRuleErrorCodeItemPrerequisitesDuplicateVariant                 PriceRuleErrorCode = "ITEM_PREREQUISITES_DUPLICATE_VARIANT"
	PriceRuleErrorCodeItemPrerequisitesExceededMax                      PriceRuleErrorCode = "ITEM_PREREQUISITES_EXCEEDED_MAX"
	PriceRuleErrorCodeItemPrerequisitesInvalidCollection                PriceRuleErrorCode = "ITEM_PREREQUISITES_INVALID_COLLECTION"
	PriceRuleErrorCodeItemPrerequisitesInvalidProduct                   PriceRuleErrorCode = "ITEM_PREREQUISITES_INVALID_PRODUCT"
	PriceRuleErrorCodeItemPrerequisitesInvalidType                      PriceRuleErrorCode = "ITEM_PREREQUISITES_INVALID_TYPE"
	PriceRuleErrorCodeItemPrerequisitesInvalidVariant                   PriceRuleErrorCode = "ITEM_PREREQUISITES_INVALID_VARIANT"
	PriceRuleErrorCodeItemPrerequisitesMissing                          PriceRuleErrorCode = "ITEM_PREREQUISITES_MISSING"
	PriceRuleErrorCodeItemPrerequisitesMustBeEmpty                      PriceRuleErrorCode = "ITEM_PREREQUISITES_MUST_BE_EMPTY"
	PriceRuleErrorCodeInvalidTargetTypePrerequisiteShippingPriceRange   PriceRuleErrorCode = "INVALID_TARGET_TYPE_PREREQUISITE_SHIPPING_PRICE_RANGE"
	PriceRuleErrorCodeShippingEntitlementsDuplicateCountry              PriceRuleErrorCode = "SHIPPING_ENTITLEMENTS_DUPLICATE_COUNTRY"
	PriceRuleErrorCodeShippingEntitlementsExceededMax                   PriceRuleErrorCode = "SHIPPING_ENTITLEMENTS_EXCEEDED_MAX"
	PriceRuleErrorCodeShippingEntitlementsInvalidCountry                PriceRuleErrorCode = "SHIPPING_ENTITLEMENTS_INVALID_COUNTRY"
	PriceRuleErrorCodeShippingEntitlementsInvalidTargetTypeOrSelection  PriceRuleErrorCode = "SHIPPING_ENTITLEMENTS_INVALID_TARGET_TYPE_OR_SELECTION"
	PriceRuleErrorCodeShippingEntitlementsMissing                       PriceRuleErrorCode = "SHIPPING_ENTITLEMENTS_MISSING"
	PriceRuleErrorCodeShippingEntitlementsUnsupportedDestinationType    PriceRuleErrorCode = "SHIPPING_ENTITLEMENTS_UNSUPPORTED_DESTINATION_TYPE"
	PriceRuleErrorCodeBothCustomerAndSavedSearchPrerequisitesSelected   PriceRuleErrorCode = "BOTH_CUSTOMER_AND_SAVED_SEARCH_PREREQUISITES_SELECTED"
	PriceRuleErrorCodeCustomerPrerequisitesExceededMax                  PriceRuleErrorCode = "CUSTOMER_PREREQUISITES_EXCEEDED_MAX"
	PriceRuleErrorCodeCustomerPrerequisitesInvalidSelection             PriceRuleErrorCode = "CUSTOMER_PREREQUISITES_INVALID_SELECTION"
	PriceRuleErrorCodeCustomerPrerequisitesMissing                      PriceRuleErrorCode = "CUSTOMER_PREREQUISITES_MISSING"
	PriceRuleErrorCodeCustomerSavedSearchDuplicate                      PriceRuleErrorCode = "CUSTOMER_SAVED_SEARCH_DUPLICATE"
	PriceRuleErrorCodeCustomerSavedSearchExceededMax                    PriceRuleErrorCode = "CUSTOMER_SAVED_SEARCH_EXCEEDED_MAX"
	PriceRuleErrorCodeCustomerSavedSearchInvalid                        PriceRuleErrorCode = "CUSTOMER_SAVED_SEARCH_INVALID"
	PriceRuleErrorCodeDiscountCodeDuplicate                             PriceRuleErrorCode = "DISCOUNT_CODE_DUPLICATE"
	// Exceeds maximum number allowed.
	PriceRuleErrorCodeExceededMax                PriceRuleErrorCode = "EXCEEDED_MAX"
	PriceRuleErrorCodeBogoInvalidTargetSelection PriceRuleErrorCode = "BOGO_INVALID_TARGET_SELECTION"
	PriceRuleErrorCodeBogoInvalidTargetType      PriceRuleErrorCode = "BOGO_INVALID_TARGET_TYPE"
	PriceRuleErrorCodeBogoInvalidValueType       PriceRuleErrorCode = "BOGO_INVALID_VALUE_TYPE"
	// Allocation limit can only be set on buy one get one type discounts.
	PriceRuleErrorCodePriceRuleAllocationLimitOnNonBogo PriceRuleErrorCode = "PRICE_RULE_ALLOCATION_LIMIT_ON_NON_BOGO"
	// Allocation limit must be a non zero positive number.
	PriceRuleErrorCodePriceRuleAllocationLimitIsZero PriceRuleErrorCode = "PRICE_RULE_ALLOCATION_LIMIT_IS_ZERO"
	// Number of discount codes in the shop has reached its limit.
	PriceRuleErrorCodePriceRuleExceededMaxDiscountCode PriceRuleErrorCode = "PRICE_RULE_EXCEEDED_MAX_DISCOUNT_CODE"
	// Number of discounts in the shop has reached its limit.
	PriceRuleErrorCodeShopExceededMaxPriceRules PriceRuleErrorCode = "SHOP_EXCEEDED_MAX_PRICE_RULES"
	// Discount end date must be after the start date.
	PriceRuleErrorCodeEndDateBeforeStartDate PriceRuleErrorCode = "END_DATE_BEFORE_START_DATE"
	// Percentage value must be between 0 and -100.
	PriceRuleErrorCodePriceRulePercentageValueOutsideRange PriceRuleErrorCode = "PRICE_RULE_PERCENTAGE_VALUE_OUTSIDE_RANGE"
	// Only one of minimum subtotal or minimum quantity condition can be defined.
	PriceRuleErrorCodePrerequisiteSubtotalAndQuantityRangeBothPresent PriceRuleErrorCode = "PREREQUISITE_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT"
	// Allocation method must be "across" for the provided target selection.
	PriceRuleErrorCodeAllocationMethodMustBeAcrossForGivenTargetSelection PriceRuleErrorCode = "ALLOCATION_METHOD_MUST_BE_ACROSS_FOR_GIVEN_TARGET_SELECTION"
)

var AllPriceRuleErrorCode = []PriceRuleErrorCode{
	PriceRuleErrorCodeBlank,
	PriceRuleErrorCodeEqualTo,
	PriceRuleErrorCodeGreaterThan,
	PriceRuleErrorCodeGreaterThanOrEqualTo,
	PriceRuleErrorCodeInvalid,
	PriceRuleErrorCodeLessThan,
	PriceRuleErrorCodeLessThanOrEqualTo,
	PriceRuleErrorCodeTaken,
	PriceRuleErrorCodeTooLong,
	PriceRuleErrorCodeTooShort,
	PriceRuleErrorCodeInternalError,
	PriceRuleErrorCodeTooManyArguments,
	PriceRuleErrorCodeMissingArgument,
	PriceRuleErrorCodeCustomerPrerequisiteDuplicate,
	PriceRuleErrorCodeCannotEntitleCollectionsWithProductsOrVariants,
	PriceRuleErrorCodeItemEntitlementInvalidType,
	PriceRuleErrorCodeItemEntitlementsDuplicateCollection,
	PriceRuleErrorCodeItemEntitlementsDuplicateProduct,
	PriceRuleErrorCodeItemEntitlementsDuplicateVariant,
	PriceRuleErrorCodeItemEntitlementsExceededMaxCollection,
	PriceRuleErrorCodeItemEntitlementsExceededMaxProduct,
	PriceRuleErrorCodeItemEntitlementsExceededMaxVariant,
	PriceRuleErrorCodeItemEntitlementsInvalidCollection,
	PriceRuleErrorCodeItemEntitlementsInvalidProduct,
	PriceRuleErrorCodeItemEntitlementsInvalidTargetTypeOrSelection,
	PriceRuleErrorCodeItemEntitlementsInvalidVariant,
	PriceRuleErrorCodeItemEntitlementsMissing,
	PriceRuleErrorCodeVariantAlreadyEntitledThroughProduct,
	PriceRuleErrorCodeCannotPrerequisiteCollectionWithProductOrVariants,
	PriceRuleErrorCodeItemPrerequisitesDuplicateCollection,
	PriceRuleErrorCodeItemPrerequisitesDuplicateProduct,
	PriceRuleErrorCodeItemPrerequisitesDuplicateVariant,
	PriceRuleErrorCodeItemPrerequisitesExceededMax,
	PriceRuleErrorCodeItemPrerequisitesInvalidCollection,
	PriceRuleErrorCodeItemPrerequisitesInvalidProduct,
	PriceRuleErrorCodeItemPrerequisitesInvalidType,
	PriceRuleErrorCodeItemPrerequisitesInvalidVariant,
	PriceRuleErrorCodeItemPrerequisitesMissing,
	PriceRuleErrorCodeItemPrerequisitesMustBeEmpty,
	PriceRuleErrorCodeInvalidTargetTypePrerequisiteShippingPriceRange,
	PriceRuleErrorCodeShippingEntitlementsDuplicateCountry,
	PriceRuleErrorCodeShippingEntitlementsExceededMax,
	PriceRuleErrorCodeShippingEntitlementsInvalidCountry,
	PriceRuleErrorCodeShippingEntitlementsInvalidTargetTypeOrSelection,
	PriceRuleErrorCodeShippingEntitlementsMissing,
	PriceRuleErrorCodeShippingEntitlementsUnsupportedDestinationType,
	PriceRuleErrorCodeBothCustomerAndSavedSearchPrerequisitesSelected,
	PriceRuleErrorCodeCustomerPrerequisitesExceededMax,
	PriceRuleErrorCodeCustomerPrerequisitesInvalidSelection,
	PriceRuleErrorCodeCustomerPrerequisitesMissing,
	PriceRuleErrorCodeCustomerSavedSearchDuplicate,
	PriceRuleErrorCodeCustomerSavedSearchExceededMax,
	PriceRuleErrorCodeCustomerSavedSearchInvalid,
	PriceRuleErrorCodeDiscountCodeDuplicate,
	PriceRuleErrorCodeExceededMax,
	PriceRuleErrorCodeBogoInvalidTargetSelection,
	PriceRuleErrorCodeBogoInvalidTargetType,
	PriceRuleErrorCodeBogoInvalidValueType,
	PriceRuleErrorCodePriceRuleAllocationLimitOnNonBogo,
	PriceRuleErrorCodePriceRuleAllocationLimitIsZero,
	PriceRuleErrorCodePriceRuleExceededMaxDiscountCode,
	PriceRuleErrorCodeShopExceededMaxPriceRules,
	PriceRuleErrorCodeEndDateBeforeStartDate,
	PriceRuleErrorCodePriceRulePercentageValueOutsideRange,
	PriceRuleErrorCodePrerequisiteSubtotalAndQuantityRangeBothPresent,
	PriceRuleErrorCodeAllocationMethodMustBeAcrossForGivenTargetSelection,
}

func (e PriceRuleErrorCode) IsValid() bool {
	switch e {
	case PriceRuleErrorCodeBlank, PriceRuleErrorCodeEqualTo, PriceRuleErrorCodeGreaterThan, PriceRuleErrorCodeGreaterThanOrEqualTo, PriceRuleErrorCodeInvalid, PriceRuleErrorCodeLessThan, PriceRuleErrorCodeLessThanOrEqualTo, PriceRuleErrorCodeTaken, PriceRuleErrorCodeTooLong, PriceRuleErrorCodeTooShort, PriceRuleErrorCodeInternalError, PriceRuleErrorCodeTooManyArguments, PriceRuleErrorCodeMissingArgument, PriceRuleErrorCodeCustomerPrerequisiteDuplicate, PriceRuleErrorCodeCannotEntitleCollectionsWithProductsOrVariants, PriceRuleErrorCodeItemEntitlementInvalidType, PriceRuleErrorCodeItemEntitlementsDuplicateCollection, PriceRuleErrorCodeItemEntitlementsDuplicateProduct, PriceRuleErrorCodeItemEntitlementsDuplicateVariant, PriceRuleErrorCodeItemEntitlementsExceededMaxCollection, PriceRuleErrorCodeItemEntitlementsExceededMaxProduct, PriceRuleErrorCodeItemEntitlementsExceededMaxVariant, PriceRuleErrorCodeItemEntitlementsInvalidCollection, PriceRuleErrorCodeItemEntitlementsInvalidProduct, PriceRuleErrorCodeItemEntitlementsInvalidTargetTypeOrSelection, PriceRuleErrorCodeItemEntitlementsInvalidVariant, PriceRuleErrorCodeItemEntitlementsMissing, PriceRuleErrorCodeVariantAlreadyEntitledThroughProduct, PriceRuleErrorCodeCannotPrerequisiteCollectionWithProductOrVariants, PriceRuleErrorCodeItemPrerequisitesDuplicateCollection, PriceRuleErrorCodeItemPrerequisitesDuplicateProduct, PriceRuleErrorCodeItemPrerequisitesDuplicateVariant, PriceRuleErrorCodeItemPrerequisitesExceededMax, PriceRuleErrorCodeItemPrerequisitesInvalidCollection, PriceRuleErrorCodeItemPrerequisitesInvalidProduct, PriceRuleErrorCodeItemPrerequisitesInvalidType, PriceRuleErrorCodeItemPrerequisitesInvalidVariant, PriceRuleErrorCodeItemPrerequisitesMissing, PriceRuleErrorCodeItemPrerequisitesMustBeEmpty, PriceRuleErrorCodeInvalidTargetTypePrerequisiteShippingPriceRange, PriceRuleErrorCodeShippingEntitlementsDuplicateCountry, PriceRuleErrorCodeShippingEntitlementsExceededMax, PriceRuleErrorCodeShippingEntitlementsInvalidCountry, PriceRuleErrorCodeShippingEntitlementsInvalidTargetTypeOrSelection, PriceRuleErrorCodeShippingEntitlementsMissing, PriceRuleErrorCodeShippingEntitlementsUnsupportedDestinationType, PriceRuleErrorCodeBothCustomerAndSavedSearchPrerequisitesSelected, PriceRuleErrorCodeCustomerPrerequisitesExceededMax, PriceRuleErrorCodeCustomerPrerequisitesInvalidSelection, PriceRuleErrorCodeCustomerPrerequisitesMissing, PriceRuleErrorCodeCustomerSavedSearchDuplicate, PriceRuleErrorCodeCustomerSavedSearchExceededMax, PriceRuleErrorCodeCustomerSavedSearchInvalid, PriceRuleErrorCodeDiscountCodeDuplicate, PriceRuleErrorCodeExceededMax, PriceRuleErrorCodeBogoInvalidTargetSelection, PriceRuleErrorCodeBogoInvalidTargetType, PriceRuleErrorCodeBogoInvalidValueType, PriceRuleErrorCodePriceRuleAllocationLimitOnNonBogo, PriceRuleErrorCodePriceRuleAllocationLimitIsZero, PriceRuleErrorCodePriceRuleExceededMaxDiscountCode, PriceRuleErrorCodeShopExceededMaxPriceRules, PriceRuleErrorCodeEndDateBeforeStartDate, PriceRuleErrorCodePriceRulePercentageValueOutsideRange, PriceRuleErrorCodePrerequisiteSubtotalAndQuantityRangeBothPresent, PriceRuleErrorCodeAllocationMethodMustBeAcrossForGivenTargetSelection:
		return true
	}
	return false
}

func (e PriceRuleErrorCode) String() string {
	return string(e)
}

func (e *PriceRuleErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleErrorCode", str)
	}
	return nil
}

func (e PriceRuleErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A list of features used by the price rule.
type PriceRuleFeature string

const (
	// The price rule supports quantity BXGY discounts.
	PriceRuleFeatureBuyOneGetOne PriceRuleFeature = "BUY_ONE_GET_ONE"
	// The price rule supports BXGY discounts using custom allocation limit.
	PriceRuleFeatureBuyOneGetOneWithAllocationLimit PriceRuleFeature = "BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT"
	// The price rule supports bulk discounts.
	PriceRuleFeatureBulk PriceRuleFeature = "BULK"
	// The price rule supports specific customers.
	PriceRuleFeatureSpecificCustomers PriceRuleFeature = "SPECIFIC_CUSTOMERS"
	// The price rule supports quantity discounts.
	PriceRuleFeatureQuantityDiscounts PriceRuleFeature = "QUANTITY_DISCOUNTS"
)

var AllPriceRuleFeature = []PriceRuleFeature{
	PriceRuleFeatureBuyOneGetOne,
	PriceRuleFeatureBuyOneGetOneWithAllocationLimit,
	PriceRuleFeatureBulk,
	PriceRuleFeatureSpecificCustomers,
	PriceRuleFeatureQuantityDiscounts,
}

func (e PriceRuleFeature) IsValid() bool {
	switch e {
	case PriceRuleFeatureBuyOneGetOne, PriceRuleFeatureBuyOneGetOneWithAllocationLimit, PriceRuleFeatureBulk, PriceRuleFeatureSpecificCustomers, PriceRuleFeatureQuantityDiscounts:
		return true
	}
	return false
}

func (e PriceRuleFeature) String() string {
	return string(e)
}

func (e *PriceRuleFeature) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleFeature(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleFeature", str)
	}
	return nil
}

func (e PriceRuleFeature) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Page type where shareable URL lands.
type PriceRuleShareableURLTargetType string

const (
	PriceRuleShareableURLTargetTypeHome       PriceRuleShareableURLTargetType = "HOME"
	PriceRuleShareableURLTargetTypeProduct    PriceRuleShareableURLTargetType = "PRODUCT"
	PriceRuleShareableURLTargetTypeCollection PriceRuleShareableURLTargetType = "COLLECTION"
)

var AllPriceRuleShareableURLTargetType = []PriceRuleShareableURLTargetType{
	PriceRuleShareableURLTargetTypeHome,
	PriceRuleShareableURLTargetTypeProduct,
	PriceRuleShareableURLTargetTypeCollection,
}

func (e PriceRuleShareableURLTargetType) IsValid() bool {
	switch e {
	case PriceRuleShareableURLTargetTypeHome, PriceRuleShareableURLTargetTypeProduct, PriceRuleShareableURLTargetTypeCollection:
		return true
	}
	return false
}

func (e PriceRuleShareableURLTargetType) String() string {
	return string(e)
}

func (e *PriceRuleShareableURLTargetType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleShareableURLTargetType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleShareableUrlTargetType", str)
	}
	return nil
}

func (e PriceRuleShareableURLTargetType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the PriceRule query.
type PriceRuleSortKeys string

const (
	// Sort by the `starts_at` value.
	PriceRuleSortKeysStartsAt PriceRuleSortKeys = "STARTS_AT"
	// Sort by the `ends_at` value.
	PriceRuleSortKeysEndsAt PriceRuleSortKeys = "ENDS_AT"
	// Sort by the `title` value.
	PriceRuleSortKeysTitle PriceRuleSortKeys = "TITLE"
	// Sort by the `created_at` value.
	PriceRuleSortKeysCreatedAt PriceRuleSortKeys = "CREATED_AT"
	// Sort by the `updated_at` value.
	PriceRuleSortKeysUpdatedAt PriceRuleSortKeys = "UPDATED_AT"
	// Sort by the `id` value.
	PriceRuleSortKeysID PriceRuleSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	PriceRuleSortKeysRelevance PriceRuleSortKeys = "RELEVANCE"
)

var AllPriceRuleSortKeys = []PriceRuleSortKeys{
	PriceRuleSortKeysStartsAt,
	PriceRuleSortKeysEndsAt,
	PriceRuleSortKeysTitle,
	PriceRuleSortKeysCreatedAt,
	PriceRuleSortKeysUpdatedAt,
	PriceRuleSortKeysID,
	PriceRuleSortKeysRelevance,
}

func (e PriceRuleSortKeys) IsValid() bool {
	switch e {
	case PriceRuleSortKeysStartsAt, PriceRuleSortKeysEndsAt, PriceRuleSortKeysTitle, PriceRuleSortKeysCreatedAt, PriceRuleSortKeysUpdatedAt, PriceRuleSortKeysID, PriceRuleSortKeysRelevance:
		return true
	}
	return false
}

func (e PriceRuleSortKeys) String() string {
	return string(e)
}

func (e *PriceRuleSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleSortKeys", str)
	}
	return nil
}

func (e PriceRuleSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of the price rule.
type PriceRuleStatus string

const (
	PriceRuleStatusActive    PriceRuleStatus = "ACTIVE"
	PriceRuleStatusExpired   PriceRuleStatus = "EXPIRED"
	PriceRuleStatusScheduled PriceRuleStatus = "SCHEDULED"
)

var AllPriceRuleStatus = []PriceRuleStatus{
	PriceRuleStatusActive,
	PriceRuleStatusExpired,
	PriceRuleStatusScheduled,
}

func (e PriceRuleStatus) IsValid() bool {
	switch e {
	case PriceRuleStatusActive, PriceRuleStatusExpired, PriceRuleStatusScheduled:
		return true
	}
	return false
}

func (e PriceRuleStatus) String() string {
	return string(e)
}

func (e *PriceRuleStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleStatus", str)
	}
	return nil
}

func (e PriceRuleStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of lines (line_item or shipping_line) to which the price rule applies.
type PriceRuleTarget string

const (
	// The price rule applies to line items.
	PriceRuleTargetLineItem PriceRuleTarget = "LINE_ITEM"
	// The price rule applies to shipping lines.
	PriceRuleTargetShippingLine PriceRuleTarget = "SHIPPING_LINE"
)

var AllPriceRuleTarget = []PriceRuleTarget{
	PriceRuleTargetLineItem,
	PriceRuleTargetShippingLine,
}

func (e PriceRuleTarget) IsValid() bool {
	switch e {
	case PriceRuleTargetLineItem, PriceRuleTargetShippingLine:
		return true
	}
	return false
}

func (e PriceRuleTarget) String() string {
	return string(e)
}

func (e *PriceRuleTarget) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleTarget(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleTarget", str)
	}
	return nil
}

func (e PriceRuleTarget) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// A list of features used by the price rule.
type PriceRuleTrait string

const (
	// The price rule supports quantity BXGY discounts.
	PriceRuleTraitBuyOneGetOne PriceRuleTrait = "BUY_ONE_GET_ONE"
	// The price rule supports BXGY discounts using custom allocation limit.
	PriceRuleTraitBuyOneGetOneWithAllocationLimit PriceRuleTrait = "BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT"
	// The price rule supports bulk discounts.
	PriceRuleTraitBulk PriceRuleTrait = "BULK"
	// The price rule supports specific customers.
	PriceRuleTraitSpecificCustomers PriceRuleTrait = "SPECIFIC_CUSTOMERS"
	// The price rule supports quantity discounts.
	PriceRuleTraitQuantityDiscounts PriceRuleTrait = "QUANTITY_DISCOUNTS"
)

var AllPriceRuleTrait = []PriceRuleTrait{
	PriceRuleTraitBuyOneGetOne,
	PriceRuleTraitBuyOneGetOneWithAllocationLimit,
	PriceRuleTraitBulk,
	PriceRuleTraitSpecificCustomers,
	PriceRuleTraitQuantityDiscounts,
}

func (e PriceRuleTrait) IsValid() bool {
	switch e {
	case PriceRuleTraitBuyOneGetOne, PriceRuleTraitBuyOneGetOneWithAllocationLimit, PriceRuleTraitBulk, PriceRuleTraitSpecificCustomers, PriceRuleTraitQuantityDiscounts:
		return true
	}
	return false
}

func (e PriceRuleTrait) String() string {
	return string(e)
}

func (e *PriceRuleTrait) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceRuleTrait(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceRuleTrait", str)
	}
	return nil
}

func (e PriceRuleTrait) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Private Metafield value types.
type PrivateMetafieldValueType string

const (
	// A string metafield.
	PrivateMetafieldValueTypeString PrivateMetafieldValueType = "STRING"
	// An integer metafield.
	PrivateMetafieldValueTypeInteger PrivateMetafieldValueType = "INTEGER"
	// A JSON string metafield.
	PrivateMetafieldValueTypeJSONString PrivateMetafieldValueType = "JSON_STRING"
)

var AllPrivateMetafieldValueType = []PrivateMetafieldValueType{
	PrivateMetafieldValueTypeString,
	PrivateMetafieldValueTypeInteger,
	PrivateMetafieldValueTypeJSONString,
}

func (e PrivateMetafieldValueType) IsValid() bool {
	switch e {
	case PrivateMetafieldValueTypeString, PrivateMetafieldValueTypeInteger, PrivateMetafieldValueTypeJSONString:
		return true
	}
	return false
}

func (e PrivateMetafieldValueType) String() string {
	return string(e)
}

func (e *PrivateMetafieldValueType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrivateMetafieldValueType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrivateMetafieldValueType", str)
	}
	return nil
}

func (e PrivateMetafieldValueType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by ProductChangeStatusUserError.
type ProductChangeStatusUserErrorCode string

const (
	// Product could not be found.
	ProductChangeStatusUserErrorCodeProductNotFound ProductChangeStatusUserErrorCode = "PRODUCT_NOT_FOUND"
)

var AllProductChangeStatusUserErrorCode = []ProductChangeStatusUserErrorCode{
	ProductChangeStatusUserErrorCodeProductNotFound,
}

func (e ProductChangeStatusUserErrorCode) IsValid() bool {
	switch e {
	case ProductChangeStatusUserErrorCodeProductNotFound:
		return true
	}
	return false
}

func (e ProductChangeStatusUserErrorCode) String() string {
	return string(e)
}

func (e *ProductChangeStatusUserErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductChangeStatusUserErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductChangeStatusUserErrorCode", str)
	}
	return nil
}

func (e ProductChangeStatusUserErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProductCollection query.
type ProductCollectionSortKeys string

const (
	// Sort by the `title` value.
	ProductCollectionSortKeysTitle ProductCollectionSortKeys = "TITLE"
	// Sort by the `price` value.
	ProductCollectionSortKeysPrice ProductCollectionSortKeys = "PRICE"
	// Sort by the `best-selling` value.
	ProductCollectionSortKeysBestSelling ProductCollectionSortKeys = "BEST_SELLING"
	// Sort by the `created` value.
	ProductCollectionSortKeysCreated ProductCollectionSortKeys = "CREATED"
	// Sort by the `id` value.
	ProductCollectionSortKeysID ProductCollectionSortKeys = "ID"
	// Sort by the `manual` value.
	ProductCollectionSortKeysManual ProductCollectionSortKeys = "MANUAL"
	// Sort by the `collection-default` value.
	ProductCollectionSortKeysCollectionDefault ProductCollectionSortKeys = "COLLECTION_DEFAULT"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	ProductCollectionSortKeysRelevance ProductCollectionSortKeys = "RELEVANCE"
)

var AllProductCollectionSortKeys = []ProductCollectionSortKeys{
	ProductCollectionSortKeysTitle,
	ProductCollectionSortKeysPrice,
	ProductCollectionSortKeysBestSelling,
	ProductCollectionSortKeysCreated,
	ProductCollectionSortKeysID,
	ProductCollectionSortKeysManual,
	ProductCollectionSortKeysCollectionDefault,
	ProductCollectionSortKeysRelevance,
}

func (e ProductCollectionSortKeys) IsValid() bool {
	switch e {
	case ProductCollectionSortKeysTitle, ProductCollectionSortKeysPrice, ProductCollectionSortKeysBestSelling, ProductCollectionSortKeysCreated, ProductCollectionSortKeysID, ProductCollectionSortKeysManual, ProductCollectionSortKeysCollectionDefault, ProductCollectionSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductCollectionSortKeys) String() string {
	return string(e)
}

func (e *ProductCollectionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductCollectionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductCollectionSortKeys", str)
	}
	return nil
}

func (e ProductCollectionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProductImage query.
type ProductImageSortKeys string

const (
	// Sort by the `created_at` value.
	ProductImageSortKeysCreatedAt ProductImageSortKeys = "CREATED_AT"
	// Sort by the `position` value.
	ProductImageSortKeysPosition ProductImageSortKeys = "POSITION"
	// Sort by the `id` value.
	ProductImageSortKeysID ProductImageSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	ProductImageSortKeysRelevance ProductImageSortKeys = "RELEVANCE"
)

var AllProductImageSortKeys = []ProductImageSortKeys{
	ProductImageSortKeysCreatedAt,
	ProductImageSortKeysPosition,
	ProductImageSortKeysID,
	ProductImageSortKeysRelevance,
}

func (e ProductImageSortKeys) IsValid() bool {
	switch e {
	case ProductImageSortKeysCreatedAt, ProductImageSortKeysPosition, ProductImageSortKeysID, ProductImageSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductImageSortKeys) String() string {
	return string(e)
}

func (e *ProductImageSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductImageSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductImageSortKeys", str)
	}
	return nil
}

func (e ProductImageSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProductMedia query.
type ProductMediaSortKeys string

const (
	// Sort by the `position` value.
	ProductMediaSortKeysPosition ProductMediaSortKeys = "POSITION"
	// Sort by the `id` value.
	ProductMediaSortKeysID ProductMediaSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	ProductMediaSortKeysRelevance ProductMediaSortKeys = "RELEVANCE"
)

var AllProductMediaSortKeys = []ProductMediaSortKeys{
	ProductMediaSortKeysPosition,
	ProductMediaSortKeysID,
	ProductMediaSortKeysRelevance,
}

func (e ProductMediaSortKeys) IsValid() bool {
	switch e {
	case ProductMediaSortKeysPosition, ProductMediaSortKeysID, ProductMediaSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductMediaSortKeys) String() string {
	return string(e)
}

func (e *ProductMediaSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductMediaSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductMediaSortKeys", str)
	}
	return nil
}

func (e ProductMediaSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the Product query.
type ProductSortKeys string

const (
	// Sort by the `title` value.
	ProductSortKeysTitle ProductSortKeys = "TITLE"
	// Sort by the `product_type` value.
	ProductSortKeysProductType ProductSortKeys = "PRODUCT_TYPE"
	// Sort by the `vendor` value.
	ProductSortKeysVendor ProductSortKeys = "VENDOR"
	// Sort by the `inventory_total` value.
	ProductSortKeysInventoryTotal ProductSortKeys = "INVENTORY_TOTAL"
	// Sort by the `updated_at` value.
	ProductSortKeysUpdatedAt ProductSortKeys = "UPDATED_AT"
	// Sort by the `created_at` value.
	ProductSortKeysCreatedAt ProductSortKeys = "CREATED_AT"
	// Sort by the `published_at` value.
	ProductSortKeysPublishedAt ProductSortKeys = "PUBLISHED_AT"
	// Sort by the `id` value.
	ProductSortKeysID ProductSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	ProductSortKeysRelevance ProductSortKeys = "RELEVANCE"
)

var AllProductSortKeys = []ProductSortKeys{
	ProductSortKeysTitle,
	ProductSortKeysProductType,
	ProductSortKeysVendor,
	ProductSortKeysInventoryTotal,
	ProductSortKeysUpdatedAt,
	ProductSortKeysCreatedAt,
	ProductSortKeysPublishedAt,
	ProductSortKeysID,
	ProductSortKeysRelevance,
}

func (e ProductSortKeys) IsValid() bool {
	switch e {
	case ProductSortKeysTitle, ProductSortKeysProductType, ProductSortKeysVendor, ProductSortKeysInventoryTotal, ProductSortKeysUpdatedAt, ProductSortKeysCreatedAt, ProductSortKeysPublishedAt, ProductSortKeysID, ProductSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductSortKeys) String() string {
	return string(e)
}

func (e *ProductSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortKeys", str)
	}
	return nil
}

func (e ProductSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible product statuses.
type ProductStatus string

const (
	// The product is ready to sell and is available to customers on the online store, sales channels, and apps. By default, existing products are set to active.
	ProductStatusActive ProductStatus = "ACTIVE"
	// The product is no longer being sold and isn't available to customers on sales channels and apps.
	ProductStatusArchived ProductStatus = "ARCHIVED"
	// The product isn't ready to sell and is unavailable to customers on sales channels and apps. By default, duplicated and unarchived products are set to draft.
	ProductStatusDraft ProductStatus = "DRAFT"
)

var AllProductStatus = []ProductStatus{
	ProductStatusActive,
	ProductStatusArchived,
	ProductStatusDraft,
}

func (e ProductStatus) IsValid() bool {
	switch e {
	case ProductStatusActive, ProductStatusArchived, ProductStatusDraft:
		return true
	}
	return false
}

func (e ProductStatus) String() string {
	return string(e)
}

func (e *ProductStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductStatus", str)
	}
	return nil
}

func (e ProductStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The method of inventory tracking for a product variant.
type ProductVariantInventoryManagement string

const (
	// Shopify tracks this product variant's inventory.
	ProductVariantInventoryManagementShopify ProductVariantInventoryManagement = "SHOPIFY"
	// This product variant's inventory is not tracked.
	ProductVariantInventoryManagementNotManaged ProductVariantInventoryManagement = "NOT_MANAGED"
	// A third-party fulfillment service tracks this product variant's inventory.
	ProductVariantInventoryManagementFulfillmentService ProductVariantInventoryManagement = "FULFILLMENT_SERVICE"
)

var AllProductVariantInventoryManagement = []ProductVariantInventoryManagement{
	ProductVariantInventoryManagementShopify,
	ProductVariantInventoryManagementNotManaged,
	ProductVariantInventoryManagementFulfillmentService,
}

func (e ProductVariantInventoryManagement) IsValid() bool {
	switch e {
	case ProductVariantInventoryManagementShopify, ProductVariantInventoryManagementNotManaged, ProductVariantInventoryManagementFulfillmentService:
		return true
	}
	return false
}

func (e ProductVariantInventoryManagement) String() string {
	return string(e)
}

func (e *ProductVariantInventoryManagement) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductVariantInventoryManagement(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductVariantInventoryManagement", str)
	}
	return nil
}

func (e ProductVariantInventoryManagement) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The inventory policy for a product variant controls whether customers can continue to buy the variant when it
// is out of stock. When the value is <code>continue</code>, customers are able to buy the variant when it's out of stock.
// When the value is <code>deny</code>, customers can't buy the variant when it's out of stock.
//
type ProductVariantInventoryPolicy string

const (
	// Stop selling a product variant when it is out of stock.
	ProductVariantInventoryPolicyDeny ProductVariantInventoryPolicy = "DENY"
	// Continue selling a product variant when it is out of stock.
	ProductVariantInventoryPolicyContinue ProductVariantInventoryPolicy = "CONTINUE"
)

var AllProductVariantInventoryPolicy = []ProductVariantInventoryPolicy{
	ProductVariantInventoryPolicyDeny,
	ProductVariantInventoryPolicyContinue,
}

func (e ProductVariantInventoryPolicy) IsValid() bool {
	switch e {
	case ProductVariantInventoryPolicyDeny, ProductVariantInventoryPolicyContinue:
		return true
	}
	return false
}

func (e ProductVariantInventoryPolicy) String() string {
	return string(e)
}

func (e *ProductVariantInventoryPolicy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductVariantInventoryPolicy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductVariantInventoryPolicy", str)
	}
	return nil
}

func (e ProductVariantInventoryPolicy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProductVariant query.
type ProductVariantSortKeys string

const (
	// Sort by the `title` value.
	ProductVariantSortKeysTitle ProductVariantSortKeys = "TITLE"
	// Sort by the `name` value.
	ProductVariantSortKeysName ProductVariantSortKeys = "NAME"
	// Sort by the `sku` value.
	ProductVariantSortKeysSku ProductVariantSortKeys = "SKU"
	// Sort by the `inventory_quantity` value.
	ProductVariantSortKeysInventoryQuantity ProductVariantSortKeys = "INVENTORY_QUANTITY"
	// Sort by the `inventory_management` value.
	ProductVariantSortKeysInventoryManagement ProductVariantSortKeys = "INVENTORY_MANAGEMENT"
	// Sort by the `inventory_levels.available` value.
	ProductVariantSortKeysInventoryLevelsAvailable ProductVariantSortKeys = "INVENTORY_LEVELS_AVAILABLE"
	// Sort by the `inventory_policy` value.
	ProductVariantSortKeysInventoryPolicy ProductVariantSortKeys = "INVENTORY_POLICY"
	// Sort by the `full_title` value.
	ProductVariantSortKeysFullTitle ProductVariantSortKeys = "FULL_TITLE"
	// Sort by the `popular` value.
	ProductVariantSortKeysPopular ProductVariantSortKeys = "POPULAR"
	// Sort by the `position` value.
	ProductVariantSortKeysPosition ProductVariantSortKeys = "POSITION"
	// Sort by the `id` value.
	ProductVariantSortKeysID ProductVariantSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	ProductVariantSortKeysRelevance ProductVariantSortKeys = "RELEVANCE"
)

var AllProductVariantSortKeys = []ProductVariantSortKeys{
	ProductVariantSortKeysTitle,
	ProductVariantSortKeysName,
	ProductVariantSortKeysSku,
	ProductVariantSortKeysInventoryQuantity,
	ProductVariantSortKeysInventoryManagement,
	ProductVariantSortKeysInventoryLevelsAvailable,
	ProductVariantSortKeysInventoryPolicy,
	ProductVariantSortKeysFullTitle,
	ProductVariantSortKeysPopular,
	ProductVariantSortKeysPosition,
	ProductVariantSortKeysID,
	ProductVariantSortKeysRelevance,
}

func (e ProductVariantSortKeys) IsValid() bool {
	switch e {
	case ProductVariantSortKeysTitle, ProductVariantSortKeysName, ProductVariantSortKeysSku, ProductVariantSortKeysInventoryQuantity, ProductVariantSortKeysInventoryManagement, ProductVariantSortKeysInventoryLevelsAvailable, ProductVariantSortKeysInventoryPolicy, ProductVariantSortKeysFullTitle, ProductVariantSortKeysPopular, ProductVariantSortKeysPosition, ProductVariantSortKeysID, ProductVariantSortKeysRelevance:
		return true
	}
	return false
}

func (e ProductVariantSortKeys) String() string {
	return string(e)
}

func (e *ProductVariantSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductVariantSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductVariantSortKeys", str)
	}
	return nil
}

func (e ProductVariantSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ProfileItem query.
type ProfileItemSortKeys string

const (
	// Sort by the `title` value.
	ProfileItemSortKeysTitle ProfileItemSortKeys = "TITLE"
	// Sort by the `product_type` value.
	ProfileItemSortKeysProductType ProfileItemSortKeys = "PRODUCT_TYPE"
	// Sort by the `vendor` value.
	ProfileItemSortKeysVendor ProfileItemSortKeys = "VENDOR"
	// Sort by the `inventory_total` value.
	ProfileItemSortKeysInventoryTotal ProfileItemSortKeys = "INVENTORY_TOTAL"
	// Sort by the `updated_at` value.
	ProfileItemSortKeysUpdatedAt ProfileItemSortKeys = "UPDATED_AT"
	// Sort by the `created_at` value.
	ProfileItemSortKeysCreatedAt ProfileItemSortKeys = "CREATED_AT"
	// Sort by the `published_at` value.
	ProfileItemSortKeysPublishedAt ProfileItemSortKeys = "PUBLISHED_AT"
	// Sort by the `id` value.
	ProfileItemSortKeysID ProfileItemSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	ProfileItemSortKeysRelevance ProfileItemSortKeys = "RELEVANCE"
)

var AllProfileItemSortKeys = []ProfileItemSortKeys{
	ProfileItemSortKeysTitle,
	ProfileItemSortKeysProductType,
	ProfileItemSortKeysVendor,
	ProfileItemSortKeysInventoryTotal,
	ProfileItemSortKeysUpdatedAt,
	ProfileItemSortKeysCreatedAt,
	ProfileItemSortKeysPublishedAt,
	ProfileItemSortKeysID,
	ProfileItemSortKeysRelevance,
}

func (e ProfileItemSortKeys) IsValid() bool {
	switch e {
	case ProfileItemSortKeysTitle, ProfileItemSortKeysProductType, ProfileItemSortKeysVendor, ProfileItemSortKeysInventoryTotal, ProfileItemSortKeysUpdatedAt, ProfileItemSortKeysCreatedAt, ProfileItemSortKeysPublishedAt, ProfileItemSortKeysID, ProfileItemSortKeysRelevance:
		return true
	}
	return false
}

func (e ProfileItemSortKeys) String() string {
	return string(e)
}

func (e *ProfileItemSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProfileItemSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProfileItemSortKeys", str)
	}
	return nil
}

func (e ProfileItemSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of refund to perform for a particular refund duty.
type RefundDutyRefundType string

const (
	// The duty is proportionally refunded based on the quantity of the refunded line item.
	RefundDutyRefundTypeProportional RefundDutyRefundType = "PROPORTIONAL"
	// The duty is fully refunded.
	RefundDutyRefundTypeFull RefundDutyRefundType = "FULL"
)

var AllRefundDutyRefundType = []RefundDutyRefundType{
	RefundDutyRefundTypeProportional,
	RefundDutyRefundTypeFull,
}

func (e RefundDutyRefundType) IsValid() bool {
	switch e {
	case RefundDutyRefundTypeProportional, RefundDutyRefundTypeFull:
		return true
	}
	return false
}

func (e RefundDutyRefundType) String() string {
	return string(e)
}

func (e *RefundDutyRefundType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RefundDutyRefundType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RefundDutyRefundType", str)
	}
	return nil
}

func (e RefundDutyRefundType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of restock performed for a particular refund line item.
type RefundLineItemRestockType string

const (
	// Refund line item was returned.
	RefundLineItemRestockTypeReturn RefundLineItemRestockType = "RETURN"
	// Refund line item was canceled.
	RefundLineItemRestockTypeCancel RefundLineItemRestockType = "CANCEL"
	// Refund line item was restocked, without specifically being identified as a return or cancelation.
	RefundLineItemRestockTypeLegacyRestock RefundLineItemRestockType = "LEGACY_RESTOCK"
	// Refund line item was not restocked.
	RefundLineItemRestockTypeNoRestock RefundLineItemRestockType = "NO_RESTOCK"
)

var AllRefundLineItemRestockType = []RefundLineItemRestockType{
	RefundLineItemRestockTypeReturn,
	RefundLineItemRestockTypeCancel,
	RefundLineItemRestockTypeLegacyRestock,
	RefundLineItemRestockTypeNoRestock,
}

func (e RefundLineItemRestockType) IsValid() bool {
	switch e {
	case RefundLineItemRestockTypeReturn, RefundLineItemRestockTypeCancel, RefundLineItemRestockTypeLegacyRestock, RefundLineItemRestockTypeNoRestock:
		return true
	}
	return false
}

func (e RefundLineItemRestockType) String() string {
	return string(e)
}

func (e *RefundLineItemRestockType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RefundLineItemRestockType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RefundLineItemRestockType", str)
	}
	return nil
}

func (e RefundLineItemRestockType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The available icons for resource alerts.
type ResourceAlertIcon string

const (
	// A checkmark inside a circle.
	ResourceAlertIconCheckmarkCircle ResourceAlertIcon = "CHECKMARK_CIRCLE"
	// A lowercase `i` inside a circle.
	ResourceAlertIconInformationCircle ResourceAlertIcon = "INFORMATION_CIRCLE"
)

var AllResourceAlertIcon = []ResourceAlertIcon{
	ResourceAlertIconCheckmarkCircle,
	ResourceAlertIconInformationCircle,
}

func (e ResourceAlertIcon) IsValid() bool {
	switch e {
	case ResourceAlertIconCheckmarkCircle, ResourceAlertIconInformationCircle:
		return true
	}
	return false
}

func (e ResourceAlertIcon) String() string {
	return string(e)
}

func (e *ResourceAlertIcon) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAlertIcon(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAlertIcon", str)
	}
	return nil
}

func (e ResourceAlertIcon) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible severity levels for a resource alert.
type ResourceAlertSeverity string

const (
	// Indicates a neutral alert.
	ResourceAlertSeverityDefault ResourceAlertSeverity = "DEFAULT"
	// Indicates an informative alert.
	ResourceAlertSeverityInfo ResourceAlertSeverity = "INFO"
	// Indicates a warning alert.
	ResourceAlertSeverityWarning ResourceAlertSeverity = "WARNING"
	// Indicates a success alert.
	ResourceAlertSeveritySuccess ResourceAlertSeverity = "SUCCESS"
	// Indicates a critical alert.
	ResourceAlertSeverityCritical ResourceAlertSeverity = "CRITICAL"
	ResourceAlertSeverityError    ResourceAlertSeverity = "ERROR"
)

var AllResourceAlertSeverity = []ResourceAlertSeverity{
	ResourceAlertSeverityDefault,
	ResourceAlertSeverityInfo,
	ResourceAlertSeverityWarning,
	ResourceAlertSeveritySuccess,
	ResourceAlertSeverityCritical,
	ResourceAlertSeverityError,
}

func (e ResourceAlertSeverity) IsValid() bool {
	switch e {
	case ResourceAlertSeverityDefault, ResourceAlertSeverityInfo, ResourceAlertSeverityWarning, ResourceAlertSeveritySuccess, ResourceAlertSeverityCritical, ResourceAlertSeverityError:
		return true
	}
	return false
}

func (e ResourceAlertSeverity) String() string {
	return string(e)
}

func (e *ResourceAlertSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceAlertSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceAlertSeverity", str)
	}
	return nil
}

func (e ResourceAlertSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The page or pages on the online store where the script should be included.
//
type ScriptTagDisplayScope string

const (
	// Include the script on both the web storefront and the order status page.
	ScriptTagDisplayScopeAll ScriptTagDisplayScope = "ALL"
	// Include the script only on the order status page.
	ScriptTagDisplayScopeOrderStatus ScriptTagDisplayScope = "ORDER_STATUS"
	// Include the script only on the web storefront.
	ScriptTagDisplayScopeOnlineStore ScriptTagDisplayScope = "ONLINE_STORE"
)

var AllScriptTagDisplayScope = []ScriptTagDisplayScope{
	ScriptTagDisplayScopeAll,
	ScriptTagDisplayScopeOrderStatus,
	ScriptTagDisplayScopeOnlineStore,
}

func (e ScriptTagDisplayScope) IsValid() bool {
	switch e {
	case ScriptTagDisplayScopeAll, ScriptTagDisplayScopeOrderStatus, ScriptTagDisplayScopeOnlineStore:
		return true
	}
	return false
}

func (e ScriptTagDisplayScope) String() string {
	return string(e)
}

func (e *ScriptTagDisplayScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScriptTagDisplayScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScriptTagDisplayScope", str)
	}
	return nil
}

func (e ScriptTagDisplayScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the type of resources to be returned from a search.
type SearchResultType string

const (
	SearchResultTypeOrder              SearchResultType = "ORDER"
	SearchResultTypeCustomer           SearchResultType = "CUSTOMER"
	SearchResultTypeProduct            SearchResultType = "PRODUCT"
	SearchResultTypeOnlineStorePage    SearchResultType = "ONLINE_STORE_PAGE"
	SearchResultTypeOnlineStoreBlog    SearchResultType = "ONLINE_STORE_BLOG"
	SearchResultTypeOnlineStoreArticle SearchResultType = "ONLINE_STORE_ARTICLE"
	SearchResultTypeCollection         SearchResultType = "COLLECTION"
	SearchResultTypeDraftOrder         SearchResultType = "DRAFT_ORDER"
	SearchResultTypePriceRule          SearchResultType = "PRICE_RULE"
	// A code discount redeem code.
	SearchResultTypeDiscountRedeemCode SearchResultType = "DISCOUNT_REDEEM_CODE"
)

var AllSearchResultType = []SearchResultType{
	SearchResultTypeOrder,
	SearchResultTypeCustomer,
	SearchResultTypeProduct,
	SearchResultTypeOnlineStorePage,
	SearchResultTypeOnlineStoreBlog,
	SearchResultTypeOnlineStoreArticle,
	SearchResultTypeCollection,
	SearchResultTypeDraftOrder,
	SearchResultTypePriceRule,
	SearchResultTypeDiscountRedeemCode,
}

func (e SearchResultType) IsValid() bool {
	switch e {
	case SearchResultTypeOrder, SearchResultTypeCustomer, SearchResultTypeProduct, SearchResultTypeOnlineStorePage, SearchResultTypeOnlineStoreBlog, SearchResultTypeOnlineStoreArticle, SearchResultTypeCollection, SearchResultTypeDraftOrder, SearchResultTypePriceRule, SearchResultTypeDiscountRedeemCode:
		return true
	}
	return false
}

func (e SearchResultType) String() string {
	return string(e)
}

func (e *SearchResultType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SearchResultType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SearchResultType", str)
	}
	return nil
}

func (e SearchResultType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible branding of a shop.
// Branding can be used to define the look of a shop including its styling and logo in the Shopify Admin.
//
type ShopBranding string

const (
	// Shop has Shopify Gold branding.
	ShopBrandingShopifyGold ShopBranding = "SHOPIFY_GOLD"
	// Shop has Shopify Plus branding.
	ShopBrandingShopifyPlus ShopBranding = "SHOPIFY_PLUS"
	// Shop has Rogers branding.
	ShopBrandingRogers ShopBranding = "ROGERS"
	// Shop has Shopify branding.
	ShopBrandingShopify ShopBranding = "SHOPIFY"
)

var AllShopBranding = []ShopBranding{
	ShopBrandingShopifyGold,
	ShopBrandingShopifyPlus,
	ShopBrandingRogers,
	ShopBrandingShopify,
}

func (e ShopBranding) IsValid() bool {
	switch e {
	case ShopBrandingShopifyGold, ShopBrandingShopifyPlus, ShopBrandingRogers, ShopBrandingShopify:
		return true
	}
	return false
}

func (e ShopBranding) String() string {
	return string(e)
}

func (e *ShopBranding) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopBranding(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopBranding", str)
	}
	return nil
}

func (e ShopBranding) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the shop's customer account requirement preference.
//
type ShopCustomerAccountsSetting string

const (
	ShopCustomerAccountsSettingRequired ShopCustomerAccountsSetting = "REQUIRED"
	ShopCustomerAccountsSettingOptional ShopCustomerAccountsSetting = "OPTIONAL"
	ShopCustomerAccountsSettingDisabled ShopCustomerAccountsSetting = "DISABLED"
)

var AllShopCustomerAccountsSetting = []ShopCustomerAccountsSetting{
	ShopCustomerAccountsSettingRequired,
	ShopCustomerAccountsSettingOptional,
	ShopCustomerAccountsSettingDisabled,
}

func (e ShopCustomerAccountsSetting) IsValid() bool {
	switch e {
	case ShopCustomerAccountsSettingRequired, ShopCustomerAccountsSettingOptional, ShopCustomerAccountsSettingDisabled:
		return true
	}
	return false
}

func (e ShopCustomerAccountsSetting) String() string {
	return string(e)
}

func (e *ShopCustomerAccountsSetting) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopCustomerAccountsSetting(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopCustomerAccountsSetting", str)
	}
	return nil
}

func (e ShopCustomerAccountsSetting) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the ShopImage query.
type ShopImageSortKeys string

const (
	// Sort by the `created_at` value.
	ShopImageSortKeysCreatedAt ShopImageSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	ShopImageSortKeysID ShopImageSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	ShopImageSortKeysRelevance ShopImageSortKeys = "RELEVANCE"
)

var AllShopImageSortKeys = []ShopImageSortKeys{
	ShopImageSortKeysCreatedAt,
	ShopImageSortKeysID,
	ShopImageSortKeysRelevance,
}

func (e ShopImageSortKeys) IsValid() bool {
	switch e {
	case ShopImageSortKeysCreatedAt, ShopImageSortKeysID, ShopImageSortKeysRelevance:
		return true
	}
	return false
}

func (e ShopImageSortKeys) String() string {
	return string(e)
}

func (e *ShopImageSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopImageSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopImageSortKeys", str)
	}
	return nil
}

func (e ShopImageSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by ShopPolicyUserError.
type ShopPolicyErrorCode string

const (
	// Input value is too big.
	ShopPolicyErrorCodeTooBig ShopPolicyErrorCode = "TOO_BIG"
)

var AllShopPolicyErrorCode = []ShopPolicyErrorCode{
	ShopPolicyErrorCodeTooBig,
}

func (e ShopPolicyErrorCode) IsValid() bool {
	switch e {
	case ShopPolicyErrorCodeTooBig:
		return true
	}
	return false
}

func (e ShopPolicyErrorCode) String() string {
	return string(e)
}

func (e *ShopPolicyErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopPolicyErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopPolicyErrorCode", str)
	}
	return nil
}

func (e ShopPolicyErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Available shop policy types.
type ShopPolicyType string

const (
	// The Refund policy.
	ShopPolicyTypeRefundPolicy ShopPolicyType = "REFUND_POLICY"
	// The Shipping policy.
	ShopPolicyTypeShippingPolicy ShopPolicyType = "SHIPPING_POLICY"
	// The Privacy policy.
	ShopPolicyTypePrivacyPolicy ShopPolicyType = "PRIVACY_POLICY"
	// The Terms of service.
	ShopPolicyTypeTermsOfService ShopPolicyType = "TERMS_OF_SERVICE"
	// The Terms of sale.
	ShopPolicyTypeTermsOfSale ShopPolicyType = "TERMS_OF_SALE"
	// The Legal notice.
	ShopPolicyTypeLegalNotice ShopPolicyType = "LEGAL_NOTICE"
)

var AllShopPolicyType = []ShopPolicyType{
	ShopPolicyTypeRefundPolicy,
	ShopPolicyTypeShippingPolicy,
	ShopPolicyTypePrivacyPolicy,
	ShopPolicyTypeTermsOfService,
	ShopPolicyTypeTermsOfSale,
	ShopPolicyTypeLegalNotice,
}

func (e ShopPolicyType) IsValid() bool {
	switch e {
	case ShopPolicyTypeRefundPolicy, ShopPolicyTypeShippingPolicy, ShopPolicyTypePrivacyPolicy, ShopPolicyTypeTermsOfService, ShopPolicyTypeTermsOfSale, ShopPolicyTypeLegalNotice:
		return true
	}
	return false
}

func (e ShopPolicyType) String() string {
	return string(e)
}

func (e *ShopPolicyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopPolicyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopPolicyType", str)
	}
	return nil
}

func (e ShopPolicyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible sort of tags.
type ShopTagSort string

const (
	// Alphabetical sort.
	ShopTagSortAlphabetical ShopTagSort = "ALPHABETICAL"
	// Popularity sort.
	ShopTagSortPopular ShopTagSort = "POPULAR"
)

var AllShopTagSort = []ShopTagSort{
	ShopTagSortAlphabetical,
	ShopTagSortPopular,
}

func (e ShopTagSort) IsValid() bool {
	switch e {
	case ShopTagSortAlphabetical, ShopTagSortPopular:
		return true
	}
	return false
}

func (e ShopTagSort) String() string {
	return string(e)
}

func (e *ShopTagSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopTagSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopTagSort", str)
	}
	return nil
}

func (e ShopTagSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The bank account status.
type ShopifyPaymentsBankAccountStatus string

const (
	// A bank account that hasn't had any activity and that's not validated.
	ShopifyPaymentsBankAccountStatusNew ShopifyPaymentsBankAccountStatus = "NEW"
	// It was determined that the bank account exists.
	ShopifyPaymentsBankAccountStatusValidated ShopifyPaymentsBankAccountStatus = "VALIDATED"
	// Bank account validation was successful.
	ShopifyPaymentsBankAccountStatusVerified ShopifyPaymentsBankAccountStatus = "VERIFIED"
	// A payout to the bank account failed.
	ShopifyPaymentsBankAccountStatusErrored ShopifyPaymentsBankAccountStatus = "ERRORED"
)

var AllShopifyPaymentsBankAccountStatus = []ShopifyPaymentsBankAccountStatus{
	ShopifyPaymentsBankAccountStatusNew,
	ShopifyPaymentsBankAccountStatusValidated,
	ShopifyPaymentsBankAccountStatusVerified,
	ShopifyPaymentsBankAccountStatusErrored,
}

func (e ShopifyPaymentsBankAccountStatus) IsValid() bool {
	switch e {
	case ShopifyPaymentsBankAccountStatusNew, ShopifyPaymentsBankAccountStatusValidated, ShopifyPaymentsBankAccountStatusVerified, ShopifyPaymentsBankAccountStatusErrored:
		return true
	}
	return false
}

func (e ShopifyPaymentsBankAccountStatus) String() string {
	return string(e)
}

func (e *ShopifyPaymentsBankAccountStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopifyPaymentsBankAccountStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopifyPaymentsBankAccountStatus", str)
	}
	return nil
}

func (e ShopifyPaymentsBankAccountStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The reason for the dispute provided by the cardholder's bank.
type ShopifyPaymentsDisputeReason string

const (
	// The cardholder claims that they didn’t authorize the payment.
	ShopifyPaymentsDisputeReasonFraudulent ShopifyPaymentsDisputeReason = "FRAUDULENT"
	// The dispute is uncategorized, so you should contact the customer for additional details to find out why the payment was disputed.
	ShopifyPaymentsDisputeReasonGeneral ShopifyPaymentsDisputeReason = "GENERAL"
	// The customer doesn’t recognize the payment appearing on their card statement.
	ShopifyPaymentsDisputeReasonUnrecognized ShopifyPaymentsDisputeReason = "UNRECOGNIZED"
	// The customer claims they were charged multiple times for the same product or service.
	ShopifyPaymentsDisputeReasonDuplicate ShopifyPaymentsDisputeReason = "DUPLICATE"
	// The customer claims that you continued to charge them after a subscription was canceled.
	ShopifyPaymentsDisputeReasonSubscriptionCancelled ShopifyPaymentsDisputeReason = "SUBSCRIPTION_CANCELLED"
	// The product or service was received but was defective, damaged, or not as described.
	ShopifyPaymentsDisputeReasonProductUnacceptable ShopifyPaymentsDisputeReason = "PRODUCT_UNACCEPTABLE"
	// The customer claims they did not receive the products or services purchased.
	ShopifyPaymentsDisputeReasonProductNotReceived ShopifyPaymentsDisputeReason = "PRODUCT_NOT_RECEIVED"
	// The customer claims that the purchased product was returned or the transaction was otherwise canceled, but you have not yet provided a refund or credit.
	ShopifyPaymentsDisputeReasonCreditNotProcessed ShopifyPaymentsDisputeReason = "CREDIT_NOT_PROCESSED"
	// The customer account associated with the purchase is incorrect.
	ShopifyPaymentsDisputeReasonIncorrectAccountDetails ShopifyPaymentsDisputeReason = "INCORRECT_ACCOUNT_DETAILS"
	// The customer's bank account has insufficient funds.
	ShopifyPaymentsDisputeReasonInsufficientFunds ShopifyPaymentsDisputeReason = "INSUFFICIENT_FUNDS"
	// The customer's bank cannot process the charge.
	ShopifyPaymentsDisputeReasonBankCannotProcess ShopifyPaymentsDisputeReason = "BANK_CANNOT_PROCESS"
	// The customer's bank cannot proceed with the debit since it has not been authorized.
	ShopifyPaymentsDisputeReasonDebitNotAuthorized ShopifyPaymentsDisputeReason = "DEBIT_NOT_AUTHORIZED"
	// The customer initiated the dispute, so you should contact the customer for additional details to find out why the payment was disputed.
	ShopifyPaymentsDisputeReasonCustomerInitiated ShopifyPaymentsDisputeReason = "CUSTOMER_INITIATED"
)

var AllShopifyPaymentsDisputeReason = []ShopifyPaymentsDisputeReason{
	ShopifyPaymentsDisputeReasonFraudulent,
	ShopifyPaymentsDisputeReasonGeneral,
	ShopifyPaymentsDisputeReasonUnrecognized,
	ShopifyPaymentsDisputeReasonDuplicate,
	ShopifyPaymentsDisputeReasonSubscriptionCancelled,
	ShopifyPaymentsDisputeReasonProductUnacceptable,
	ShopifyPaymentsDisputeReasonProductNotReceived,
	ShopifyPaymentsDisputeReasonCreditNotProcessed,
	ShopifyPaymentsDisputeReasonIncorrectAccountDetails,
	ShopifyPaymentsDisputeReasonInsufficientFunds,
	ShopifyPaymentsDisputeReasonBankCannotProcess,
	ShopifyPaymentsDisputeReasonDebitNotAuthorized,
	ShopifyPaymentsDisputeReasonCustomerInitiated,
}

func (e ShopifyPaymentsDisputeReason) IsValid() bool {
	switch e {
	case ShopifyPaymentsDisputeReasonFraudulent, ShopifyPaymentsDisputeReasonGeneral, ShopifyPaymentsDisputeReasonUnrecognized, ShopifyPaymentsDisputeReasonDuplicate, ShopifyPaymentsDisputeReasonSubscriptionCancelled, ShopifyPaymentsDisputeReasonProductUnacceptable, ShopifyPaymentsDisputeReasonProductNotReceived, ShopifyPaymentsDisputeReasonCreditNotProcessed, ShopifyPaymentsDisputeReasonIncorrectAccountDetails, ShopifyPaymentsDisputeReasonInsufficientFunds, ShopifyPaymentsDisputeReasonBankCannotProcess, ShopifyPaymentsDisputeReasonDebitNotAuthorized, ShopifyPaymentsDisputeReasonCustomerInitiated:
		return true
	}
	return false
}

func (e ShopifyPaymentsDisputeReason) String() string {
	return string(e)
}

func (e *ShopifyPaymentsDisputeReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopifyPaymentsDisputeReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopifyPaymentsDisputeReason", str)
	}
	return nil
}

func (e ShopifyPaymentsDisputeReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The interval at which payouts are sent to the connected bank account.
type ShopifyPaymentsPayoutInterval string

const (
	// Each business day.
	ShopifyPaymentsPayoutIntervalDaily ShopifyPaymentsPayoutInterval = "DAILY"
	// Each week, on the day of week specified by weeklyAnchor.
	ShopifyPaymentsPayoutIntervalWeekly ShopifyPaymentsPayoutInterval = "WEEKLY"
	// Each month, on the day of month specified by monthlyAnchor.
	ShopifyPaymentsPayoutIntervalMonthly ShopifyPaymentsPayoutInterval = "MONTHLY"
	// Payouts will not be automatically made.
	ShopifyPaymentsPayoutIntervalManual ShopifyPaymentsPayoutInterval = "MANUAL"
)

var AllShopifyPaymentsPayoutInterval = []ShopifyPaymentsPayoutInterval{
	ShopifyPaymentsPayoutIntervalDaily,
	ShopifyPaymentsPayoutIntervalWeekly,
	ShopifyPaymentsPayoutIntervalMonthly,
	ShopifyPaymentsPayoutIntervalManual,
}

func (e ShopifyPaymentsPayoutInterval) IsValid() bool {
	switch e {
	case ShopifyPaymentsPayoutIntervalDaily, ShopifyPaymentsPayoutIntervalWeekly, ShopifyPaymentsPayoutIntervalMonthly, ShopifyPaymentsPayoutIntervalManual:
		return true
	}
	return false
}

func (e ShopifyPaymentsPayoutInterval) String() string {
	return string(e)
}

func (e *ShopifyPaymentsPayoutInterval) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopifyPaymentsPayoutInterval(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopifyPaymentsPayoutInterval", str)
	}
	return nil
}

func (e ShopifyPaymentsPayoutInterval) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The transfer status of the payout.
type ShopifyPaymentsPayoutStatus string

const (
	// The payout has been created and had transactions assigned to it, but
	// it has not yet been submitted to the bank.
	//
	ShopifyPaymentsPayoutStatusScheduled ShopifyPaymentsPayoutStatus = "SCHEDULED"
	// The payout has been submitted to the bank.
	ShopifyPaymentsPayoutStatusInTransit ShopifyPaymentsPayoutStatus = "IN_TRANSIT"
	// The payout has been successfully deposited into the bank.
	ShopifyPaymentsPayoutStatusPaid ShopifyPaymentsPayoutStatus = "PAID"
	// The payout has been declined by the bank.
	ShopifyPaymentsPayoutStatusFailed ShopifyPaymentsPayoutStatus = "FAILED"
	// The payout has been canceled by Shopify.
	ShopifyPaymentsPayoutStatusCanceled ShopifyPaymentsPayoutStatus = "CANCELED"
)

var AllShopifyPaymentsPayoutStatus = []ShopifyPaymentsPayoutStatus{
	ShopifyPaymentsPayoutStatusScheduled,
	ShopifyPaymentsPayoutStatusInTransit,
	ShopifyPaymentsPayoutStatusPaid,
	ShopifyPaymentsPayoutStatusFailed,
	ShopifyPaymentsPayoutStatusCanceled,
}

func (e ShopifyPaymentsPayoutStatus) IsValid() bool {
	switch e {
	case ShopifyPaymentsPayoutStatusScheduled, ShopifyPaymentsPayoutStatusInTransit, ShopifyPaymentsPayoutStatusPaid, ShopifyPaymentsPayoutStatusFailed, ShopifyPaymentsPayoutStatusCanceled:
		return true
	}
	return false
}

func (e ShopifyPaymentsPayoutStatus) String() string {
	return string(e)
}

func (e *ShopifyPaymentsPayoutStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopifyPaymentsPayoutStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopifyPaymentsPayoutStatus", str)
	}
	return nil
}

func (e ShopifyPaymentsPayoutStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The possible transaction types for a payout.
type ShopifyPaymentsPayoutTransactionType string

const (
	// The payout is a deposit.
	ShopifyPaymentsPayoutTransactionTypeDeposit ShopifyPaymentsPayoutTransactionType = "DEPOSIT"
	// The payout is a withdrawal.
	ShopifyPaymentsPayoutTransactionTypeWithdrawal ShopifyPaymentsPayoutTransactionType = "WITHDRAWAL"
)

var AllShopifyPaymentsPayoutTransactionType = []ShopifyPaymentsPayoutTransactionType{
	ShopifyPaymentsPayoutTransactionTypeDeposit,
	ShopifyPaymentsPayoutTransactionTypeWithdrawal,
}

func (e ShopifyPaymentsPayoutTransactionType) IsValid() bool {
	switch e {
	case ShopifyPaymentsPayoutTransactionTypeDeposit, ShopifyPaymentsPayoutTransactionTypeWithdrawal:
		return true
	}
	return false
}

func (e ShopifyPaymentsPayoutTransactionType) String() string {
	return string(e)
}

func (e *ShopifyPaymentsPayoutTransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopifyPaymentsPayoutTransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopifyPaymentsPayoutTransactionType", str)
	}
	return nil
}

func (e ShopifyPaymentsPayoutTransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types of possible verification documents.
type ShopifyPaymentsVerificationDocumentType string

const (
	// The subject's driver's license.
	ShopifyPaymentsVerificationDocumentTypeDriversLicense ShopifyPaymentsVerificationDocumentType = "DRIVERS_LICENSE"
	// A government's identification document of the subject.
	ShopifyPaymentsVerificationDocumentTypeGovernmentIDEntification ShopifyPaymentsVerificationDocumentType = "GOVERNMENT_IDENTIFICATION"
	// The subject's passport.
	ShopifyPaymentsVerificationDocumentTypePassport ShopifyPaymentsVerificationDocumentType = "PASSPORT"
)

var AllShopifyPaymentsVerificationDocumentType = []ShopifyPaymentsVerificationDocumentType{
	ShopifyPaymentsVerificationDocumentTypeDriversLicense,
	ShopifyPaymentsVerificationDocumentTypeGovernmentIDEntification,
	ShopifyPaymentsVerificationDocumentTypePassport,
}

func (e ShopifyPaymentsVerificationDocumentType) IsValid() bool {
	switch e {
	case ShopifyPaymentsVerificationDocumentTypeDriversLicense, ShopifyPaymentsVerificationDocumentTypeGovernmentIDEntification, ShopifyPaymentsVerificationDocumentTypePassport:
		return true
	}
	return false
}

func (e ShopifyPaymentsVerificationDocumentType) String() string {
	return string(e)
}

func (e *ShopifyPaymentsVerificationDocumentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopifyPaymentsVerificationDocumentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopifyPaymentsVerificationDocumentType", str)
	}
	return nil
}

func (e ShopifyPaymentsVerificationDocumentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The status of a verification.
type ShopifyPaymentsVerificationStatus string

const (
	// The verification has been verified.
	ShopifyPaymentsVerificationStatusVerified ShopifyPaymentsVerificationStatus = "VERIFIED"
	// The verification has not yet been verified.
	ShopifyPaymentsVerificationStatusUnverified ShopifyPaymentsVerificationStatus = "UNVERIFIED"
	// The verification request has been submitted but a response has not yet been given.
	ShopifyPaymentsVerificationStatusPending ShopifyPaymentsVerificationStatus = "PENDING"
)

var AllShopifyPaymentsVerificationStatus = []ShopifyPaymentsVerificationStatus{
	ShopifyPaymentsVerificationStatusVerified,
	ShopifyPaymentsVerificationStatusUnverified,
	ShopifyPaymentsVerificationStatusPending,
}

func (e ShopifyPaymentsVerificationStatus) IsValid() bool {
	switch e {
	case ShopifyPaymentsVerificationStatusVerified, ShopifyPaymentsVerificationStatusUnverified, ShopifyPaymentsVerificationStatusPending:
		return true
	}
	return false
}

func (e ShopifyPaymentsVerificationStatus) String() string {
	return string(e)
}

func (e *ShopifyPaymentsVerificationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShopifyPaymentsVerificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShopifyPaymentsVerificationStatus", str)
	}
	return nil
}

func (e ShopifyPaymentsVerificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible HTTP method of a staged upload target.
type StagedUploadHTTPMethodType string

const (
	// The POST HTTP method.
	StagedUploadHTTPMethodTypePost StagedUploadHTTPMethodType = "POST"
	// The PUT HTTP method.
	StagedUploadHTTPMethodTypePut StagedUploadHTTPMethodType = "PUT"
)

var AllStagedUploadHTTPMethodType = []StagedUploadHTTPMethodType{
	StagedUploadHTTPMethodTypePost,
	StagedUploadHTTPMethodTypePut,
}

func (e StagedUploadHTTPMethodType) IsValid() bool {
	switch e {
	case StagedUploadHTTPMethodTypePost, StagedUploadHTTPMethodTypePut:
		return true
	}
	return false
}

func (e StagedUploadHTTPMethodType) String() string {
	return string(e)
}

func (e *StagedUploadHTTPMethodType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StagedUploadHTTPMethodType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StagedUploadHttpMethodType", str)
	}
	return nil
}

func (e StagedUploadHTTPMethodType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the resource type to receive.
type StagedUploadTargetGenerateUploadResource string

const (
	// A timeline event.
	StagedUploadTargetGenerateUploadResourceTimeline StagedUploadTargetGenerateUploadResource = "TIMELINE"
	// A product image.
	StagedUploadTargetGenerateUploadResourceProductImage StagedUploadTargetGenerateUploadResource = "PRODUCT_IMAGE"
	// A collection image.
	StagedUploadTargetGenerateUploadResourceCollectionImage StagedUploadTargetGenerateUploadResource = "COLLECTION_IMAGE"
	// A shop image.
	StagedUploadTargetGenerateUploadResourceShopImage StagedUploadTargetGenerateUploadResource = "SHOP_IMAGE"
	// Merchandising::Video resource representation.
	StagedUploadTargetGenerateUploadResourceVideo StagedUploadTargetGenerateUploadResource = "VIDEO"
	// Merchandising::Model3d resource representation.
	StagedUploadTargetGenerateUploadResourceModel3d StagedUploadTargetGenerateUploadResource = "MODEL_3D"
	// Merchandising::Image resource representation.
	StagedUploadTargetGenerateUploadResourceImage StagedUploadTargetGenerateUploadResource = "IMAGE"
)

var AllStagedUploadTargetGenerateUploadResource = []StagedUploadTargetGenerateUploadResource{
	StagedUploadTargetGenerateUploadResourceTimeline,
	StagedUploadTargetGenerateUploadResourceProductImage,
	StagedUploadTargetGenerateUploadResourceCollectionImage,
	StagedUploadTargetGenerateUploadResourceShopImage,
	StagedUploadTargetGenerateUploadResourceVideo,
	StagedUploadTargetGenerateUploadResourceModel3d,
	StagedUploadTargetGenerateUploadResourceImage,
}

func (e StagedUploadTargetGenerateUploadResource) IsValid() bool {
	switch e {
	case StagedUploadTargetGenerateUploadResourceTimeline, StagedUploadTargetGenerateUploadResourceProductImage, StagedUploadTargetGenerateUploadResourceCollectionImage, StagedUploadTargetGenerateUploadResourceShopImage, StagedUploadTargetGenerateUploadResourceVideo, StagedUploadTargetGenerateUploadResourceModel3d, StagedUploadTargetGenerateUploadResourceImage:
		return true
	}
	return false
}

func (e StagedUploadTargetGenerateUploadResource) String() string {
	return string(e)
}

func (e *StagedUploadTargetGenerateUploadResource) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StagedUploadTargetGenerateUploadResource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StagedUploadTargetGenerateUploadResource", str)
	}
	return nil
}

func (e StagedUploadTargetGenerateUploadResource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the kind of the suggested order transaction.
type SuggestedOrderTransactionKind string

const (
	// A suggested refund transaction for an order.
	SuggestedOrderTransactionKindSuggestedRefund SuggestedOrderTransactionKind = "SUGGESTED_REFUND"
)

var AllSuggestedOrderTransactionKind = []SuggestedOrderTransactionKind{
	SuggestedOrderTransactionKindSuggestedRefund,
}

func (e SuggestedOrderTransactionKind) IsValid() bool {
	switch e {
	case SuggestedOrderTransactionKindSuggestedRefund:
		return true
	}
	return false
}

func (e SuggestedOrderTransactionKind) String() string {
	return string(e)
}

func (e *SuggestedOrderTransactionKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SuggestedOrderTransactionKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SuggestedOrderTransactionKind", str)
	}
	return nil
}

func (e SuggestedOrderTransactionKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Available customer tax exemptions.
type TaxExemption string

const (
	// This customer is exempt from specific taxes for holding a valid STATUS_CARD_EXEMPTION in Canada.
	TaxExemptionCaStatusCardExemption TaxExemption = "CA_STATUS_CARD_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid RESELLER_EXEMPTION in British Columbia.
	TaxExemptionCaBcResellerExemption TaxExemption = "CA_BC_RESELLER_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid RESELLER_EXEMPTION in Manitoba.
	TaxExemptionCaMbResellerExemption TaxExemption = "CA_MB_RESELLER_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid RESELLER_EXEMPTION in Saskatchewan.
	TaxExemptionCaSkResellerExemption TaxExemption = "CA_SK_RESELLER_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid DIPLOMAT_EXEMPTION in Canada.
	TaxExemptionCaDiplomatExemption TaxExemption = "CA_DIPLOMAT_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid COMMERCIAL_FISHERY_EXEMPTION in British Columbia.
	TaxExemptionCaBcCommercialFisheryExemption TaxExemption = "CA_BC_COMMERCIAL_FISHERY_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid COMMERCIAL_FISHERY_EXEMPTION in Manitoba.
	TaxExemptionCaMbCommercialFisheryExemption TaxExemption = "CA_MB_COMMERCIAL_FISHERY_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid COMMERCIAL_FISHERY_EXEMPTION in Nova Scotia.
	TaxExemptionCaNsCommercialFisheryExemption TaxExemption = "CA_NS_COMMERCIAL_FISHERY_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid COMMERCIAL_FISHERY_EXEMPTION in Prince Edward Island.
	TaxExemptionCaPeCommercialFisheryExemption TaxExemption = "CA_PE_COMMERCIAL_FISHERY_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid COMMERCIAL_FISHERY_EXEMPTION in Saskatchewan.
	TaxExemptionCaSkCommercialFisheryExemption TaxExemption = "CA_SK_COMMERCIAL_FISHERY_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid PRODUCTION_AND_MACHINERY_EXEMPTION in British Columbia.
	TaxExemptionCaBcProductionAndMachineryExemption TaxExemption = "CA_BC_PRODUCTION_AND_MACHINERY_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid PRODUCTION_AND_MACHINERY_EXEMPTION in Saskatchewan.
	TaxExemptionCaSkProductionAndMachineryExemption TaxExemption = "CA_SK_PRODUCTION_AND_MACHINERY_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid SUB_CONTRACTOR_EXEMPTION in British Columbia.
	TaxExemptionCaBcSubContractorExemption TaxExemption = "CA_BC_SUB_CONTRACTOR_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid SUB_CONTRACTOR_EXEMPTION in Saskatchewan.
	TaxExemptionCaSkSubContractorExemption TaxExemption = "CA_SK_SUB_CONTRACTOR_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid CONTRACTOR_EXEMPTION in British Columbia.
	TaxExemptionCaBcContractorExemption TaxExemption = "CA_BC_CONTRACTOR_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid CONTRACTOR_EXEMPTION in Saskatchewan.
	TaxExemptionCaSkContractorExemption TaxExemption = "CA_SK_CONTRACTOR_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid PURCHASE_EXEMPTION in Ontario.
	TaxExemptionCaOnPurchaseExemption TaxExemption = "CA_ON_PURCHASE_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid FARMER_EXEMPTION in Manitoba.
	TaxExemptionCaMbFarmerExemption TaxExemption = "CA_MB_FARMER_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid FARMER_EXEMPTION in Nova Scotia.
	TaxExemptionCaNsFarmerExemption TaxExemption = "CA_NS_FARMER_EXEMPTION"
	// This customer is exempt from specific taxes for holding a valid FARMER_EXEMPTION in Saskatchewan.
	TaxExemptionCaSkFarmerExemption TaxExemption = "CA_SK_FARMER_EXEMPTION"
)

var AllTaxExemption = []TaxExemption{
	TaxExemptionCaStatusCardExemption,
	TaxExemptionCaBcResellerExemption,
	TaxExemptionCaMbResellerExemption,
	TaxExemptionCaSkResellerExemption,
	TaxExemptionCaDiplomatExemption,
	TaxExemptionCaBcCommercialFisheryExemption,
	TaxExemptionCaMbCommercialFisheryExemption,
	TaxExemptionCaNsCommercialFisheryExemption,
	TaxExemptionCaPeCommercialFisheryExemption,
	TaxExemptionCaSkCommercialFisheryExemption,
	TaxExemptionCaBcProductionAndMachineryExemption,
	TaxExemptionCaSkProductionAndMachineryExemption,
	TaxExemptionCaBcSubContractorExemption,
	TaxExemptionCaSkSubContractorExemption,
	TaxExemptionCaBcContractorExemption,
	TaxExemptionCaSkContractorExemption,
	TaxExemptionCaOnPurchaseExemption,
	TaxExemptionCaMbFarmerExemption,
	TaxExemptionCaNsFarmerExemption,
	TaxExemptionCaSkFarmerExemption,
}

func (e TaxExemption) IsValid() bool {
	switch e {
	case TaxExemptionCaStatusCardExemption, TaxExemptionCaBcResellerExemption, TaxExemptionCaMbResellerExemption, TaxExemptionCaSkResellerExemption, TaxExemptionCaDiplomatExemption, TaxExemptionCaBcCommercialFisheryExemption, TaxExemptionCaMbCommercialFisheryExemption, TaxExemptionCaNsCommercialFisheryExemption, TaxExemptionCaPeCommercialFisheryExemption, TaxExemptionCaSkCommercialFisheryExemption, TaxExemptionCaBcProductionAndMachineryExemption, TaxExemptionCaSkProductionAndMachineryExemption, TaxExemptionCaBcSubContractorExemption, TaxExemptionCaSkSubContractorExemption, TaxExemptionCaBcContractorExemption, TaxExemptionCaSkContractorExemption, TaxExemptionCaOnPurchaseExemption, TaxExemptionCaMbFarmerExemption, TaxExemptionCaNsFarmerExemption, TaxExemptionCaSkFarmerExemption:
		return true
	}
	return false
}

func (e TaxExemption) String() string {
	return string(e)
}

func (e *TaxExemption) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaxExemption(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaxExemption", str)
	}
	return nil
}

func (e TaxExemption) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the type of resources that are translatable.
type TranslatableResourceType string

const (
	// Represents a product.
	TranslatableResourceTypeProduct TranslatableResourceType = "PRODUCT"
	// Represents a product variant.
	TranslatableResourceTypeProductVariant TranslatableResourceType = "PRODUCT_VARIANT"
	// Represents an email template.
	TranslatableResourceTypeEmailTemplate TranslatableResourceType = "EMAIL_TEMPLATE"
	// Represents an online store theme.
	TranslatableResourceTypeOnlineStoreTheme TranslatableResourceType = "ONLINE_STORE_THEME"
	// Represents an article.
	TranslatableResourceTypeOnlineStoreArticle TranslatableResourceType = "ONLINE_STORE_ARTICLE"
	// Represents an online store blog.
	TranslatableResourceTypeOnlineStoreBlog TranslatableResourceType = "ONLINE_STORE_BLOG"
	// Represents an online store page.
	TranslatableResourceTypeOnlineStorePage TranslatableResourceType = "ONLINE_STORE_PAGE"
	// Represents a collection of products.
	TranslatableResourceTypeCollection TranslatableResourceType = "COLLECTION"
	// Represents a link to direct users to.
	TranslatableResourceTypeLink TranslatableResourceType = "LINK"
	// Represents a metafield.
	TranslatableResourceTypeMetafield TranslatableResourceType = "METAFIELD"
	// Represents an SMS template.
	TranslatableResourceTypeSmsTemplate TranslatableResourceType = "SMS_TEMPLATE"
	// Represents a shop.
	TranslatableResourceTypeShop TranslatableResourceType = "SHOP"
	// Represents a shop policy.
	TranslatableResourceTypeShopPolicy TranslatableResourceType = "SHOP_POLICY"
	// Represents a payment gateway.
	TranslatableResourceTypePaymentGateway TranslatableResourceType = "PAYMENT_GATEWAY"
	// Represents a custom product property name like "Size", "Color", and "Material".
	TranslatableResourceTypeProductOption TranslatableResourceType = "PRODUCT_OPTION"
	// Represents a delivery method definition. For example, "Standard", or "Expedited".
	TranslatableResourceTypeDeliveryMethodDefinition TranslatableResourceType = "DELIVERY_METHOD_DEFINITION"
)

var AllTranslatableResourceType = []TranslatableResourceType{
	TranslatableResourceTypeProduct,
	TranslatableResourceTypeProductVariant,
	TranslatableResourceTypeEmailTemplate,
	TranslatableResourceTypeOnlineStoreTheme,
	TranslatableResourceTypeOnlineStoreArticle,
	TranslatableResourceTypeOnlineStoreBlog,
	TranslatableResourceTypeOnlineStorePage,
	TranslatableResourceTypeCollection,
	TranslatableResourceTypeLink,
	TranslatableResourceTypeMetafield,
	TranslatableResourceTypeSmsTemplate,
	TranslatableResourceTypeShop,
	TranslatableResourceTypeShopPolicy,
	TranslatableResourceTypePaymentGateway,
	TranslatableResourceTypeProductOption,
	TranslatableResourceTypeDeliveryMethodDefinition,
}

func (e TranslatableResourceType) IsValid() bool {
	switch e {
	case TranslatableResourceTypeProduct, TranslatableResourceTypeProductVariant, TranslatableResourceTypeEmailTemplate, TranslatableResourceTypeOnlineStoreTheme, TranslatableResourceTypeOnlineStoreArticle, TranslatableResourceTypeOnlineStoreBlog, TranslatableResourceTypeOnlineStorePage, TranslatableResourceTypeCollection, TranslatableResourceTypeLink, TranslatableResourceTypeMetafield, TranslatableResourceTypeSmsTemplate, TranslatableResourceTypeShop, TranslatableResourceTypeShopPolicy, TranslatableResourceTypePaymentGateway, TranslatableResourceTypeProductOption, TranslatableResourceTypeDeliveryMethodDefinition:
		return true
	}
	return false
}

func (e TranslatableResourceType) String() string {
	return string(e)
}

func (e *TranslatableResourceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TranslatableResourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TranslatableResourceType", str)
	}
	return nil
}

func (e TranslatableResourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible error codes that could be returned by TranslationUserError.
type TranslationErrorCode string

const (
	// Input value is blank.
	TranslationErrorCodeBlank TranslationErrorCode = "BLANK"
	// Input value is invalid.
	TranslationErrorCodeInvalid TranslationErrorCode = "INVALID"
	// Resource does not exist.
	TranslationErrorCodeResourceNotFound TranslationErrorCode = "RESOURCE_NOT_FOUND"
	// Too many translation keys for resource.
	TranslationErrorCodeTooManyKeysForResource TranslationErrorCode = "TOO_MANY_KEYS_FOR_RESOURCE"
	// Translation key is invalid.
	TranslationErrorCodeInvalidKeyForModel TranslationErrorCode = "INVALID_KEY_FOR_MODEL"
	// Translation value is invalid.
	TranslationErrorCodeFailsResourceValidation TranslationErrorCode = "FAILS_RESOURCE_VALIDATION"
	// Translatable content is invalid.
	TranslationErrorCodeInvalidTranslatableContent TranslationErrorCode = "INVALID_TRANSLATABLE_CONTENT"
	// Locale is invalid for the shop.
	TranslationErrorCodeInvalidLocaleForShop TranslationErrorCode = "INVALID_LOCALE_FOR_SHOP"
	// Locale language code is invalid.
	TranslationErrorCodeInvalidCode TranslationErrorCode = "INVALID_CODE"
	// Locale code format is invalid.
	TranslationErrorCodeInvalidFormat TranslationErrorCode = "INVALID_FORMAT"
)

var AllTranslationErrorCode = []TranslationErrorCode{
	TranslationErrorCodeBlank,
	TranslationErrorCodeInvalid,
	TranslationErrorCodeResourceNotFound,
	TranslationErrorCodeTooManyKeysForResource,
	TranslationErrorCodeInvalidKeyForModel,
	TranslationErrorCodeFailsResourceValidation,
	TranslationErrorCodeInvalidTranslatableContent,
	TranslationErrorCodeInvalidLocaleForShop,
	TranslationErrorCodeInvalidCode,
	TranslationErrorCodeInvalidFormat,
}

func (e TranslationErrorCode) IsValid() bool {
	switch e {
	case TranslationErrorCodeBlank, TranslationErrorCodeInvalid, TranslationErrorCodeResourceNotFound, TranslationErrorCodeTooManyKeysForResource, TranslationErrorCodeInvalidKeyForModel, TranslationErrorCodeFailsResourceValidation, TranslationErrorCodeInvalidTranslatableContent, TranslationErrorCodeInvalidLocaleForShop, TranslationErrorCodeInvalidCode, TranslationErrorCodeInvalidFormat:
		return true
	}
	return false
}

func (e TranslationErrorCode) String() string {
	return string(e)
}

func (e *TranslationErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TranslationErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TranslationErrorCode", str)
	}
	return nil
}

func (e TranslationErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Systems of weights and measures.
type UnitSystem string

const (
	// Imperial system of weights and measures.
	UnitSystemImperialSystem UnitSystem = "IMPERIAL_SYSTEM"
	// Metric system of weights and measures.
	UnitSystemMetricSystem UnitSystem = "METRIC_SYSTEM"
)

var AllUnitSystem = []UnitSystem{
	UnitSystemImperialSystem,
	UnitSystemMetricSystem,
}

func (e UnitSystem) IsValid() bool {
	switch e {
	case UnitSystemImperialSystem, UnitSystemMetricSystem:
		return true
	}
	return false
}

func (e UnitSystem) String() string {
	return string(e)
}

func (e *UnitSystem) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitSystem(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitSystem", str)
	}
	return nil
}

func (e UnitSystem) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The supported formats for webhook subscriptions.
type WebhookSubscriptionFormat string

const (
	WebhookSubscriptionFormatJSON WebhookSubscriptionFormat = "JSON"
	WebhookSubscriptionFormatXML  WebhookSubscriptionFormat = "XML"
)

var AllWebhookSubscriptionFormat = []WebhookSubscriptionFormat{
	WebhookSubscriptionFormatJSON,
	WebhookSubscriptionFormatXML,
}

func (e WebhookSubscriptionFormat) IsValid() bool {
	switch e {
	case WebhookSubscriptionFormatJSON, WebhookSubscriptionFormatXML:
		return true
	}
	return false
}

func (e WebhookSubscriptionFormat) String() string {
	return string(e)
}

func (e *WebhookSubscriptionFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookSubscriptionFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookSubscriptionFormat", str)
	}
	return nil
}

func (e WebhookSubscriptionFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The set of valid sort keys for the WebhookSubscription query.
type WebhookSubscriptionSortKeys string

const (
	// Sort by the `created_at` value.
	WebhookSubscriptionSortKeysCreatedAt WebhookSubscriptionSortKeys = "CREATED_AT"
	// Sort by the `id` value.
	WebhookSubscriptionSortKeysID WebhookSubscriptionSortKeys = "ID"
	// During a search (i.e. when the `query` parameter has been specified on the connection) this sorts the
	// results by relevance to the search term(s). When no search query is specified, this sort key is not
	// deterministic and should not be used.
	//
	WebhookSubscriptionSortKeysRelevance WebhookSubscriptionSortKeys = "RELEVANCE"
)

var AllWebhookSubscriptionSortKeys = []WebhookSubscriptionSortKeys{
	WebhookSubscriptionSortKeysCreatedAt,
	WebhookSubscriptionSortKeysID,
	WebhookSubscriptionSortKeysRelevance,
}

func (e WebhookSubscriptionSortKeys) IsValid() bool {
	switch e {
	case WebhookSubscriptionSortKeysCreatedAt, WebhookSubscriptionSortKeysID, WebhookSubscriptionSortKeysRelevance:
		return true
	}
	return false
}

func (e WebhookSubscriptionSortKeys) String() string {
	return string(e)
}

func (e *WebhookSubscriptionSortKeys) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookSubscriptionSortKeys(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookSubscriptionSortKeys", str)
	}
	return nil
}

func (e WebhookSubscriptionSortKeys) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The supported topics for webhook subscriptions.
type WebhookSubscriptionTopic string

const (
	// The webhook topic for `app/uninstalled` events.
	WebhookSubscriptionTopicAppUninstalled WebhookSubscriptionTopic = "APP_UNINSTALLED"
	// The webhook topic for `carts/create` events.
	WebhookSubscriptionTopicCartsCreate WebhookSubscriptionTopic = "CARTS_CREATE"
	// The webhook topic for `carts/update` events.
	WebhookSubscriptionTopicCartsUpdate WebhookSubscriptionTopic = "CARTS_UPDATE"
	// The webhook topic for `channels/delete` events.
	WebhookSubscriptionTopicChannelsDelete WebhookSubscriptionTopic = "CHANNELS_DELETE"
	// The webhook topic for `checkouts/create` events.
	WebhookSubscriptionTopicCheckoutsCreate WebhookSubscriptionTopic = "CHECKOUTS_CREATE"
	// The webhook topic for `checkouts/delete` events.
	WebhookSubscriptionTopicCheckoutsDelete WebhookSubscriptionTopic = "CHECKOUTS_DELETE"
	// The webhook topic for `checkouts/update` events.
	WebhookSubscriptionTopicCheckoutsUpdate WebhookSubscriptionTopic = "CHECKOUTS_UPDATE"
	// The webhook topic for `collection_listings/add` events.
	WebhookSubscriptionTopicCollectionListingsAdd WebhookSubscriptionTopic = "COLLECTION_LISTINGS_ADD"
	// The webhook topic for `collection_listings/remove` events.
	WebhookSubscriptionTopicCollectionListingsRemove WebhookSubscriptionTopic = "COLLECTION_LISTINGS_REMOVE"
	// The webhook topic for `collection_listings/update` events.
	WebhookSubscriptionTopicCollectionListingsUpdate WebhookSubscriptionTopic = "COLLECTION_LISTINGS_UPDATE"
	// The webhook topic for `collection_publications/create` events.
	WebhookSubscriptionTopicCollectionPublicationsCreate WebhookSubscriptionTopic = "COLLECTION_PUBLICATIONS_CREATE"
	// The webhook topic for `collection_publications/delete` events.
	WebhookSubscriptionTopicCollectionPublicationsDelete WebhookSubscriptionTopic = "COLLECTION_PUBLICATIONS_DELETE"
	// The webhook topic for `collection_publications/update` events.
	WebhookSubscriptionTopicCollectionPublicationsUpdate WebhookSubscriptionTopic = "COLLECTION_PUBLICATIONS_UPDATE"
	// The webhook topic for `collections/create` events.
	WebhookSubscriptionTopicCollectionsCreate WebhookSubscriptionTopic = "COLLECTIONS_CREATE"
	// The webhook topic for `collections/delete` events.
	WebhookSubscriptionTopicCollectionsDelete WebhookSubscriptionTopic = "COLLECTIONS_DELETE"
	// The webhook topic for `collections/update` events.
	WebhookSubscriptionTopicCollectionsUpdate WebhookSubscriptionTopic = "COLLECTIONS_UPDATE"
	// The webhook topic for `customer_groups/create` events.
	WebhookSubscriptionTopicCustomerGroupsCreate WebhookSubscriptionTopic = "CUSTOMER_GROUPS_CREATE"
	// The webhook topic for `customer_groups/delete` events.
	WebhookSubscriptionTopicCustomerGroupsDelete WebhookSubscriptionTopic = "CUSTOMER_GROUPS_DELETE"
	// The webhook topic for `customer_groups/update` events.
	WebhookSubscriptionTopicCustomerGroupsUpdate WebhookSubscriptionTopic = "CUSTOMER_GROUPS_UPDATE"
	// The webhook topic for `customers/create` events.
	WebhookSubscriptionTopicCustomersCreate WebhookSubscriptionTopic = "CUSTOMERS_CREATE"
	// The webhook topic for `customers/delete` events.
	WebhookSubscriptionTopicCustomersDelete WebhookSubscriptionTopic = "CUSTOMERS_DELETE"
	// The webhook topic for `customers/disable` events.
	WebhookSubscriptionTopicCustomersDisable WebhookSubscriptionTopic = "CUSTOMERS_DISABLE"
	// The webhook topic for `customers/enable` events.
	WebhookSubscriptionTopicCustomersEnable WebhookSubscriptionTopic = "CUSTOMERS_ENABLE"
	// The webhook topic for `customers/update` events.
	WebhookSubscriptionTopicCustomersUpdate WebhookSubscriptionTopic = "CUSTOMERS_UPDATE"
	// The webhook topic for `disputes/create` events.
	WebhookSubscriptionTopicDisputesCreate WebhookSubscriptionTopic = "DISPUTES_CREATE"
	// The webhook topic for `disputes/update` events.
	WebhookSubscriptionTopicDisputesUpdate WebhookSubscriptionTopic = "DISPUTES_UPDATE"
	// The webhook topic for `draft_orders/create` events.
	WebhookSubscriptionTopicDraftOrdersCreate WebhookSubscriptionTopic = "DRAFT_ORDERS_CREATE"
	// The webhook topic for `draft_orders/delete` events.
	WebhookSubscriptionTopicDraftOrdersDelete WebhookSubscriptionTopic = "DRAFT_ORDERS_DELETE"
	// The webhook topic for `draft_orders/update` events.
	WebhookSubscriptionTopicDraftOrdersUpdate WebhookSubscriptionTopic = "DRAFT_ORDERS_UPDATE"
	// The webhook topic for `fulfillment_events/create` events.
	WebhookSubscriptionTopicFulfillmentEventsCreate WebhookSubscriptionTopic = "FULFILLMENT_EVENTS_CREATE"
	// The webhook topic for `fulfillment_events/delete` events.
	WebhookSubscriptionTopicFulfillmentEventsDelete WebhookSubscriptionTopic = "FULFILLMENT_EVENTS_DELETE"
	// The webhook topic for `fulfillments/create` events.
	WebhookSubscriptionTopicFulfillmentsCreate WebhookSubscriptionTopic = "FULFILLMENTS_CREATE"
	// The webhook topic for `fulfillments/update` events.
	WebhookSubscriptionTopicFulfillmentsUpdate WebhookSubscriptionTopic = "FULFILLMENTS_UPDATE"
	// The webhook topic for `attributed_sessions/first` events.
	WebhookSubscriptionTopicAttributedSessionsFirst WebhookSubscriptionTopic = "ATTRIBUTED_SESSIONS_FIRST"
	// The webhook topic for `attributed_sessions/last` events.
	WebhookSubscriptionTopicAttributedSessionsLast WebhookSubscriptionTopic = "ATTRIBUTED_SESSIONS_LAST"
	// The webhook topic for `order_transactions/create` events.
	WebhookSubscriptionTopicOrderTransactionsCreate WebhookSubscriptionTopic = "ORDER_TRANSACTIONS_CREATE"
	// The webhook topic for `orders/cancelled` events.
	WebhookSubscriptionTopicOrdersCancelled WebhookSubscriptionTopic = "ORDERS_CANCELLED"
	// The webhook topic for `orders/create` events.
	WebhookSubscriptionTopicOrdersCreate WebhookSubscriptionTopic = "ORDERS_CREATE"
	// The webhook topic for `orders/delete` events.
	WebhookSubscriptionTopicOrdersDelete WebhookSubscriptionTopic = "ORDERS_DELETE"
	// The webhook topic for `orders/edited` events.
	WebhookSubscriptionTopicOrdersEdited WebhookSubscriptionTopic = "ORDERS_EDITED"
	// The webhook topic for `orders/fulfilled` events.
	WebhookSubscriptionTopicOrdersFulfilled WebhookSubscriptionTopic = "ORDERS_FULFILLED"
	// The webhook topic for `orders/paid` events.
	WebhookSubscriptionTopicOrdersPaid WebhookSubscriptionTopic = "ORDERS_PAID"
	// The webhook topic for `orders/partially_fulfilled` events.
	WebhookSubscriptionTopicOrdersPartiallyFulfilled WebhookSubscriptionTopic = "ORDERS_PARTIALLY_FULFILLED"
	// The webhook topic for `orders/updated` events.
	WebhookSubscriptionTopicOrdersUpdated WebhookSubscriptionTopic = "ORDERS_UPDATED"
	// The webhook topic for `product_listings/add` events.
	WebhookSubscriptionTopicProductListingsAdd WebhookSubscriptionTopic = "PRODUCT_LISTINGS_ADD"
	// The webhook topic for `product_listings/remove` events.
	WebhookSubscriptionTopicProductListingsRemove WebhookSubscriptionTopic = "PRODUCT_LISTINGS_REMOVE"
	// The webhook topic for `product_listings/update` events.
	WebhookSubscriptionTopicProductListingsUpdate WebhookSubscriptionTopic = "PRODUCT_LISTINGS_UPDATE"
	// The webhook topic for `product_publications/create` events.
	WebhookSubscriptionTopicProductPublicationsCreate WebhookSubscriptionTopic = "PRODUCT_PUBLICATIONS_CREATE"
	// The webhook topic for `product_publications/delete` events.
	WebhookSubscriptionTopicProductPublicationsDelete WebhookSubscriptionTopic = "PRODUCT_PUBLICATIONS_DELETE"
	// The webhook topic for `product_publications/update` events.
	WebhookSubscriptionTopicProductPublicationsUpdate WebhookSubscriptionTopic = "PRODUCT_PUBLICATIONS_UPDATE"
	// The webhook topic for `products/create` events.
	WebhookSubscriptionTopicProductsCreate WebhookSubscriptionTopic = "PRODUCTS_CREATE"
	// The webhook topic for `products/delete` events.
	WebhookSubscriptionTopicProductsDelete WebhookSubscriptionTopic = "PRODUCTS_DELETE"
	// The webhook topic for `products/update` events.
	WebhookSubscriptionTopicProductsUpdate WebhookSubscriptionTopic = "PRODUCTS_UPDATE"
	// The webhook topic for `refunds/create` events.
	WebhookSubscriptionTopicRefundsCreate WebhookSubscriptionTopic = "REFUNDS_CREATE"
	// The webhook topic for `shipping_addresses/create` events.
	WebhookSubscriptionTopicShippingAddressesCreate WebhookSubscriptionTopic = "SHIPPING_ADDRESSES_CREATE"
	// The webhook topic for `shipping_addresses/update` events.
	WebhookSubscriptionTopicShippingAddressesUpdate WebhookSubscriptionTopic = "SHIPPING_ADDRESSES_UPDATE"
	// The webhook topic for `shop/update` events.
	WebhookSubscriptionTopicShopUpdate WebhookSubscriptionTopic = "SHOP_UPDATE"
	// The webhook topic for `tax_services/create` events.
	WebhookSubscriptionTopicTaxServicesCreate WebhookSubscriptionTopic = "TAX_SERVICES_CREATE"
	// The webhook topic for `tax_services/update` events.
	WebhookSubscriptionTopicTaxServicesUpdate WebhookSubscriptionTopic = "TAX_SERVICES_UPDATE"
	// The webhook topic for `themes/create` events.
	WebhookSubscriptionTopicThemesCreate WebhookSubscriptionTopic = "THEMES_CREATE"
	// The webhook topic for `themes/delete` events.
	WebhookSubscriptionTopicThemesDelete WebhookSubscriptionTopic = "THEMES_DELETE"
	// The webhook topic for `themes/publish` events.
	WebhookSubscriptionTopicThemesPublish WebhookSubscriptionTopic = "THEMES_PUBLISH"
	// The webhook topic for `themes/update` events.
	WebhookSubscriptionTopicThemesUpdate WebhookSubscriptionTopic = "THEMES_UPDATE"
	// The webhook topic for `variants/in_stock` events.
	WebhookSubscriptionTopicVariantsInStock WebhookSubscriptionTopic = "VARIANTS_IN_STOCK"
	// The webhook topic for `variants/out_of_stock` events.
	WebhookSubscriptionTopicVariantsOutOfStock WebhookSubscriptionTopic = "VARIANTS_OUT_OF_STOCK"
	// The webhook topic for `inventory_levels/connect` events.
	WebhookSubscriptionTopicInventoryLevelsConnect WebhookSubscriptionTopic = "INVENTORY_LEVELS_CONNECT"
	// The webhook topic for `inventory_levels/update` events.
	WebhookSubscriptionTopicInventoryLevelsUpdate WebhookSubscriptionTopic = "INVENTORY_LEVELS_UPDATE"
	// The webhook topic for `inventory_levels/disconnect` events.
	WebhookSubscriptionTopicInventoryLevelsDisconnect WebhookSubscriptionTopic = "INVENTORY_LEVELS_DISCONNECT"
	// The webhook topic for `attribution/risk` events.
	WebhookSubscriptionTopicAttributionRisk WebhookSubscriptionTopic = "ATTRIBUTION_RISK"
	// The webhook topic for `inventory_items/create` events.
	WebhookSubscriptionTopicInventoryItemsCreate WebhookSubscriptionTopic = "INVENTORY_ITEMS_CREATE"
	// The webhook topic for `inventory_items/update` events.
	WebhookSubscriptionTopicInventoryItemsUpdate WebhookSubscriptionTopic = "INVENTORY_ITEMS_UPDATE"
	// The webhook topic for `inventory_items/delete` events.
	WebhookSubscriptionTopicInventoryItemsDelete WebhookSubscriptionTopic = "INVENTORY_ITEMS_DELETE"
	// The webhook topic for `locations/create` events.
	WebhookSubscriptionTopicLocationsCreate WebhookSubscriptionTopic = "LOCATIONS_CREATE"
	// The webhook topic for `locations/update` events.
	WebhookSubscriptionTopicLocationsUpdate WebhookSubscriptionTopic = "LOCATIONS_UPDATE"
	// The webhook topic for `locations/delete` events.
	WebhookSubscriptionTopicLocationsDelete WebhookSubscriptionTopic = "LOCATIONS_DELETE"
	// The webhook topic for `tender_transactions/create` events.
	WebhookSubscriptionTopicTenderTransactionsCreate WebhookSubscriptionTopic = "TENDER_TRANSACTIONS_CREATE"
	// The webhook topic for `app_purchases_one_time/update` events.
	WebhookSubscriptionTopicAppPurchasesOneTimeUpdate WebhookSubscriptionTopic = "APP_PURCHASES_ONE_TIME_UPDATE"
	// The webhook topic for `app_subscriptions/update` events.
	WebhookSubscriptionTopicAppSubscriptionsUpdate WebhookSubscriptionTopic = "APP_SUBSCRIPTIONS_UPDATE"
	// The webhook topic for `locales/create` events.
	WebhookSubscriptionTopicLocalesCreate WebhookSubscriptionTopic = "LOCALES_CREATE"
	// The webhook topic for `locales/update` events.
	WebhookSubscriptionTopicLocalesUpdate WebhookSubscriptionTopic = "LOCALES_UPDATE"
	// The webhook topic for `domains/create` events.
	WebhookSubscriptionTopicDomainsCreate WebhookSubscriptionTopic = "DOMAINS_CREATE"
	// The webhook topic for `domains/update` events.
	WebhookSubscriptionTopicDomainsUpdate WebhookSubscriptionTopic = "DOMAINS_UPDATE"
	// The webhook topic for `domains/destroy` events.
	WebhookSubscriptionTopicDomainsDestroy WebhookSubscriptionTopic = "DOMAINS_DESTROY"
	// The webhook topic for `profiles/create` events.
	WebhookSubscriptionTopicProfilesCreate WebhookSubscriptionTopic = "PROFILES_CREATE"
	// The webhook topic for `profiles/update` events.
	WebhookSubscriptionTopicProfilesUpdate WebhookSubscriptionTopic = "PROFILES_UPDATE"
	// The webhook topic for `profiles/delete` events.
	WebhookSubscriptionTopicProfilesDelete WebhookSubscriptionTopic = "PROFILES_DELETE"
)

var AllWebhookSubscriptionTopic = []WebhookSubscriptionTopic{
	WebhookSubscriptionTopicAppUninstalled,
	WebhookSubscriptionTopicCartsCreate,
	WebhookSubscriptionTopicCartsUpdate,
	WebhookSubscriptionTopicChannelsDelete,
	WebhookSubscriptionTopicCheckoutsCreate,
	WebhookSubscriptionTopicCheckoutsDelete,
	WebhookSubscriptionTopicCheckoutsUpdate,
	WebhookSubscriptionTopicCollectionListingsAdd,
	WebhookSubscriptionTopicCollectionListingsRemove,
	WebhookSubscriptionTopicCollectionListingsUpdate,
	WebhookSubscriptionTopicCollectionPublicationsCreate,
	WebhookSubscriptionTopicCollectionPublicationsDelete,
	WebhookSubscriptionTopicCollectionPublicationsUpdate,
	WebhookSubscriptionTopicCollectionsCreate,
	WebhookSubscriptionTopicCollectionsDelete,
	WebhookSubscriptionTopicCollectionsUpdate,
	WebhookSubscriptionTopicCustomerGroupsCreate,
	WebhookSubscriptionTopicCustomerGroupsDelete,
	WebhookSubscriptionTopicCustomerGroupsUpdate,
	WebhookSubscriptionTopicCustomersCreate,
	WebhookSubscriptionTopicCustomersDelete,
	WebhookSubscriptionTopicCustomersDisable,
	WebhookSubscriptionTopicCustomersEnable,
	WebhookSubscriptionTopicCustomersUpdate,
	WebhookSubscriptionTopicDisputesCreate,
	WebhookSubscriptionTopicDisputesUpdate,
	WebhookSubscriptionTopicDraftOrdersCreate,
	WebhookSubscriptionTopicDraftOrdersDelete,
	WebhookSubscriptionTopicDraftOrdersUpdate,
	WebhookSubscriptionTopicFulfillmentEventsCreate,
	WebhookSubscriptionTopicFulfillmentEventsDelete,
	WebhookSubscriptionTopicFulfillmentsCreate,
	WebhookSubscriptionTopicFulfillmentsUpdate,
	WebhookSubscriptionTopicAttributedSessionsFirst,
	WebhookSubscriptionTopicAttributedSessionsLast,
	WebhookSubscriptionTopicOrderTransactionsCreate,
	WebhookSubscriptionTopicOrdersCancelled,
	WebhookSubscriptionTopicOrdersCreate,
	WebhookSubscriptionTopicOrdersDelete,
	WebhookSubscriptionTopicOrdersEdited,
	WebhookSubscriptionTopicOrdersFulfilled,
	WebhookSubscriptionTopicOrdersPaid,
	WebhookSubscriptionTopicOrdersPartiallyFulfilled,
	WebhookSubscriptionTopicOrdersUpdated,
	WebhookSubscriptionTopicProductListingsAdd,
	WebhookSubscriptionTopicProductListingsRemove,
	WebhookSubscriptionTopicProductListingsUpdate,
	WebhookSubscriptionTopicProductPublicationsCreate,
	WebhookSubscriptionTopicProductPublicationsDelete,
	WebhookSubscriptionTopicProductPublicationsUpdate,
	WebhookSubscriptionTopicProductsCreate,
	WebhookSubscriptionTopicProductsDelete,
	WebhookSubscriptionTopicProductsUpdate,
	WebhookSubscriptionTopicRefundsCreate,
	WebhookSubscriptionTopicShippingAddressesCreate,
	WebhookSubscriptionTopicShippingAddressesUpdate,
	WebhookSubscriptionTopicShopUpdate,
	WebhookSubscriptionTopicTaxServicesCreate,
	WebhookSubscriptionTopicTaxServicesUpdate,
	WebhookSubscriptionTopicThemesCreate,
	WebhookSubscriptionTopicThemesDelete,
	WebhookSubscriptionTopicThemesPublish,
	WebhookSubscriptionTopicThemesUpdate,
	WebhookSubscriptionTopicVariantsInStock,
	WebhookSubscriptionTopicVariantsOutOfStock,
	WebhookSubscriptionTopicInventoryLevelsConnect,
	WebhookSubscriptionTopicInventoryLevelsUpdate,
	WebhookSubscriptionTopicInventoryLevelsDisconnect,
	WebhookSubscriptionTopicAttributionRisk,
	WebhookSubscriptionTopicInventoryItemsCreate,
	WebhookSubscriptionTopicInventoryItemsUpdate,
	WebhookSubscriptionTopicInventoryItemsDelete,
	WebhookSubscriptionTopicLocationsCreate,
	WebhookSubscriptionTopicLocationsUpdate,
	WebhookSubscriptionTopicLocationsDelete,
	WebhookSubscriptionTopicTenderTransactionsCreate,
	WebhookSubscriptionTopicAppPurchasesOneTimeUpdate,
	WebhookSubscriptionTopicAppSubscriptionsUpdate,
	WebhookSubscriptionTopicLocalesCreate,
	WebhookSubscriptionTopicLocalesUpdate,
	WebhookSubscriptionTopicDomainsCreate,
	WebhookSubscriptionTopicDomainsUpdate,
	WebhookSubscriptionTopicDomainsDestroy,
	WebhookSubscriptionTopicProfilesCreate,
	WebhookSubscriptionTopicProfilesUpdate,
	WebhookSubscriptionTopicProfilesDelete,
}

func (e WebhookSubscriptionTopic) IsValid() bool {
	switch e {
	case WebhookSubscriptionTopicAppUninstalled, WebhookSubscriptionTopicCartsCreate, WebhookSubscriptionTopicCartsUpdate, WebhookSubscriptionTopicChannelsDelete, WebhookSubscriptionTopicCheckoutsCreate, WebhookSubscriptionTopicCheckoutsDelete, WebhookSubscriptionTopicCheckoutsUpdate, WebhookSubscriptionTopicCollectionListingsAdd, WebhookSubscriptionTopicCollectionListingsRemove, WebhookSubscriptionTopicCollectionListingsUpdate, WebhookSubscriptionTopicCollectionPublicationsCreate, WebhookSubscriptionTopicCollectionPublicationsDelete, WebhookSubscriptionTopicCollectionPublicationsUpdate, WebhookSubscriptionTopicCollectionsCreate, WebhookSubscriptionTopicCollectionsDelete, WebhookSubscriptionTopicCollectionsUpdate, WebhookSubscriptionTopicCustomerGroupsCreate, WebhookSubscriptionTopicCustomerGroupsDelete, WebhookSubscriptionTopicCustomerGroupsUpdate, WebhookSubscriptionTopicCustomersCreate, WebhookSubscriptionTopicCustomersDelete, WebhookSubscriptionTopicCustomersDisable, WebhookSubscriptionTopicCustomersEnable, WebhookSubscriptionTopicCustomersUpdate, WebhookSubscriptionTopicDisputesCreate, WebhookSubscriptionTopicDisputesUpdate, WebhookSubscriptionTopicDraftOrdersCreate, WebhookSubscriptionTopicDraftOrdersDelete, WebhookSubscriptionTopicDraftOrdersUpdate, WebhookSubscriptionTopicFulfillmentEventsCreate, WebhookSubscriptionTopicFulfillmentEventsDelete, WebhookSubscriptionTopicFulfillmentsCreate, WebhookSubscriptionTopicFulfillmentsUpdate, WebhookSubscriptionTopicAttributedSessionsFirst, WebhookSubscriptionTopicAttributedSessionsLast, WebhookSubscriptionTopicOrderTransactionsCreate, WebhookSubscriptionTopicOrdersCancelled, WebhookSubscriptionTopicOrdersCreate, WebhookSubscriptionTopicOrdersDelete, WebhookSubscriptionTopicOrdersEdited, WebhookSubscriptionTopicOrdersFulfilled, WebhookSubscriptionTopicOrdersPaid, WebhookSubscriptionTopicOrdersPartiallyFulfilled, WebhookSubscriptionTopicOrdersUpdated, WebhookSubscriptionTopicProductListingsAdd, WebhookSubscriptionTopicProductListingsRemove, WebhookSubscriptionTopicProductListingsUpdate, WebhookSubscriptionTopicProductPublicationsCreate, WebhookSubscriptionTopicProductPublicationsDelete, WebhookSubscriptionTopicProductPublicationsUpdate, WebhookSubscriptionTopicProductsCreate, WebhookSubscriptionTopicProductsDelete, WebhookSubscriptionTopicProductsUpdate, WebhookSubscriptionTopicRefundsCreate, WebhookSubscriptionTopicShippingAddressesCreate, WebhookSubscriptionTopicShippingAddressesUpdate, WebhookSubscriptionTopicShopUpdate, WebhookSubscriptionTopicTaxServicesCreate, WebhookSubscriptionTopicTaxServicesUpdate, WebhookSubscriptionTopicThemesCreate, WebhookSubscriptionTopicThemesDelete, WebhookSubscriptionTopicThemesPublish, WebhookSubscriptionTopicThemesUpdate, WebhookSubscriptionTopicVariantsInStock, WebhookSubscriptionTopicVariantsOutOfStock, WebhookSubscriptionTopicInventoryLevelsConnect, WebhookSubscriptionTopicInventoryLevelsUpdate, WebhookSubscriptionTopicInventoryLevelsDisconnect, WebhookSubscriptionTopicAttributionRisk, WebhookSubscriptionTopicInventoryItemsCreate, WebhookSubscriptionTopicInventoryItemsUpdate, WebhookSubscriptionTopicInventoryItemsDelete, WebhookSubscriptionTopicLocationsCreate, WebhookSubscriptionTopicLocationsUpdate, WebhookSubscriptionTopicLocationsDelete, WebhookSubscriptionTopicTenderTransactionsCreate, WebhookSubscriptionTopicAppPurchasesOneTimeUpdate, WebhookSubscriptionTopicAppSubscriptionsUpdate, WebhookSubscriptionTopicLocalesCreate, WebhookSubscriptionTopicLocalesUpdate, WebhookSubscriptionTopicDomainsCreate, WebhookSubscriptionTopicDomainsUpdate, WebhookSubscriptionTopicDomainsDestroy, WebhookSubscriptionTopicProfilesCreate, WebhookSubscriptionTopicProfilesUpdate, WebhookSubscriptionTopicProfilesDelete:
		return true
	}
	return false
}

func (e WebhookSubscriptionTopic) String() string {
	return string(e)
}

func (e *WebhookSubscriptionTopic) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookSubscriptionTopic(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookSubscriptionTopic", str)
	}
	return nil
}

func (e WebhookSubscriptionTopic) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Units of measurement for weight.
type WeightUnit string

const (
	// 1 kilogram equals 1000 grams.
	WeightUnitKilograms WeightUnit = "KILOGRAMS"
	// Metric system unit of mass.
	WeightUnitGrams WeightUnit = "GRAMS"
	// 1 pound equals 16 ounces.
	WeightUnitPounds WeightUnit = "POUNDS"
	// Imperial system unit of mass.
	WeightUnitOunces WeightUnit = "OUNCES"
)

var AllWeightUnit = []WeightUnit{
	WeightUnitKilograms,
	WeightUnitGrams,
	WeightUnitPounds,
	WeightUnitOunces,
}

func (e WeightUnit) IsValid() bool {
	switch e {
	case WeightUnitKilograms, WeightUnitGrams, WeightUnitPounds, WeightUnitOunces:
		return true
	}
	return false
}

func (e WeightUnit) String() string {
	return string(e)
}

func (e *WeightUnit) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WeightUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WeightUnit", str)
	}
	return nil
}

func (e WeightUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
